<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZWZ的博客嘻嘻">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Git/" class="post-title-link" itemprop="url">Git</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-12 21:52:26" itemprop="dateModified" datetime="2020-04-12T21:52:26+08:00">2020-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
</blockquote>
<blockquote>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
</blockquote>
<blockquote>
<p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
</blockquote>
<h3 id="版本控制工具的功能"><a href="#版本控制工具的功能" class="headerlink" title="版本控制工具的功能"></a>版本控制工具的功能</h3><ul>
<li>协同修改<ul>
<li>多人并行不悖的修改服务端的同一个文件</li>
</ul>
</li>
<li>数据备份<ul>
<li>不仅保存目录和文件的当前状态，还能够保存每一个提交的历史状态。</li>
</ul>
</li>
<li>版本管理<ul>
<li>在保存每一个版本文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。在这方面SVN采用的是增量式管理的方式，而Git采取了文件系统快照的方式</li>
</ul>
</li>
<li>权限控制<ul>
<li>对团队中参与开发的人员进行权限控制。</li>
<li>对团队外开发贡献的代码进行审核 ——Git独有</li>
</ul>
</li>
<li>历史记录<ul>
<li>查看修改人，修改时间，修改内容，日志信息。</li>
<li>将本地文件恢复到某一个历史状态。</li>
</ul>
</li>
<li>分支管理<ul>
<li>允许开发团队在文件过程中多条生产线同时推进任务，进一步提高效率。<h3 id="Git优点"><a href="#Git优点" class="headerlink" title="Git优点"></a>Git优点</h3></li>
</ul>
</li>
</ul>
<ol>
<li>大部分操作在本地完成，不需要联网。</li>
<li>完整性保证。</li>
<li>尽可能添加数据而不是删除或修改数据</li>
<li>分支操作非常快捷</li>
<li>与Linux命令全面兼容</li>
</ol>
<h3 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h3><p>一般流程如下：</p>
<ul>
<li>克隆Git资源为工作目录。</li>
<li>在克隆的资源上添加或修改文件</li>
<li>如果其他人修改了，你可以更新资源</li>
<li>在提交前查看修改</li>
<li>提交修改</li>
<li>在修改完成后发现错，可以撤回提交并再次修改并提交。<br><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png" alt=""></li>
</ul>
<h3 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h3><p>工作区：就是你在电脑里面可以看到的目录。<br>暂存区：英文名叫stage或者index。一般存放在 .git 目录下的index文件(.git/index)中，所以我们把暂存区有时也叫做索引(index)。<br>版本库：工作区有个隐藏目录 .git，这个不算工作区，耳式Git的版本库。<br><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt=""></p>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>是多功能命令，根据目标文件的状态不同，命令效果也不同</br><br>1）. 可以用它跟踪新文件</br><br>2）. 把已经跟踪的文件放进暂存区</br><br>3）. 还能用于合并时把有冲突的文件标记为已解决状态等</br><br>如图：add把工作区的文件加入了暂存区。</p>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>git commit主要是将在暂存区里的改动提交到本地的版本库。每次使用git commit都会产生40位的哈希值，这个哈希值也叫commit-id.</br><br>commit-id在版本回退时候很有用搭配reset可以进行版本的进退。</p>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>git reset [选项] [commit-id]有三个选项可以选择 –soft、–mixed、–hard</p>
<ol>
<li>git reset –soft仅将head指针指向历史版本。</li>
<li>git reset –mixed将head指针指向历史版本，且用历史版本的暂存区覆盖当前的暂存区</li>
<li>git reset –hard将head指针指向历史版本，同时覆盖工作区和暂存区的内容(比较危险，慎用)</li>
</ol>
<h4 id="git-checkout-git-checkout-lt-file-gt"><a href="#git-checkout-git-checkout-lt-file-gt" class="headerlink" title="git checkout / git checkout &lt;-file&gt;"></a>git checkout / git checkout &lt;-file&gt;</h4><p>git checkout或checkout – <file> 会将暂存区全部或指定的文件替换工作区的文件，这个操作很危险，会清除工作区中未添加到暂存区的改动。</p>
<h4 id="git-rm-–cached"><a href="#git-rm-–cached" class="headerlink" title="git rm –cached"></a>git rm –cached</h4><p>执行<code>git rm --cached</code>命令的时候会直接从暂存区删除文件，工作区则不会做出改变。</p>
<h4 id="git-checkout-HEAD-git-checkout-HEAD"><a href="#git-checkout-HEAD-git-checkout-HEAD" class="headerlink" title="git checkout HEAD / git checkout HEAD "></a>git checkout HEAD / git checkout HEAD <file></h4><p>当执行<code>git checkout HEAD</code>或者<code>git checkout Head &lt;file&gt;</code>时候，会用HEAD指向master分支中的全部或部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区未提交的改动。</p>
<h3 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h3><ol>
<li><p><strong>git init</strong>来初始化一个仓库，Git的很多指令都需要在Git的仓库中运行，所以git init是使用Git的第一个命令。执行完git init后会出现一个<code>.git</code>隐藏目录。在当前目录下git bash 输入<code>ls lA</code>(Linux通用)即可出现。</p>
</li>
<li><p><strong>git clone</strong>可以从现有Git仓库中拷贝项目</br><br>格式一般为git clone <repo> <directory></p>
<ul>
<li><p>repo:Git 仓库。</p>
</li>
<li><p>directory:本地目录。<br>例子：比如克隆Ruby语言的Git代码仓库Grit，使用以下命令</p>
<p><code>git clone git://github.com/schacon/grit.git</code></p>
</li>
</ul>
</li>
</ol>
<p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</br><br>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<pre><code>`git clone git://github.com schacon/grit.git mygrit`</code></pre><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>可以查看在上次提交之后是否有修改。</p>
<pre><code>$ git status
On branch master

Initial commit

Changes to be committed:
  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)

    new file:   README
    new file:   hello.php</code></pre><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>执行git diff来查看执行git status的结果的详细信息<br>git diff命令显示已写入缓存与已修改但未写入缓存的改动的区别。git diff有两个主要的应用场景</p>
<ul>
<li>尚未缓存的改动：<strong>git diff</strong></li>
<li>查看已缓存的改动：<strong>git diff –cached</strong></li>
<li>查看已缓存的与未缓存的所有改动：<strong>git diff HEAD</strong></li>
<li>显示摘要而非整个diff：<strong>git diff –stat</strong></li>
</ul>
<h4 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h4><p>git mv命令用于移动或者重命名一个文件、目录、软连接。<br>例如重命名：$ git mv [原文件名] [修改后文件名]</p>
<h3 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><p>几乎每一个版本控制系统都以某种形式支持分支。使用分支就意味着可以从开发主线上分离开，不影响主线继续工作。创建分支：</p>
<pre><code>`git branch (branchname)`</code></pre><p>切换分支命令：</p>
<pre><code>`git checkout (branchname)`</code></pre><p>当切换分支的时候，Git会用该分支最后提交的快照替换你的工作目录内容，所有多个分支不需要多个目录。</p>
<p>合并分支命令：</p>
<pre><code>`git merge`</code></pre><p>你可以多次合并到一分支，也可以选择在合并之后直接删除被并入的分支。</p>
<h3 id="Git-分支管理-1"><a href="#Git-分支管理-1" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><h4 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h4><p>列出分支基本命令:</p>
<pre><code>`git branch`</code></pre><p>没有参数时，git branch会列出你在本地的分支。</p>
<pre><code>$ git branch
* master</code></pre><p>这里是说我们有个叫做master的分支，并且该分支还是当前分支。在git init之后会默认创建master分支。</br><br>我们通过git checkout(branch)修改到我们需要切换的分支</p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>删除分支命令：</p>
<pre><code>`git branch -d (branchname)`</code></pre><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>分支合并命令：</p>
<pre><code>`git merge`</code></pre><h3 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h3><p>在使用Git提交若干更新之后，又或者克隆了某个项目，想回顾一下提交历史，我们可以使用git log命令查看。</p>
<ul>
<li>git log –oneline可以看历史记录的简介版本</li>
<li>还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项</li>
<li>可以用 –reverse 参数来逆向显示所有日志</li>
<li>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分</li>
<li>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</li>
</ul>
<h3 id="Git-查看提交历史-1"><a href="#Git-查看提交历史-1" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h3><p>在使用了Git提交若干更新后，或克隆了某个项目，想回顾下提交历史，我们可以用git log命令查看</p>
<pre><code>git log</code></pre><p>可以回顾历史版本</p>
<pre><code>git log --oneline</code></pre><p>可以来查看历史记录的简介的版本。</p>
<pre><code>git log --reverse</code></pre><p>可以用 –reverse参数来逆向显示所有日志。</p>
<pre><code>git log --author</code></pre><p>可以查找指定用户的提交日志例如</p>
<pre><code>git log --author=zwz --oneline</code></pre><p>可以查找zwz提交的简单版本的日志。</p>
<p>如果要指定日期，还可以执行几个选项<code>--since</code>和<code>--before</code>,也可以用<code>--until</code>和<code>--after</code>。</p>
<pre><code>git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges</code></pre><p>可以看三周前且在四月十八日之后的所有提交。</p>
<p>###Git 标签<br>如果达到了一个重要的阶段，并希望永远记住那个特别的快照，你可以使用git tag给它打上标签。比如说，我们想为项目发布一个版本”1.0”版本。于是可以使用git tag -a v1.0命令给最新一个提交打上(HEAD)”v1.0”的标签</p>
<p>-a选项一样为创建一个带注解的标签.不用-a选项也可以执行的，但他不会记录这标签什么时候打的，谁打的，也不会让你添加个标签的注解</p>
<pre><code>git tag -a v1.0</code></pre><p>当执行git tag -a命令时，Git会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样，当我们执行<code>git log --decorate</code>时就可以看到我们的标签了。</p>
<p>如果忘记给某个提交打标签了，又将他发布了，我们可以给它追加标签。</p>
<pre><code>git tag -a v0.9 hash_id</code></pre><p>指定标签信息命令：</p>
<pre><code>git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></pre><p>PGP签名标签命令：</p>
<pre><code>git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></pre><h3 id="Git-amp-Github"><a href="#Git-amp-Github" class="headerlink" title="Git&amp;Github"></a>Git&amp;Github</h3><h4 id="为创建远程库地址别名"><a href="#为创建远程库地址别名" class="headerlink" title="为创建远程库地址别名"></a>为创建远程库地址别名</h4><pre><code>git remote -v</code></pre><p>可以查看当前所有远程地址的别名</p>
<pre><code>git remote add [别名] [远程地址(就是GitHub的地址)]</code></pre><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><pre><code>git push [别名] [分支名]</code></pre><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><pre><code>git clone [远程地址]</code></pre><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><ul>
<li>pull =fetch+merge </li>
<li>git fetch [远程库地址别名] [远程分支名]</li>
<li>git merge [远程库地址别名/远程分支名]</li>
<li>git pull [远程库地址别名] [远程分支名]</li>
</ul>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>要点</p>
<ol>
<li>如果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取</li>
<li>拉取下来后如果进入冲突状态,则按照分支冲突解决操作即可</li>
</ol>
<h4 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h4><p>在GitHub里面别人的项目右上角点击fork</p>
<h4 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h4><ol>
<li>机内当前用户的目录<code>$ cd~</code></li>
<li>删除.ssh目录 <code>$ rm -rvf .ssh</code></li>
<li>运行命令生成.ssh密钥目录 <code>$ ssh-keygen -t rsa -C 595488485@qq.com</code></li>
<li>进入.ssh目录查看文件列表<code>$ cd .ssh</code> <code>$ls -lF</code></li>
<li>查看id_rsa.pub文件内容<code>$ cat id_rsa.pub</code></li>
<li>复制id_rsa.pub文件内容，登录GitHub，点击头像用户→Setting→SSH and GPG keys</li>
<li>New SSH Key</li>
<li>输入复制的密钥信息</li>
<li>回到Git bush 创建远程地址别名<code>git remote add origin_ssh [地址在SSH里面clone]</code></li>
<li>推送文件测试.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/File&%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/File&%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">File&递归</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-16 18:52:36" itemprop="dateModified" datetime="2020-07-16T18:52:36+08:00">2020-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="File类、递归"><a href="#File类、递归" class="headerlink" title="File类、递归"></a>File类、递归</h1><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>java.io.File</code>类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public File(String pathname)</code>：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的File实例。</li>
<li><code>public File(String parent, String child)</code>：从<strong>父路径名字符串和子路径名字符串</strong>创建新的File实例。</li>
</ul>
<p>举例子：</p>
<pre><code>/*
    路径：
        绝对路径：完整的路径
            以盘符(C:  D: ...)开始的路径
                c:\\1.txt
        相对路径：是一个简化的路径
            相对指的是相对于当前项目的根目录
            如果使用当前项目的根目录，路径可以简化书写

        注意：
            1.路径是不区分大小写
            2.路径中的文件名称分隔符windows用反斜杠，反斜杠是转义字符。两个反斜杠代表一个反斜杠
*/
public class Demo02FilePath {
    public static void main(String[] args) {
        /*
            File类的构造方法
        */
        show01();
        show02(&quot;c:\\&quot;,&quot;a.txt&quot;);//c:\a.txt
        show02(&quot;d:\\&quot;,&quot;a.txt&quot;);//d:\a.txt
        show03();
    }
    /*
        File(File parent, String child)根据parent抽象路径名和chile路径名字符串创建一个新File实例
        参数：把路径分为两部部分
            File parent:父路径
            String child：子路径
        好处：
            父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径可以变化
            父路径是File类型，可以使用File的方法对路径进行一些操作，再使用路径创建对象
    */
    private static void show03() {
        File parent = new File(&quot;c:\\&quot;);
        File file1 = new File(parent,&quot;hhh&quot;);
        System.out.println(file1);
    }

    /*
        File(String parent,String child) 根据parent 路径名字字符串和 child 路径名字符串创建一个新 File 实例
        参数：把路径分成了两部分
        String parent：父路径
        String child：子路径
        好处：
            父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径可以变化
    */
    private static void show02(String parent,String child) {
        File file = new File(parent,child);
        System.out.println(file);//c:\a.txt
    }

    /*
        File(String pathname)通过将给定路径名字符串转换为抽象路径名来创建一个新File实例
        参数：
            String pathname：字符串的路径名称
            路径名称可以是以文件皆为，也可以是以文件夹结尾
            路径可以是相对路径，也可以是绝对路径
            路径可以存在，也可以是不存在
            创建File对象，只是把字符串路径封装成File对象，不考虑路径的真假情况
    */
    private static void show01() {
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        System.out.println(f1);//重写了Object类的toString方法

        File f2 = new File(&quot;b.txt&quot;);
        System.out.println(f2);
    }
}</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul>
<li><code>public String getAbsolutePath()</code>; 返回此File的绝对路径名字符串</li>
<li><code>public String getPath()</code>; 将此File转换为路径名字符串</li>
<li><code>public String getName()</code>; 返回由此File表示的文件或目录的名称。</li>
<li><code>public long length()</code> ;返回由此File表示的文件的长度</li>
</ul>
<p>演示</p>
<pre><code>public class Demo03FileMethods {
    public static void main(String[] args) {
        show01();
        show02();
        show03();
        show04();
    }
    /*
        public long length() ;返回由此File表示的文件的长度
        获取的是构造方法指定的文件的大小，以字节为单位
        注意：
            文件夹是没有大小概念的，不能获取文件夹的大小
            如果构造方法中给出的路径不存在，那么length方法返回0;
    */
    private static void show04() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\1.jpg&quot;);
        long length = f1.length();
        System.out.println(length);
    }

    /*
        public String getName(); 返回由此File表示的文件或目录的名称。
        获取的就是构造方法传递路径结尾的部分(文件/文件夹)
    */
    private static void show03() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        File f2 = new File(&quot;C:\\java练习\\File&quot;);
        System.out.println(f1.getName());
        System.out.println(f2.getName());
    }

    /*
         public String getPath(); 将此File转换为路径名字符串
         获取构造方法中的路径
    */
    private static void show02() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        File f2 = new File(&quot;a.txt&quot;);
        System.out.println(f1.getPath());
        System.out.println(f2.getPath());

        System.out.println(f1); //默认调用toString方法，toString方法调用getPath()方法
    }

    /*
        public String getAbsolutePath(); 返回此File的绝对路径名字符串.
        获取构造方法中传递的路径
        无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径
    */
    private static void show01() {
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        String absolutePath1 = f1.getAbsolutePath();
        System.out.println(absolutePath1);

        File f2 = new File(&quot;a.txt&quot;);
        System.out.println(f2.getAbsolutePath());
    }
}</code></pre><p>输出结果</p>
<pre><code>C:\java练习\File\a.txt
C:\java练习\File\a.txt
-----------------------
C:\java练习\File\a.txt
a.txt
C:\java练习\File\a.txt
-----------------------
a.txt
File
-----------------------
3149546</code></pre><blockquote>
<p>API中说明:length(),表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便携的路径，开发常用。</li>
</ul>
<hr>
<pre><code>public class FilePath{
    public static void main(String[] args){
        //D盘下的bbb.java文件
        File f = new File(&quot;D:\\bbb.java&quot;);
        System.out.println(f.getAbsolutePath());

        //项目下的bbb.java文件
        File f2 = new File(&quot;bbb.java&quot;);
        System.out.println(f.getAbsolutePath());
    }
}

输出结果：
D:\bbb.java
D:\C:\java练习\File\bbb.java</code></pre><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li>public boolean exists():此File类表示的文件或目录是否实际存在。</li>
<li>public boolean isDirectory():此File表示的是否为目录。</li>
<li>public boolean isFile():此File表示的是否为文件。</li>
</ul>
<p>方法演示。</p>
<pre><code>public class Demo04FileExists {
    public static void main(String[] args) {
        show01();
        show02();
    }
    /*
        public boolean isDirectory() : 此File表示的是否为目录
            用于判断构造方法中给定的路径是否以文件夹结尾
                是：true
                否：false
        public boolean isFile():此File表示的是否为文件。
            用于判断构造方法中给定的路径是否以文件结尾
                是：true
                否：false
        注意：
            电脑的硬盘中只有文件或者文件夹，两个方法是互斥的
            这两个方法使用前提，路径必须存在，否则都返回false
    */
    private static void show02() {
        System.out.println(&quot;-------------show02----------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\src\\Demo01\\File&quot;);
        System.out.println(f1.isDirectory());
        System.out.println(f1.isFile());
    }

    /*
        public boolean exists():此File类表示的文件或目录是否实际存在。
        用于判断构造方法中的路径是否存在
            存在:true
            不存在：false
    */
    private static void show01() {
        System.out.println(&quot;-------------show01----------------&quot;);
        File f1 = new File(&quot;C:\\&quot;);
        System.out.println(f1.exists());

        File f2 = new File(&quot;f:\\&quot;);
        System.out.println(f2.exists());

        File f3 = new File(&quot;a.txt&quot;);
        System.out.println(f3.exists());
    }
}</code></pre><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li>public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时候，创建一个新的空文件。</li>
<li>public boolean delete():删除由此File表示的文件或目录。</li>
<li>public boolean mkdir():创建由此File表示的目录。</li>
<li>public boolean mkdirs():创建由此File表示的目录，包括任何必须但不存在的父目录。</li>
</ul>
<p>方法演示</p>
<pre><code>public class Demo05FileCreateAndDelete {
    public static void main(String[] args) throws IOException{
        show01();
        show02();
        show03();
    }
    /*
         public boolean delete():删除由此File表示的文件或目录。
         此方法，可以删除构造方法路径中给出的文件/文件夹
         返回值：布尔值
            true：文件/文件夹删除成功 返回true
            false：文件夹中有内容，不会删除 返回false；构造方法中路径不存在false
         注意：
            delete方法是直接在硬盘删除文件和文件夹，不走回收站，删除须谨慎

    */
    private static void show03() {
        System.out.println(&quot;-------------show03-------------&quot;);
        File f2 = new File(&quot;C:\\java练习\\File\\11\\22\\33\\4.txt&quot;);
        boolean b1 = f2.delete();
        System.out.println(b1);
    }

    /*
        public boolean mkdir():创建单级文件夹
        public boolean mkdirs():既可以创建单级也可以创建多级
        返回值:布尔值
            true：文件夹不存在，创建文件夹，返回true
            false：文件夹不存在，不会创建，返回false；构造方法中给出的路径不存在返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常
    */
    private static void show02() {
        System.out.println(&quot;-------------show02-------------&quot;);
        File f1 = new File(&quot;aaa.txt&quot;);
        boolean b1 = f1.mkdir();
        System.out.println(b1);

        File f2 = new File(&quot;11\\22\\33\\4.txt&quot;);
        boolean b2 = f2.mkdirs();
        System.out.println(b2);
    }

    /*
        public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时候，创建一个新的空文件。
        创建文件的路径和名称在构造方法中给出(构造方法的参数)
        返回值:布尔值
            true：文件不存在，创建文件，返回true
            false：文件存在，不会创建，返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常

        public boolean createNewFile() throws IOException
        该方法会抛出异常
    */
    private static void show01() throws IOException {
        System.out.println(&quot;-------------show01-------------&quot;);
        File f1 = new File(&quot;1.txt&quot;);
        boolean b1 = f1.createNewFile();
        System.out.println(b1);
    }
}</code></pre><blockquote>
<p>API中说明:delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><ul>
<li>public String[] List():返回一个String数组，表示该File目录中的所有子文件或目录</li>
<li>public File[] listFiles():返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
<p>方法</p>
<pre><code>/*
注意：
    List方法和listFiles方法遍历的是构造方法中给出的目录
    如果构造方法中给出的目录的路径不存在，会抛出空指针异常
    如果构造方法中给出的路径不是一个目录，也会抛出空指针异常
*/
public class Demo06FileList {
    public static void main(String[] args) {
        Show01();
        Show02();
    }
    /*
        - public File[] listFiles():返回一个File数组，表示该File目录中的所有的子文件或目录。
        遍历构造方法中给出的目录，会获得目录中所有文件/文件夹的名称,把文件/文件夹封装成File对象，多个File对象存储到File数组中
    */
    private static void Show02() {
        File file = new File(&quot;C:\\java练习\\File&quot;);
        File[] files = file.listFiles();
        for (File f : files){
            System.out.println(f);
        }
    }

    /*
        - public String[] List():返回一个String数组，表示该File目录中的所有子文件或目录
        遍历构造方法中给出的目录，会获得目录中所有文件/文件夹的名称，把多个名称存储到一个字符串String类型的数组

    */
    private static void Show01() {
        File file = new File(&quot;C:\\java练习\\File&quot;);
        String[] list = file.list();
        for (String s : list){
            System.out.println(s);
        }

    }
}</code></pre><blockquote>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历哦。</p>
</blockquote>
<p>#递归</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>递归：方法自己调用自己</p>
<ul>
<li><p>递归分类：</p>
<pre><code>- 直接递归成为方法自己调用自己
- 间接递归可以A方法屌用B方法，B方法调用C方法，C方法调用A方法</code></pre></li>
<li><p>注意事项：</p>
<pre><code>- 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</code></pre><ul>
<li>递归虽然有限制条件，但是递归次数不能太多，不然也会发撒哼栈内存溢出</li>
<li>构造方法禁止递归！</li>
</ul>
</li>
<li><p>递归的使用前提：当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归</p>
<pre><code>public class Recursive {
    public static void main(String[] args) {
    a(1);
}

private static void a(int i) {
    System.out.println(i);
    if (i==20000){
        return;
    }
    a(++i);
}</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>运行该代码会使栈空间爆满，以至于抛出栈溢出异常</p>
</blockquote>
<h2 id="递归累加求和"><a href="#递归累加求和" class="headerlink" title="递归累加求和"></a>递归累加求和</h2><pre><code>/*
    练习：
        使用递归计算1-n之间的和
*/
public class Demo02Recursive {
    public static void main(String[] args) {
        int s =sum(3);
        System.out.println(s);
    }
    /*
        定义一个方法，使用递归计算1-n之间的和
        1+2+3+...+n
        n + (n-1) + (n-2)+...+1
        已知：
            最大值：n
            最小值：1
        使用递归必须明确：
            1，递归的结束条件
                获取到1的时候结束
            2.递归的目的
                获取下一个被加的数字(n-1)
    */
    private static int sum(int n) {

        if (n==1){
            return 1;
        }
        //获取下一个被加的数字(n-1)
        return n+sum(n-1);
    }
}</code></pre><p><img src="https://i.loli.net/2020/07/15/SoduBbYEKMtrwqA.png" alt="1594785660_1_.jpg"></p>
<blockquote>
<p>该图是计算1加到3的算法 </p>
<p>一开始调用方法入栈，然后递归继续入栈，接着当条件符合的时候弹栈输出结果，即，sum(3-1)是2 sum(2-1)是1</p>
</blockquote>
<h2 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h2><pre><code>/*
    练习：
        使用递归计算阶乘
        n的阶乘：n! = n*(n-1)*(n-2)*...*3*2*1
        5的阶乘：5! = 5*(5-1)*(5-2)*...*(5-4)
*/
public class Demo03Recursive {
    public static void main(String[] args) {
        int a = fact(-10);
        System.out.println(a);
    }
    /*
        定义方法使用递归计算阶乘
        5的阶乘：5! = 5*(5-1)*(5-2)*...*(5-4)
    */
    private static int fact(int n) {
        if (n == 1){
            return 1;
        }
        else if (n &lt; 0){
            System.out.println(&quot;fail&quot;);
            return -1;
        }
        else
            return n*fact(n-1);
    }
}</code></pre><h2 id="打印多级目录"><a href="#打印多级目录" class="headerlink" title="打印多级目录"></a>打印多级目录</h2><pre><code>/*
    练习：
        递归打印多级目录
    需求：
        遍历c:\\java练习文件夹，及其子文件夹
*/
public class Demo04Recursive {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历

    */
    public static void getAllFile(File dir){
        System.out.println(dir);
        File[] files = dir.listFiles();
        for (File f : files){
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()){
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            }else
                //f是一个文件，直接打印
                System.out.println(f);
        }
    }
}    </code></pre><p><img src="https://i.loli.net/2020/07/15/Y2GSzAmCjlcD71w.png" alt="1594791605_1_.jpg"></p>
<blockquote>
<p>图与代码不太相符，原理一样</p>
</blockquote>
<p>#综合案例</p>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><pre><code>/*
    练习：
        递归打印多级目录
    需求：
        遍历c:\\java练习文件夹，及其子文件夹
        只要.java结尾的文件
*/
public class Demo05Recursive {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历

    */
    public static void getAllFile(File dir){
        //System.out.println(dir);
        File[] files = dir.listFiles();
        for (File f : files){
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()){
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            }else{
                /*
                //f是一个文件，直接打印
                *//*
                    只要.java结尾的文件
                    1.把File对象f转换为字符串对象
                *//*
                //String name = f.getName();//转换为字符串
                //String path = f.getPath();
                String string = f.toString();

                //把字符串，转换为小写
                s = string.toLowerCase();

                //  2.调用String类中的方法endWith判断字符串是否是以.java结尾
                boolean b = string.endsWith(&quot;.java&quot;);

                //  3.如果是以.java结尾的文件，则输出就行
                if (b == true){
                System.out.println(f);
                */
                if (f.getName().toLowerCase().endsWith(&quot;.java&quot;)){
                    System.out.println(f);
                }
            }
        }
    }
}</code></pre><blockquote>
<p><code>/**/</code>在这里面的代码是最原始，正常人的思想，后面简版是改进后的</p>
</blockquote>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code>作为参数，接口中只有一个方法。</p>
<p><code>boolean accept(File pathname)</code>：测试pathname是否应该包含当前File目录中，符合返回true，过滤掉则返回false，保留规则：</p>
<ol>
<li>要么是.java文件。</li>
<li>要么是目录用于继续遍历。</li>
</ol>
<p>通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印</p>
<p><img src="https://i.loli.net/2020/07/16/MPAh5sxQuVvwFU8.png" alt="1594872854_1_.jpg"></p>
<p>实现代码</p>
<pre><code>public class Demo02Filter {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    public static void getAllFile(File dir) {
        //传递过滤器对象 使用匿名内部类 FileFilter方法
        /*File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File pathname) {
                //过滤规则，pathname是文件夹，或是.java结尾的文件返回true
                return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(&quot;.java&quot;);
            }
        });*/

        /*File [] files = dir.listFiles(new FilenameFilter() {
            //传递过滤器对象 使用匿名内部类 FileFilter方法 FilenameFilter方法
            @Override
            public boolean accept(File dir, String name) {
                return new File(dir,name).isDirectory() || name.toLowerCase().endsWith(&quot;.java&quot;);
            }
        });*/

        //传递过滤器对象 使用匿名内部类 FileFilter方法 Lambda表达式
        File [] files = dir.listFiles((dir1, name) -&gt; new File(dir1,name).isDirectory() || name.toLowerCase().endsWith(&quot;.java&quot;));

        for (File f : files) {
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()) {
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            } else {
                if (f.getName().toLowerCase().endsWith(&quot;.java&quot;)) {
                    System.out.println(f);
                }
            }
        }
    }
}</code></pre><blockquote>
<p>ps：IDEA里面写了匿名内部类的方法可以变成Lambda表达式不用自己写hhh</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/C%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/C%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E6%B3%95/" class="post-title-link" itemprop="url">C语言冒泡法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-05 20:59:56" itemprop="dateModified" datetime="2020-04-05T20:59:56+08:00">2020-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言的冒泡法"><a href="#C语言的冒泡法" class="headerlink" title="C语言的冒泡法"></a>C语言的冒泡法</h1><pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;
void main(){
    void sort(int arr[],int len);
    //冒泡法排序！
    int arr[4];
    printf(&quot;请输入4个数字分别赋给数组arr\n&quot;);
    scanf(&quot;%d%d%d%d&quot;,&amp;arr[0],&amp;arr[1],&amp;arr[2],&amp;arr[3]);
    int len = (int) sizeof(arr)/sizeof(*arr); //这里定义了数组的长度，sizeof(arr)获取了数组一共有多少个字节，sizeof(*arr)获取的第一个字节大小 sizeof(arr)/sizeof(*arr) 可获取长度
    sort(arr,len);                              //调用函数
    int k;
    for(k=0;k&lt;len;k++)
        printf(&quot;%d&quot;,arr[k]);                  //遍历数组

    system(&quot;pause&quot;);
}
void sort(int arr[],int len)                 //每次比较数组两个元素，并用临时变量temp来交换两个元素的顺序
{    
    int i,j,temp;                            
    for(i=0;i&lt;len-1;i++)
        for(j=0;j&lt;len-1-i;j++)
            if(arr[j]&gt;arr[j+1])
            {    
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }

}</code></pre><blockquote>
<p>这里的len使用了sizeof与指针来实现的  <code>sizeof(arr)</code>表示数组一共的字节数，<code>sizeof(*arr)</code>表示的是列表第一个元素的字节<code>sizeof(*arr)</code>=<code>sizeof(arr[0])</code>当然用arr[1]…也是可以的</p>
</blockquote>
<blockquote>
<p>还有宏定义于头文件之前<code>#define _CRT_SECURE_NO_WARNINGS</code>是因为1.我们在编译老的用C语言的开源项目如lua源包的时候，可能因为一些老的.c文件使用了strcpy,scanf等不安全的函数，而报警告和错误，而导致无法编译通过。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/cosx%E7%9A%84%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/cosx%E7%9A%84%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/" class="post-title-link" itemprop="url">cosx的泰勒展开</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-22 20:26:18" itemprop="dateModified" datetime="2020-04-22T20:26:18+08:00">2020-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cosx泰勒展开"><a href="#cosx泰勒展开" class="headerlink" title="cosx泰勒展开"></a>cosx泰勒展开</h2><blockquote>
<p>写了我三天（草本植物）</p>
</blockquote>
<pre><code>//泰勒展开
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//#include &lt;string.h&gt;
//#include &lt;math.h&gt;
int factzwz(int n);
int powerzwz(int x,int n);
void main()
{    
    int n1,x,i,flag,n,n2;
    double itself,sum=0;
    n = 0;
    i = 0;
    flag = 1;
    printf(&quot;请问你要输出多少项：\n&quot;);
    scanf(&quot;%d&quot;,&amp;n1);
    n2 = 2*(n1-1);
    printf(&quot;请输入cos(x)中的x(0-1.57之间)：\n&quot;);
    scanf(&quot;%d&quot;,&amp;x);
    do
    {
        itself=1.0*flag*powerzwz(x,i)/factzwz(n);
        sum=sum+itself;
        flag=-flag;
        i=i+2;
        n=n+2;
    }while(n&lt;=n2);
    printf(&quot;%.4lf&quot;,sum);
    system(&quot;pause&quot;); 
}
int factzwz(int n)
{
    if(n&lt;=0)
        return 1;
    return n*factzwz(n-1);
}
int powerzwz(int x,int n)
{
    if(n==0)
        return 1;
    else if(n&lt;0)
        return x*powerzwz(x,n+1);
    else
        return x*powerzwz(x,n-1);
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
