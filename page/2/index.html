<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZWZ的博客嘻嘻">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0&Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0&Lambda/" class="post-title-link" itemprop="url">线程池&Lambda</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-12 15:01:46" itemprop="dateModified" datetime="2020-07-12T15:01:46+08:00">2020-07-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程池与Lambda语法"><a href="#线程池与Lambda语法" class="headerlink" title="线程池与Lambda语法"></a>线程池与Lambda语法</h1><h2 id="1-1线程间通信"><a href="#1-1线程间通信" class="headerlink" title="1.1线程间通信"></a>1.1线程间通信</h2><p>概念：多个线程在处理同一个资源，但是处理的动作(线程的任务)却不相同.</p>
<p>比如线程A用于生产包子，线程B用来吃包子，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在了线程通信的问题。</p>
<p><strong>为什么要处理线程间通信</strong></p>
<p>多个线程并发执行时，在默认CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望其执行的有规律，那么多线程之间就要有一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源</strong></p>
<p>多个线程在处理同一资源，且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作，就是多个线程在操作同一份数据时，避免对同一共享变量的争夺，也就是我们需要通过一定的手段使各个线程能有效的利用资源，而这种手段即 – <strong>等待唤醒机制</strong></p>
<h2 id="1-2等待唤醒机制"><a href="#1-2等待唤醒机制" class="headerlink" title="1.2等待唤醒机制"></a>1.2等待唤醒机制</h2><h3 id="什么是等待唤醒机制"><a href="#什么是等待唤醒机制" class="headerlink" title="什么是等待唤醒机制"></a>什么是等待唤醒机制</h3><p>这个是多个线程之间一种协作的机制，谈到线程我们经常想到的是线程间的竞争(race),比如去争夺锁，但并不是故事的全部,线程间也会有协作机制。就好比公司里你和你的同事们。你们可能存在升职的竞争，但是更多是工作上的合作</p>
<p>在一个线程进行了一些规定后，就进入了<code>wait()</code>，等待其他线程执行完他们的指定代码过后，再将其唤醒<code>notify()</code>；在多个线程进行等待时，可以使用1notifyAll()`来唤醒所有的等待线程。</p>
<p><strong>wait\notify</strong>就是一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不在参与调度。进入wait set中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即WAITING.它还要等着别的线程执行一个特别的动作，也就是<strong>通知(notify)</strong>在这个对象上等待的线程从wait set中释放。重新进入了调度队列(ready queue)中。</li>
<li>notify:则选取所同志对象的wait set 中的一个线程释放，如：餐厅有空位置后，等待就餐醉酒的顾客会先入座。</li>
<li>notifyAll：释放所同志对象在wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立刻恢复执行状态，因为它当初在同步代码块里面，而它不具有锁，所以它需要再次获得锁才可以执行，成功后才能调用wait方法之后的地方回复执行。</p>
</blockquote>
<blockquote>
<p>总结：</p>
</blockquote>
<blockquote>
<ul>
<li>如果获得锁，则从WAITING状态变成RUNNABLE状态</li>
<li>如果没获得锁，则从WAITING状态变成BLOCKED状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong>  </p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用，因为：对应的锁对象可以notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="1-3生产者与消费者问题"><a href="#1-3生产者与消费者问题" class="headerlink" title="1.3生产者与消费者问题"></a>1.3生产者与消费者问题</h2><p>等待唤醒机制其实是经典的”生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<pre><code>包子铺线程生产包子，吃货线程消费包子。当包子没有时(状态为false)，吃货线程等待，包子铺线程生产包子(即包子状态为true)，
并通知吃货线程(解除吃货的等待状态)，因为已经包子，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁
的获取情况，如果吃货获取到锁，那么就执行吃包子动作，包子吃完(包子状态为false)，并通知包子铺进程(接触包子铺的等待状态)，
吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获得情况</code></pre><p><strong>代码如下</strong></p>
<p>包子资源类：</p>
<pre><code>/*
        资源类：包子类
        设置包子的属性
            皮
            馅
            包子的状态：有 true，没有 false
*/
    public class Baozi {
        //皮
        String pi;
        //馅
        String xian;
        //包子的状态：有 true，没有 false，设置初始值为false没有包子
        boolean flag = false;
    }

包子铺线程类：

/*
    生产者(包子铺类)：是一个线程类，可以继承Thread
    设置线程任务(run)：生产包子
    对包子的状态进行判断
    true：有包子
        包子铺调用wait方法进入等待状态
    false：没有包子
        包子铺生产包子
        增加一些趣味性：交替生产两种包子
            两种状态(i%2==0)
        包子铺生产好了包子
        修改包子的状态为true
        唤醒吃货线程，让吃货线程吃包子

    注意事项：
        包子铺线程喝包子线程关系--&gt;通信(互斥)
        必须同步技术保证两个线程只能有一个在执行
        锁对象必须保证唯一。可以使用包子对象为锁对象
        包子铺类和吃货类需要把包子对象作为参数传递进来
            1.需要在成员对象位置创建一个包子变量
            2.使用带参数构造方法，为这个包子变量赋值
*/
public class BaoZiPu extends Thread{
    //定义包子变量
    private Baozi bz;

    //2.使用带参数构造方法，为这个包子变量赋值
    public BaoZiPu(Baozi bz){
        this.bz = bz;
    }

    @Override
    public void run() {
        int count = 0;
        //让包子铺一直生产包子
        while (true){
        //必须同时同步技术保证两个线程只有一个执行
        synchronized (bz) {
            //对包子的状态进行判断
            if (bz.flag == true) {
                //包子铺调用wait方法进入等待状态
                try {
                    bz.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            //被唤醒之后执行，包子铺生产包子
            //增加一些趣味性：交替生产两种包子
            if (count % 2 == 0) {
                //生产薄皮三鲜馅包子
                bz.pi = &quot;薄皮&quot;;
                bz.xian = &quot;三鲜馅&quot;;
            } else {
                //生产冰皮牛肉大葱馅包子
                bz.pi = &quot;冰皮&quot;;
                bz.xian = &quot;牛肉大葱馅&quot;;
            }
            count++;
            System.out.println(&quot;包子铺正在生产：&quot; + bz.pi + bz.xian + &quot;的包子&quot;);
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //包子铺生产好了包子
            //修改包子的状态为true
            bz.flag = true;
            //唤醒吃货线程；让吃货线程吃包子
            bz.notify();
            System.out.println(&quot;包子铺正在生产：&quot; + bz.pi + bz.xian + &quot;的包子,吃货可以开吃了&quot;);
            }
        }
    }
}</code></pre><p>吃货类：</p>
<pre><code>/*
    消费者(吃货)类：是一个线程类，可以继承Thread
    设置线程任务(run):吃包子
    对包子状态进行判断
    false：没有包子
        吃货调用wait方法进入等待状态
    true：有包子
        吃货吃包子
        吃货吃完包子
        修改包子状态为false
        吃货唤醒包子铺线程，生产包子
*/
public class ChiHuo extends Thread{
    //1.需要在成员位置创建一个包子变量
    private Baozi bz;

    //2.使用带参数和构造方法，为这个包子变量赋值
    public ChiHuo(Baozi bz){
        this.bz = bz;
    }
    //设置线程任务(吃包子)
    @Override
    public void run() {
        while (true){
            //必须同时同步技术保证两个线程只有一个执行
            synchronized (bz){
                //对包子状态进行判断
                if (bz.flag==false){
                    //吃货调用wait等待状态
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //唤醒之后执行的代码，吃包子
                System.out.println(&quot;吃货正在吃&quot;+bz.pi+bz.xian+&quot;的包子&quot;);
                //吃货吃完包子
                //秀嘎包子的状态为false
                bz.flag = false;
                bz.notify();
                System.out.println(&quot;吃货已经吃完&quot;+bz.pi+bz.xian+&quot;的包子,包子铺赶紧做包子&quot;);
                System.out.println(&quot;----------------------------------------------&quot;);

            }
        }
    }
}</code></pre><p>测试类：</p>
<pre><code>public class TestBaoZi {
    public static void main(String[] args) {
        //创建包子对象
        Baozi bz = new Baozi();
        //创建包子铺线程，开启，生产包子；
        new BaoZiPu(bz).start();
        new ChiHuo(bz).start();
    }
}</code></pre><p>执行结果：</p>
<pre><code>包子铺正在生产：薄皮三鲜馅的包子
包子铺正在生产：薄皮三鲜馅的包子,吃货可以开吃了
吃货正在吃薄皮三鲜馅的包子
吃货已经吃完薄皮三鲜馅的包子,包子铺赶紧做包子
----------------------------------------------
包子铺正在生产：冰皮牛肉大葱馅的包子
包子铺正在生产：冰皮牛肉大葱馅的包子,吃货可以开吃了
吃货正在吃冰皮牛肉大葱馅的包子
吃货已经吃完冰皮牛肉大葱馅的包子,包子铺赶紧做包子
----------------------------------------------</code></pre><h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1线程池思想概述"><a href="#2-1线程池思想概述" class="headerlink" title="2.1线程池思想概述"></a>2.1线程池思想概述</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，频繁创建线程会导致系统资源被浪费，因为创建喝销毁线程都需要时间。</p>
<p>因此线程池就解决了这麻烦。</p>
<h2 id="2-2线程池的概念"><a href="#2-2线程池的概念" class="headerlink" title="2.2线程池的概念"></a>2.2线程池的概念</h2><ul>
<li>线程池：其实就说一个容纳多个线程的容器，其中线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池很多操作都是与优化资源相关，所以说多无益。</p>
<p><img src="https://i.loli.net/2020/07/10/UzQNyHI3hEdapFb.png" alt="1594382301.jpg"></p>
<h2 id="2-3线程池的使用"><a href="#2-3线程池的使用" class="headerlink" title="2.3线程池的使用"></a>2.3线程池的使用</h2><p>java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上来讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生产一些常用的线程池，官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池，也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象的方法如下：</p>
<ul>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li>
</ul>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不关闭)；</li>
</ol>
<p>Runnable实现类代码：</p>
<pre><code>//2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
    public class Runnbale implements Runnable{
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+&quot;创建了个新线程&quot;);
        }
    }</code></pre><p>线程池测试类：</p>
<pre><code>/*
    线程池：JDK1.5之后提供的
    java.util.concurrent.Executors:线程池的工厂类，用来生产线程池
    Executors类中的静态方法：
        static ExecutorService newFixedThreadPool(int nThreads)
        创建一个可重用固定线程数的线程池

        参数：
            int nThreads：创建线程池中包含的线程数量
        返回值：
            ExecutorService接口：返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口编程)

        java.util.concurrent.ExecutorService:线程池接口
            用来从线程池中获取线程，调用start方法，执行线程任务
                submit(Runnable task) 提交一个Runnable任务用于执行
            关闭/销毁线程池的方法
                void shutdown()

         线程池的使用步骤：
            1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
            2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
            3.调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。
            4.调用ExecutorService中的方法shutdown销毁线程池(不建议使用)

*/
public class TestThreadPool {
    public static void main(String[] args) {
        //1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        //3.调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。
        es.submit(new Runnbale());
        es.submit(new Runnbale());
        es.submit(new Runnbale());
        //4.调用ExecutorService中的方法shutdown销毁线程池(不建议使用)
        es.shutdown();
    }
}</code></pre><h2 id="Lambda表达式-λ"><a href="#Lambda表达式-λ" class="headerlink" title="Lambda表达式(λ)"></a>Lambda表达式(λ)</h2><h3 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h3><p>在数学里，<strong>函数</strong>就是由输入量和输出量的一套计算方案。相对而言，面向对象过分强调”必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong></p>
<p>面向对象思想：</p>
<p>做一件事情找一个能解决这个事情的对象，调用对象的方法，完成事情。</p>
<p>函数式编程思想：只要能获取到结果，谁去做，怎么做的都不重要，重视结果而不是过程。</p>
<h2 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h2><p>###传统写法<br>当你需要启动一个线程去完成任务时，通常通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。</p>
<pre><code>public class Demo01Runnable{
    public static void main(String[] args){
        //匿名内部类
        Runnable task = new Runnable(){
            @Override
            public void run(){
                //覆盖重写抽象方法
                System.out.println(&quot;多线程任务执行!&quot;)
            }
        };
        new Thread(task).start();//启动线程
    }
}</code></pre><p>本着”一切皆为对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类，可以分析出几点内容：</p>
<ul>
<li>Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心；</li>
<li>为了指定run的方法体，不得不需要Runnable接口的实现类；</li>
<li>为了省去一个RunnableImpl实现类的麻烦，不得不使用匿名内部类；</li>
<li>必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不重写一遍，且不能写错。</li>
<li>实际上，似乎只有方法体才是关键所在。</li>
</ul>
<h2 id="3-3编程思想转换"><a href="#3-3编程思想转换" class="headerlink" title="3.3编程思想转换"></a>3.3编程思想转换</h2><p><strong>做什么，而不是怎么去做</strong></p>
<p>我们真希望创建一个匿名内部类嘛？不是，我们为了创建这件事不得不创建了一个对象罢了。我们只是想把：<strong>将run方法体内的代码传递给Thread类</strong></p>
<h2 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类可以鞋厂简单的Lambda表达式达到等效：</p>
<pre><code>public class Demo02LambdaRunnable{
    public static void main(String[] args){
        new Thread(()-&gt;System.out.println(&quot;多线程任务执行！&quot;)).start();//启动线程
    }
}</code></pre><p>这段代码和刚才的执行效果是完全相同的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有”不得不创建接口对象”的束缚，不再有”抽象方法覆盖重写”的负担。</p>
<h2 id="3-5回顾匿名内部类"><a href="#3-5回顾匿名内部类" class="headerlink" title="3.5回顾匿名内部类"></a>3.5回顾匿名内部类</h2><p>Lambda是怎么样击败面向对象的？</p>
<pre><code>()-&gt;System.out.println(&quot;多线程任务执行！&quot;)\</code></pre><p>为了了解Lambda的语义，我们需要从传统的代码起步。</p>
<p><strong>使用实现类</strong></p>
<p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start()</code>方法，而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<pre><code>/*
    创建Runnable接口的实现类，重写run方法，设置线程任务
*/
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
    }
}</code></pre><p>创建该实现类的对象作为Thread类的构造参数：</p>
<pre><code>/*
    实现Runnable接口的方式实现多线程程序
*/
public class Demo01Runnable {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl r = new RunnableImpl();
        //创建Thread类对象，构造方法中传递Runnable接口的实现类
        Thread t = new Thread(r);
        t.start();
//---------------------------------------------------------------
        //简化代码，使用匿名内部类，实现多线程程序
        Runnable run = new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
            }
        };
        new Thread(run).start();
//---------------------------------------------------------------
        //继续简化代码
        new Thread(new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
            }
        }).start();
    }
}</code></pre><h3 id="匿名内部类的好处和弊端"><a href="#匿名内部类的好处和弊端" class="headerlink" title="匿名内部类的好处和弊端"></a>匿名内部类的好处和弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>，另一方面，匿名内部类的语法——<strong>实在太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，Runnable接口有一个run方法的定义：</p>
<ul>
<li>public abstract void run();</li>
</ul>
<p>即制定了一种做事情的方案(其实就是一个函数)：</p>
<ul>
<li><strong>无参数：</strong>不需要任何条件计科执行该方案。</li>
<li><strong>无返回值：</strong>该方案不产生任何结果。</li>
<li><strong>代码块(方法体)：</strong>该方案的具体执行步骤。</li>
</ul>
<p>同语义体现在<code>Lambda</code>语法中更简单：</p>
<pre><code>()-&gt;System.out.println(&quot;多线程执行！&quot;)</code></pre><ul>
<li>前面的小括号即<code>run</code>方法的参数(无)，代表不需要任何条件；</li>
<li>中间的一个剪头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6Lambda标准格式"><a href="#3-6Lambda标准格式" class="headerlink" title="3.6Lambda标准格式"></a>3.6Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由3个部分组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<pre><code>(参数类型 参数名称)-&gt;{代码语句}</code></pre><p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空，多个参数则用逗号隔开。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7练习：使用Lambda标准格式-无参无返回值"><a href="#3-7练习：使用Lambda标准格式-无参无返回值" class="headerlink" title="3.7练习：使用Lambda标准格式(无参无返回值)"></a>3.7练习：使用Lambda标准格式(无参无返回值)</h2><p><strong>题目</strong><br>给定一个厨子<code>cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数，无返回值。</p>
<pre><code>public interface Cook {
    //定义无参数无返回值的方法
    void makeFood();
}</code></pre><p>在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出”吃饭了！”字样：</p>
<pre><code>/*
    需求：
        给定一个厨子cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值.
        使用Lambda的标准格式调用invokeCook方法，打印输出&quot;吃饭啦！&quot;字样
*/
public class Practice {
    public static void main(String[] args) {
        //调用invokeCook方法，参数是Cook接口，传递Cook接口的匿名内部类对象
        invokeCook(new Cook() {
            @Override
            public void makeFood(){
                System.out.println(&quot;吃饭了&quot;);
            }
        });

        //使用Lambda表达式，简化匿名内部类的书写
        invokeCook(()-&gt;{
            System.out.println(&quot;吃饭了&quot;);
        });
    }
    //定义一个方法，参数传递Cook接口，方法内部调用Cook接口中的方法makeFood
    public static void invokeCook(Cook cook){
        cook.makeFood();
    }
}</code></pre><blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体</p>
</blockquote>
<h2 id="3-8Lambda的参数和返回值"><a href="#3-8Lambda的参数和返回值" class="headerlink" title="3.8Lambda的参数和返回值"></a>3.8Lambda的参数和返回值</h2><pre><code>/*
    Lambda表达式又参数有返回值的练习
    需求：
        使用数组存储多个Person对象
        对数组中的Person对象使用Arrays的sort方法进行升序排序
*/
public class Practice2 {
    public static void main(String[] args) {
        Person[] arr = {
                new Person(&quot;zwz&quot;,19),
                new Person(&quot;hxm&quot;,18),
                new Person(&quot;yhx&quot;,20)
        };
/*
        //对数组中的Person对象使用Arrays的sort方法进行升序(前面-后面)排序
        Arrays.sort(arr, new Comparator&lt;Person&gt;() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()-o2.getAge();
            }
        });
*/
        //使用Lambda表达式，简化匿名内部类
        Arrays.sort(arr,(Person o1, Person o2)-&gt;{
            return o1.getAge()-o2.getAge();
        });

        //遍历数组
        for (Person p : arr){
            System.out.println(p);
        }
    }
}</code></pre><p><strong>代码分析</strong></p>
<p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序， Arrays.sort 方法需要排序规则，即 Comparator 接口的实例，抽象方法 compare 是关键；</li>
<li>为了指定 compare 的方法体，不得不需要 Comparator 接口的实现类；</li>
<li>为了省去定义一个 ComparatorImpl 实现类的麻烦，不得不使用匿名内部类；</li>
<li>必须覆盖重写抽象 compare 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；</li>
<li>实际上，只有参数和方法体才是关</li>
</ul>
<h2 id="3-9练习：使用Lambda标准格式-有参有返回"><a href="#3-9练习：使用Lambda标准格式-有参有返回" class="headerlink" title="3.9练习：使用Lambda标准格式(有参有返回)"></a>3.9练习：使用Lambda标准格式(有参有返回)</h2><p><strong>题目</strong></p>
<p>给定一个计算机<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<pre><code>public interface Calculator{
    int calc(int a,int b);
}</code></pre><p>测试类中：</p>
<pre><code>/*
    Lambda表达式有参数有返回值的练习
    需求：
        给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值
        使用Lambda的标准格式调用invokeCalc方法，完成120+130的相加计算
*/
public class Practice3 {
    public static void main(String[] args) {
        //调用invokeCalc方法，方法的参数是一个接口，可以使用匿名内部类
        invokeCalc(10, 20, new Calculator() {
            @Override
            public int calc(int a, int b) {
                return a+b;
            }
        });

        //使用Lambda表达式
        invokeCalc(120,130,(int a,int b)-&gt;{
            return a+b;
        });
    }

    //定义一个方法，参数传递两个int类型整数
    //参数传递Calculator中的方法calc计算两个整数的和

    public static void invokeCalc(int a,int b,Calculator c){
        int sum = c.calc(a,b);
        System.out.println(sum);
    }
}</code></pre><blockquote>
<p>在Lambda表达式里面 小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数。大括号表示<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><p><strong>可推导即可省略</strong></p>
<p>Lambda强调的是”做什么”而不是”怎么做”,所以凡是可以根据上下文推导得知的信息，都可以省略，比如上述还可以用简便写法。</p>
<pre><code>public static void main(String[] aegs){
    invokeCalc(120,130,(a,b) -&gt; a+b);
}</code></pre><p><strong>省略规则</strong></p>
<p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参数，</strong>则小括号可以省略。</li>
<li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号，return关键字，及其语句分号。</li>
</ol>
<h3 id="3-11-Lambda的使用前提"><a href="#3-11-Lambda的使用前提" class="headerlink" title="3.11 Lambda的使用前提"></a>3.11 Lambda的使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong></br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong></br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>P.S 有且仅有一个抽象方法的接口，称为<strong>“函数式接口”</strong></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-07 12:12:36" itemprop="dateModified" datetime="2020-07-07T12:12:36+08:00">2020-07-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程-amp-同步"><a href="#线程-amp-同步" class="headerlink" title="线程&amp;同步"></a>线程&amp;同步</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><p>一开始我们写的程序都是只有一条线程在占用 CPU 即 main(主)线程。如：</p>
<pre><code>/*
    主线程：执行主(main)方法的线程

    单线程程序：java程序中中只有一个线程
    执行从main方法开始，从上到下依次执行

    JVM执行main方法，main方法会进入到栈内存
    JVM会找操作系统开辟一条main方法通向CPU的执行路径
    CPU就可以通过这个路径来执行main方法
    而该路径有个名字叫做main(主)线程

*/
public class TestThread {
    public static void main(String[] args) {
        Person s = new Person(&quot;曾炜圳&quot;);
        s.run();

        Person s1 = new Person(&quot;黄雪蔓&quot;);
        s1.run();
    }
}</code></pre><blockquote>
<p>Person里面有对应的set，get方法。以及相应的run方法和构造方法</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><hr>
<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>
<p><img src="http://m.qpic.cn/psc?/V1330WLB2ZBOB6/.GvYSzOiitXBn4c048fBdVfnLcQfAW*9TCoZEMW8qqkXq8J0wn5vM*raZqQDS*G4APLepQic9cYmq2KBe6pBQA!!/mnull&bo=BAP.AgAAAAARB8s!&rf=photolist&t=5" alt=""></p>
<p>当执行的线程任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>public Thread():分配一个新的线程对象。</li>
<li>public Thread(String name):分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target):分配一个带有指定目标新的线程对象。</li>
<li>public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li>public String getName():获得当前线程的名字</li>
<li>public void start():导致此线程开始执行，Java虚拟机调用此线程的run方法。</li>
<li>public void run():此线程要执行的任务在此处定义代码。</li>
<li>public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停(暂停停止执行)。</li>
<li>public static Thread currentThread():返回正在执行的线程对象的引用。</li>
</ul>
<blockquote>
<p>翻阅API文档可抑制创建线程方式就两种：一种是继承Thread类方式，一种是实现Runnable接口方式。接下来分析Runnable接口方式</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码，程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也与预期一样，就说线程安全的。</p>
<p>我们通过一个案例，演示线程的安全问题：</p>
<pre><code>/*
    实现卖票案例
*/
public class RunnableImplements02 implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        //先判断票是否存在
        while (true) {
            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                ticket--;
            }
        }
    }
}


public class TestThreadSafe {
    public static void main(String[] args) {
        //创建一个Runnable接口的实现类对象
        RunnableImplements02 r = new RunnableImplements02();
        //创建一个Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread t0 = new Thread(r);
        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);

        t1.start();
        t0.start();
        t2.start();
    }
}    </code></pre><p>会出现了</p>
<pre><code>Thread-0--&gt;正在卖第100张票
Thread-2--&gt;正在卖第100张票
Thread-1--&gt;正在卖第100张票
Thread-1--&gt;正在卖第97张票
Thread-2--&gt;正在卖第97张票
Thread-0--&gt;正在卖第97张票
...</code></pre><p>如下是图解：</p>
<hr>
<blockquote>
<p>多线程执行run方法遇到的问题</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/28/YsFigBZl2nDSpxu.png" alt="1593352976_1_.jpg"></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当我们使用多个线程访问同一资源的时候，而且多线程对资源有写的操作，就容易出现线程安全问题。</p>
<p>要解决上述问题并发访问同一个资源的安全性问题：也就是解决重复票与不存在票的问题，Java提供了同步机制(synchronized)来解决</p>
<p>为了保证每个线程都能正常执行原子操作Java引入了线程同步机制。那么怎么去使用呢？有三种方法完成同步操作。</p>
<ol>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制</li>
</ol>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li>同步代码块：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只是岁这个区块的资源实行互斥访问.</li>
</ul>
<p>格式:</p>
<pre><code>synchronized(同步锁){
    需要同步操作的代码
}</code></pre><p>同步锁：</p>
<p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。<br>    1. 锁对象可以是任意类型。<br>    2. 多个线程对象，需要同一把锁。</p>
<blockquote>
<p>注意：在任何时候，只允许一个线程拥有同步锁，谁拿到锁谁就可以进入代码块。其他的线程只能等着，即(BLOCKED)状态。</p>
</blockquote>
<pre><code>/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的一种方案：使用同步代码块
    格式
        synchronized(锁对象){
            可能会出现线程安全问题的代码(访问了共享数据的代码)
        }
    注意：
        1.通过代码块中的锁对象，可以使用任意的对象
        2.必须保证多个线程使用的锁对象是同一个
        3.锁对象作用：
            把同步代码块锁住，只让一个线程在同步代码块中执行
*/
public class RunnableImpl implements Runnable                                                           {
        //定义一个多个线程共享的票源
        private int ticket = 100;

        //创建一个锁对象
        Object obj = new Object();

        //设置线程任务：卖票
        @Override
        public void run() {
            //先判断票是否存在
            while (true) {
                //创建一个同步代码块
                synchronized (obj){
                    if (ticket &gt; 0) {
                        //提高安全问题出现的概率，让程序睡眠
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        //票存在,卖票 ticket--
                        System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                        ticket--;
                    }
                }
            }
        }
    }</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><p>从而就不会出现票为负或者同一票被多线程同时卖出了</p>
<blockquote>
<p>同步代码块运行的原理</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/29/JC3mKRZbAwdf9lV.png" alt="1593407072_1_.jpg"></p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul>
<li>同步方法:使用synchronized修饰的方法，就叫做同步方法。保证A线程执行该方法的时候，其他线程只能在方法外等着</li>
</ul>
<p>格式是：</p>
<pre><code>public synchronized void method(){
    可能会产生线程安全问题的代码
}</code></pre><blockquote>
<p>同步锁是谁？<br>对于非static方法，同步锁就是this。<br>对于static方法，我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<p>使用同步方法代码如下：</p>
<pre><code>/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的第二种方案：使用同步方法
    使用步骤:
        1.把访问了共享数据的代码抽取出来，放到一个方法中
        2.在方法上添加一个synchronize修饰符

    格式：定义方法的格式
    修饰符 synchronize 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码(访问了共享数据的代码)
    }
*/
public class RunnableImpl implements Runnable {
        //定义一个多个线程共享的票源
        private int ticket = 100;

        //创建一个锁对象
        Object obj = new Object();

        //设置线程任务：卖票
        @Override
        public void run () {
            System.out.println(&quot;this:&quot; + this);
            //先判断票是否存在
            while (true) {
                payTicket();
            }
        }


        /*
            定义一个同步方法
            同步方法也会把方法内部的代码锁住
            只让一个线程执行
            同步方法的锁对象是谁？
            就是实现类对象 new RunnableImpl()
            也就是this
        */
        public synchronized void payTicket(){
            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                ticket--;
            }
        }
}</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        System.out.println(&quot;run：&quot; + run);
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。</p>
<p>Lock锁也叫做同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code>：加同步锁</li>
<li><code>public void unlock()</code>：释放锁</li>
</ul>
<p>使用方法如下：</p>
<pre><code>import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的三种方案：使用lock锁
    java.util.concurrent.locks
    lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁对操作。
    Lock接口中的方法:
        void lock()获取锁
        void unlock()释放锁
    java.util.concurrent.locks.ReentrantLock implements Lock接口

    使用步骤：
        1.在成员位置创建一个ReentrantLock对象
        2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
        3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁

*/
public class RunnableImpl implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //1.在成员位置创建一个ReentrantLock对象
    Lock l = new ReentrantLock();

    //设置线程任务：卖票
    @Override
    public void run() {
        System.out.println(&quot;this:&quot; + this);
        //先判断票是否存在
        while (true) {
            //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
            l.lock();

            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                    //票存在,卖票 ticket--
                    System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                    ticket--;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
                    l.unlock();//无论程序是否异常都会把锁释放
                }
            }
        }
    }</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        System.out.println(&quot;run：&quot; + run);
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><blockquote>
<p>线程的状态</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/29/CAv8iy34BNsPajh.png" alt="1593433469_1_.jpg"></p>
<ul>
<li>NEW 至今尚未启动的线程处于这种状态。</li>
<li>RUNNABLE 正在Java JVM中执行的线程处于这种状态</li>
<li>BLOCKED受阻塞并等待某一个监视器锁的线程处于这种状态。</li>
<li>WAITING 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</li>
<li>TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。</li>
<li>TERMINATED 已退出的线程处于这种状态。</li>
</ul>
<p>阻塞状态：具有CPU的执行资格，等待CPU空闲时执行。<br>休眠状态：放弃CPU的执行资格，CPU空闲也不执行。</p>
<p>通过<code>new Thread()</code>或者<code>new Thread子类</code>获得一个新建的线程。通过<code>start()</code>方法会使线程进入<code>RUNNABLE</code>运行状态。如果<strong>CPU被占</strong><code>则会进入BLOCKED</code>阻塞状态。由于多个线程之间会互相抢夺CPU的执行时间。因此线程可能会进入<code>BLOCKED-&gt;RUNNABLE-&gt;BLOCKED...</code>阻塞运行相互转换的过程。当<code>run()</code>方法执行完后或者执行<code>stop()</code>方法。线程就会死亡，进入<code>TERMINATED</code>死亡状态。</p>
<p>在<code>RUNNABLE</code>状态下使用<code>sleep(long)\wait(long)</code>都会让线程进入<code>TIMED_WAITING</code>(休眠状态)当计时器结束。则会根据CPU的情况进入<code>BLOCKED</code>或者<code>RUNNABLE</code>状态。</p>
<p>在<code>RUNNABLE</code>状态下使用<code>Object.wait()</code>会使线程进入<code>WAITING</code>(无限等待状态) 通过<code>Object.notify()</code>根据CPU被占用情况进入<code>RUNNABLE\BLOCKED</code>状态。</p>
<blockquote>
<p><code>TIMED_WAITING\WAITING</code>两种状态均为冻结状态。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">方法与构造方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 22:19:20" itemprop="dateModified" datetime="2020-04-30T22:19:20+08:00">2020-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="方法与构造方法"><a href="#方法与构造方法" class="headerlink" title="方法与构造方法"></a>方法与构造方法</h1><p>我们常用的System.out.println()，是什么呢？</p>
<ul>
<li>println()是一个方法。</li>
<li>System是系统类。</li>
<li>out是标准输出对象。</li>
</ul>
<p>这句话的意思就是调用系统类System中的标准输出对象out中的方法println().</p>
<h2 id="那什么是方法呢？"><a href="#那什么是方法呢？" class="headerlink" title="那什么是方法呢？"></a>那什么是方法呢？</h2><p>Java方法是语句的集合，它们在一起执行一个功能。就像C的函数一样。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h2 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h2><ul>
<li>使程序变得更简短而清晰。</li>
<li>有利于维护程序</li>
<li>可以提高程序开发的效率</li>
<li>提高了代码的重用性</li>
</ul>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<pre><code>修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值；
}</code></pre><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需要的操作，但没有返回值。这种情况下，returnValueType 是关键字void。</li>
<li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>参数类型：参数像一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数，参数是可选的，方法可以不包含任何参数。</li>
<li>方法体：方法体包含具体的语句，定义该方法的功能。<br><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1220955916.jpg" alt=""></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E6%8C%BA%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E6%8C%BA%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">挺重要的控制字符串</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-24 15:58:58" itemprop="dateModified" datetime="2020-05-24T15:58:58+08:00">2020-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>class practiceContorlString {
    public static void main(String[] args) {
        //--------------------------------------------------------------------
        //给出一句英文句子： &quot;let there be light&quot;
        //得到一个新的字符串，每个单词的首字母都转换为大写
        String str6 = &quot;let there be light&quot;;
        String []str7 = str6.split(&quot; &quot;);
        String str8=&quot;&quot;;
        String str9=&quot;&quot;;
        for(int i=0;i&lt;str7.length;i++){
            str8 = str7[i].substring(0,1).toUpperCase()+str7[i].substring(1);
            str8 = str8 + &quot; &quot;;
            str9+=str8;
        }
        System.out.println(str9);
        // --------------------------------------------------------------------
        //英文绕口令
        //peter piper picked a peck of pickled peppers
        //统计这段绕口令有多少个以p开头的单词
        String str = &quot;peter piper picked a peck of pickled peppers&quot;;
        String []str1 = str.split(&quot; &quot;);
        int count = 0;
        for (String temp : str1){
            if (temp.charAt(0)==&apos;p&apos;)
                count++;
        }
        System.out.println(&quot;p次数：&quot; + count);
        //--------------------------------------------------------------------
        //Nature has given us that two ears, two eyes, and but one tongue, to the end that we should hear and see more than we speak
        //把最后一个two单词首字母大写
        String str2 = &quot;Nature has given us that two ears, two eyes, and but one tongue,&quot; +
                      &quot; to the end that we should hear and see more than we speak&quot;;
        char []arr =  str2.toCharArray();
        int index = str2.lastIndexOf(&quot;two&quot;);
        for (int i = index; i &lt; index+1;i++){
            int c = arr[i]-32;
            char c1 = (char)c;
            arr[i] = c1;
        }
        String str10 = String.valueOf(arr);
        System.out.println(str10);


        //--------------------------------------------------------------------
        //把 legendary 最后一个字母变大写
        String str3 = &quot;legendary&quot;;
        String str4 = str3.substring(0,str3.length()-1) +
                      str3.substring(str3.length()-1).toUpperCase();
        System.out.println(str4);
        //--------------------------------------------------------------------
        //把 lengendary 改成间隔大写小写模式，即 LeNgEnDaRy
        String str5 = &quot;legendary&quot;;
        char[] cs = str5.toCharArray();
        for (int i = 0;i&lt;str5.length();i++){
            if (i%2 == 0)
                cs[i] = Character.toUpperCase(cs[i]);
        }
        String c = String.valueOf(cs);
        System.out.println(c);

        //--------------------------------------------------------------------
    }

}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E5%88%9D%E5%AD%A6JS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E5%88%9D%E5%AD%A6JS/" class="post-title-link" itemprop="url">初学JS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-22 11:46:42" itemprop="dateModified" datetime="2020-03-22T11:46:42+08:00">2020-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="刚开始学JavaScript"><a href="#刚开始学JavaScript" class="headerlink" title="刚开始学JavaScript"></a>刚开始学JavaScript</h1><hr>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>“是一种脚本语言，主要用于Web。它用于增强HTML页面，通常可以嵌入HTML代码中。JavaScript是一种解释型语言。因此，它不需要编译。”</p>
</blockquote>
<br/>
简单来说:"根据用户做的一些操作，来修改页面的样式，属性等，叫做js。"(个人理解

<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>ECMAScript 解释器是JS的核心</li>
<li>DOM:Document Object Model（文档对象模型） 操作HTML文档 在JS里面就是document这个用处</li>
<li>BOM：Browser Object Model (浏览器对象模型)</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>类型：typeof运算符</br><br>常见的变量类型有：number,string,boolean,undefined,object,funtion</br><br>类型转换:</br><br>parseInt()、paarseFloat()</br><br><code>==</code>：先转换类型后比较</br><br><code>===</code>:不转换类型直接比较</br><br>NaN：不是一个数字</p>
<h4 id="运算符-基本语句……"><a href="#运算符-基本语句……" class="headerlink" title="运算符 基本语句……"></a>运算符 基本语句……</h4><p>语句大致跟C语言的一样的，可以参照C语言的语句</p>
<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>一个十分类似python的字典的东西 例如python里面用到的<code>for i in ..</code>语句在JS里面也可以运用，所以JS和python基本语法也是很类似的。</p>
<blockquote>
<p>json其实与python字典用法差不多<br>在json里面<code>var a={time:&#39;4am&#39;,person:&#39;zwz&#39;}</code> python里面<code>a={&#39;color&#39;:&#39;green&#39;,&#39;point&#39;:5}</code>就是键值对</p>
</blockquote>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>学完很惊讶的发现，数组的应用与python的列表神似呀!</br></p>
<p>添加/删除元素的方法</br><br>添加:1.push(元素)，从尾部添加           2.unshift(元素)从头部添加</br><br>删除:1.pop()，从尾部弹出 2.shift()，从为头部弹出</p>
<p>拼接</br><br>concat(数组2) 例如:concat</p>
<pre><code>`var a=[1,2,3]`
`var b=[4,5,6]`
`alert(a.concat(b))`</code></pre><p>会输出[1,2,3,4,5,6]</p>
<p>再例如：join</p>
<pre><code>`var a=[1,2,3,4];`
`alert(arr.join(&apos;-&apos;));`</code></pre><p>会输出 1-2-3-4 join里面的东西是什么都行</p>
<p>排序sort</p>
<pre><code>`var arr[&apos;c&apos;,&apos;b&apos;,&apos;z&apos;,&apos;a&apos;]`
`arr.sort()`
`alert(arr)`</code></pre><p>会输出a,b,c,z</p>
<p>在比较数字的时候例如</p>
<pre><code>`var arr[111,333,442,5,6]`
`arr.sort(function(n1, n2){
    return n1 - n2; )}`</code></pre><p>需要这么做才可以排序数字数组</p>
<blockquote>
<p>sort只能识别字符串</p>
</blockquote>
<p>splice的用法</p>
<pre><code>`arr=[1,2,3,4,5,6]`&lt;/br&gt;
`arr.splice(2,3)`&lt;/br&gt;
`alert(arr)`&lt;/br&gt;</code></pre><p>会出现1，2，6,从arr[2]→arr[5]都被删除了.可见用法删除：splice(起点，长度)</br></p>
<pre><code>`arr=[1,2,3,4,5,6]`&lt;/br&gt;
`arr.splice(2,0,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)`&lt;/br&gt;
`alert(arr)`&lt;/br&gt;</code></pre><p>会出现1，2，’a’’b’’c’，3，4，5，6，从arr[2]后面增加’a’,’b’,’c’三个元素.<br>用法插入：splice(起点，长度，元素…)</p>
<hr>
<p><code>document.getElementById()</code><br>可以在任何浏览器下使用，不会出现兼容性问题.</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>函数能传参，而且想传几个传几个。例如<code>function varName(a,b,c,..)</code></br><br>举多个栗子</br><br>script部分</p>
<p><code>function setColor(color) {
    var oDiv = document.getElementById(&#39;div1&#39;);</code></br><br>    <code>oDiv.style.background = color;
        }</code></br><br>body部分</p>
<pre><code>`&lt;input type=&quot;button&quot; value=&quot;变绿&quot; onclick=&quot;setColor(&apos;green&apos;)&quot;&gt;`
`&lt;input type=&quot;button&quot; value=&quot;变黄&quot; onclick=&quot;setColor(&apos;yellow&apos;)&gt;`
`&lt;input type=&quot;button&quot; value=&quot;变黑&quot; onclick=&quot;setColor(&apos;balck&apos;)&quot;&gt;`</code></pre><blockquote>
<p>函数其实就是个占位符 在函数里有定不下来的东西就可以用函数传参</p>
</blockquote>
<p>第二种方法<br>    <code>function setStyle(name, value)</code><br>    <code>{ var oDiv = document.getElementById(&#39;div1&#39;);</code><br>    <code>oDiv.style[name]=value}</code></p>
<p>body部分</p>
<pre><code>`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;width&apos;,&apos;400px&apos;)&quot;`
`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;height&apos;,&apos;400px&apos;)&quot;`
`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;color&apos;,&apos;green&apos;)&quot;`</code></pre><blockquote>
<p><code>.</code>能做的事<code>[]</code>都能做，反之而不一定。当要修改的属性不固定的时候常用例如这里的一会变颜色一会变宽高可以用这种方式传参</p>
</blockquote>
<p>PS.修改样式的时候比如运用<code>.style.</code>修改的是行间的样式但是<code>className</code>是直接添加class属性。由于行间样式优先级大于引用样式因此，在同一标签下先改.style的样式再改class的样式后者是显示不出来的。</p>
<h3 id="提取行间事件"><a href="#提取行间事件" class="headerlink" title="提取行间事件"></a>提取行间事件</h3><p>1.为元素添加事件。以onclick事件为例子</p>
<pre><code>`function 名字(){...;}`
`oBtn.onclick=名字`</code></pre><p>或者</p>
<pre><code>`oBtn.onclick=function(){...;}`</code></pre><blockquote>
<p>这两段代码需要在body里且在input标签下方才能执行。若script放进head里面就会报错，原因是js是一行一行读的，在head里面则会给未知的oBtn加一个onclick从而报错。</p>
</blockquote>
<p>此时window.onload出现了</p>
<pre><code>`window.onload = function(）{
        var oBtn = document.getElementById(&apos;btn1&apos;)
        oBtn.onclick = function() {
            alert(&apos;a&apos;);
        }
    }</code></pre><blockquote>
<p>window.onload的作用是加载完整个网页再进行js代码</p>
</blockquote>
<h3 id="获取一组元素"><a href="#获取一组元素" class="headerlink" title="获取一组元素"></a>获取一组元素</h3><pre><code>`getElementsByTagName`</code></pre><p>如过我们要给一堆且相同的标签添加样式的话，可以用循环实现比如说给div添加样式<br>可以用以下代码实现 </p>
<pre><code>`for(var i=0&apos;i&lt;aDiv.length;i++)`</code></pre><p>运用 <strong>this</strong> 来表示当前发生的元素</p>
<hr>

<pre><code>`oDiv.innerHTML = oTxt.value;`</code></pre><p>oTxt.value的值赋予了oDiv.innerHTML中<br>把它嵌套在<code>oBtn.onclick = function() {}</code>里面就可以点击button把text里的值赋予div。</p>
<blockquote>
<p>由于里面有HTML所以可以在里面运用html代码，即可以输入<code>&lt;h2&gt;标题&lt;h2/&gt;</code>这类代码，并实现。</p>
</blockquote>
<p>在语句中’+ something +’,’++’可以实现字符串的拼接；</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ol>
<li>可以使用<code>setInterval(var,time)</code>来进行无限次的且时隔time ms的间隔弹窗 使用clearInterval来关闭</li>
<li>使用<code>setTimeout(var,time)</code>来进行一次时隔time ms的弹窗 使用clearTimeout来关闭</li>
</ol>
<blockquote>
<p>可以进行无缝滚动或者移入移出弹框 很方便</p>
</blockquote>
<h3 id="DOM基础"><a href="#DOM基础" class="headerlink" title="DOM基础"></a>DOM基础</h3><p>childNodes 可以查询父节点下面的子节点有多少个 （其中包括文本节点和元素节点）<br></br><br>nodeType 可以显示节点的类型比如说：1.代表元素节点 2.代表属性节点 3.嗲表文本节点….</br><br>parentNode 可以获取父节点.<br>offsetParent 根据样式的不同会有不一样的显示<br>firstElementChild 获取第一个元素子节点</br><br>lastElementChild 获取最后一个元素子节点</br></p>
<h4 id="DOM方式操作元素属性"><a href="#DOM方式操作元素属性" class="headerlink" title="DOM方式操作元素属性"></a>DOM方式操作元素属性</h4><ul>
<li>获取：getAttribute (名称)</li>
<li>设置: setAttribute (名称，值)</li>
<li>删除：removeAttribute (名称)<blockquote>
<p>很少用到DOM来操作元素</p>
</blockquote>
</li>
</ul>
<h4 id="创建、插入和删除元素"><a href="#创建、插入和删除元素" class="headerlink" title="创建、插入和删除元素"></a>创建、插入和删除元素</h4><ul>
<li>创建DOM元素<ul>
<li>createElement(标签名) 创建一个节点<blockquote>
<p>需要利用appendChild加入 ，基本格式为父级.appendChild(子节点) 例子：</br><code>var oLi=document.createElement(&#39;li&#39;)</code></br><br><code>oUl.appendChild(oLi)</code></p>
</blockquote>
</li>
<li>appendChild(节点) 追加一个节点例子：为ul插入li.</li>
</ul>
</li>
<li>插入元素<br>  -insertBefore(节点，原有节点) 在已有元素的前面插入<blockquote>
<p>要把元素添加在前面则可以用这条语句，首先先把需要添加元素的父级中把子集全部选定出来，在使用该语句。例如：<br>  </br><code>var oLi = document.createElement(&#39;li&#39;);</code></br><br>   <code>var aLi = oUl.getElementsByTagName(&#39;li&#39;)</code><br>  <code>oUl.insertBefore(oLi, aLi[0])</code></p>
</blockquote>
</li>
<li>删除DOM元素<ul>
<li>removeChild(节点) 删除一个节点</li>
</ul>
</li>
</ul>
<h3 id="表格应用"><a href="#表格应用" class="headerlink" title="表格应用"></a>表格应用</h3><ul>
<li><p>获取</p>
<ul>
<li><p>tBodies、tHead、tFoot、rows、cells 用法<br><code>oTab.getElementsByTagName(&#39;tbody&#39;)[0]</code><br><code>.getElementsByTagName(&#39;tr&#39;)[1]</code><br><code>.getElementsByTagName(&#39;td&#39;)[1].innerHTML</code></br></p>
<p>  这个用法等同于</p>
<p>  <code>oTab.tBodies[0].rows[1].cells[1].innerHTML</code></p>
</li>
</ul>
</li>
<li><p>隔行变色</p>
<ul>
<li><code>for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++)</code></br><br><code>if (i % 2)</code></br>`{<pre><code>    oTab.tBodies[0].rows[i].style.background = &apos;#CCC&apos;;
} `&lt;/br&gt;</code></pre><code>else</code> </br><code>{oTab.tBodies[0].rows[i].style.background = &#39;&#39;}</code></li>
</ul>
</li>
</ul>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><h4 id="运动框架"><a href="#运动框架" class="headerlink" title="运动框架"></a>运动框架</h4><ul>
<li>在运动开始的时候，关闭已有的定时器</li>
<li>把运动和暂停隔开(if,else)</li>
</ul>
<blockquote>
<p>不好写emmm，看代码吧 &lt;运动1&gt; JS源代码里面看</p>
</blockquote>
<h4 id="多物体运动框架"><a href="#多物体运动框架" class="headerlink" title="多物体运动框架"></a>多物体运动框架</h4><ul>
<li>定时器作为物体的属性</li>
<li>并且在写多个物体运动的时候，变量是不可以公用的，比如多个div淡入淡出就可以发现，会有异样详情看 JS代码里面的多物体淡入淡出。</li>
<li>属性与运动对象绑定：速度、其他属性值等（比如透明度）</li>
</ul>
<blockquote>
<p>如果写JS多物体运动框架可以参考JS网页里面“去掉offset,添加形参的运动框架” 消化消化知识点。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E6%B3%95/" class="post-title-link" itemprop="url">二叉树排序法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-07 20:55:58" itemprop="dateModified" datetime="2020-06-07T20:55:58+08:00">2020-06-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>package ArrayList;

import java.util.ArrayList;
import java.util.List;

public class Node {
    public Node leftNode;
    public Node rightNode;

    public Object value;

    public static void main(String[] args) {
        int []randoms = new int[]{67,7,30,73,10,0,78,81,10,74};
        Node roots = new Node();
        for (int number : randoms){
            roots.add(number);
        }
        System.out.println(roots.value());
    }
    //插入 数据
    public void add(Object v){
        //如果当前节点没有值，就把数据放在当前节点上
        if (null == value){
            value = v ;
        }
        //如果当前节点有值，就进行判断，新增的值与现在的值的大小关系
        else {
            if ((Integer) v &lt; (Integer)value ){
                if (null == leftNode){
                    leftNode = new Node();
                }
                leftNode.add(v);
            }else {
                if(null == rightNode){
                    rightNode = new Node();
                }
                rightNode.add(v);
            }
        }
    }
    //中序遍历所有的节点
    public List&lt;Object&gt; value(){
        List&lt;Object&gt; values = new ArrayList&lt;&gt;();

        //左节点的遍历结果
        if (null != leftNode){
            values.addAll(leftNode.value());
        }
        //当前节点
        values.add(value);

        //右节点的遍历结果
        if (rightNode != null){
            values.addAll(rightNode.value());
        }
        return values;
    }
}</code></pre><blockquote>
<p>中序遍历的意思就是：先遍历左子树 然后 读取根节点 然后读取 右子树<br><img src="https://i.loli.net/2020/06/07/DQHGquFdAsLM5Tv.jpg" alt="微信图片_20200607194407.jpg"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/sizeof%E7%9A%84%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/sizeof%E7%9A%84%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">sizeof的用法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-05 21:06:38" itemprop="dateModified" datetime="2020-04-05T21:06:38+08:00">2020-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sizeof的用法"><a href="#sizeof的用法" class="headerlink" title="sizeof的用法"></a>sizeof的用法</h1><p><img src="https://img-blog.csdn.net/201804291534473" alt=""><br><img src="https://img-blog.csdn.net/2018042915351990" alt=""><br><img src="https://img-blog.csdn.net/20180429153532932" alt=""></p>
<p>均转载，以便复习以及加上一些注解</p>
<p>相对应的数据类型的字节数<br><img src="https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/python/" class="post-title-link" itemprop="url">python</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-29 20:15:22" itemprop="dateModified" datetime="2020-03-29T20:15:22+08:00">2020-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><blockquote>
<p>以下var全部是自定义变量</p>
</blockquote>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>定义一个列表十分简单<code>var=[&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,.....]</code></br><br>修改列表里面的元素也很简单 <code>var[i]=&#39;...&#39;</code></br></p>
<h4 id="增减元素"><a href="#增减元素" class="headerlink" title="增减元素"></a>增减元素</h4><ol>
<li>给列表末尾增添元素 <code>var.append(&quot;...&quot;)</code></li>
<li>在任意位置添加 <code>var.insert(i,&#39;...&#39;)</code></li>
<li>使用del语句删除元素 <code>del var[i]</code></li>
<li>使用pop()删除末尾元素 <code>var.pop()</code></li>
<li>使用remove()删除元素 <code>remove(&#39;value&#39;)</code><blockquote>
<p>del和pop的区别:如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还额能继续使用它，就使用方法pop()。</p>
</blockquote>
</li>
</ol>
<h4 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h4><ol>
<li><p>使用sort()对列表进行 <strong>永久性</strong> 排序 <code>var.sort()</code> 倒序<code>var.sort(reverse=True)</code></p>
</li>
<li><p>使用sorted()对列表进行<strong>临时</strong>排序 <code>print(sorted(var))</code></p>
<blockquote>
<p>为什么sorted()和sort()的用法不同呢，原因是他们的作用时间不用，因为sort是永久排序的，因此可以单独.sort()之后再print，但sorted()只能直接print才能显示顺序排列.</p>
</blockquote>
</li>
<li><p>使用reverse()进行倒序列表 <code>var.reverse()</code></p>
</li>
<li><p>使用len()可以显示列表长度 <code>len(var)</code></p>
</li>
</ol>
<h4 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h4><ol>
<li><p>遍历列表 <code>for i in var：</code>再print(i)出来就好拉。</p>
<blockquote>
<p>别忘了可爱的冒号喔，，</p>
</blockquote>
</li>
<li><p>创建数字列表<code>var = list(range(1,6))</code>会输出[1,2,3,4,5].</p>
</li>
<li><p>range()还可以指定步长<code>var = list(range(2,11,2))</code> 会输出[2,4,6,8,10].</p>
</li>
<li><p>python的运算还很简单<code>min/max/sum(var)</code></p>
</li>
<li><p>切片<code>print(var[1,4])</code>会输出列表索引中的var[1,2,3]到第4为止，但不输出4. 还能遍历哟<code>for i in var[:3]:</code></p>
</li>
<li><p>复制列表<code>var1 = var2[:]</code>就这样copy了一份了</p>
</li>
</ol>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>意义：创建一系列不可修改的元素，元组可以满足这种需求。python讲不能修改的值称为不可变的，而不可变的列表称为元组</p>
<ol>
<li>定义元组 <code>var=(...,...)</code></li>
<li>由意义可知 不允许修改元组里面的元素</li>
<li>遍历元组跟列表一样</li>
</ol>
<blockquote>
<p>相比于列表，元组是更简单的数据结构，如果需要储存的一组值在程序的整个生命周期内都不变，可使用元组。</p>
</blockquote>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ol>
<li>在比较是否相等的时候要注意大小写<code>car=&#39;Audi&#39; car==&#39;audi&#39;</code>会输出false</li>
<li>…没啥好讲的- -<blockquote>
<p>在python里面的语法是”elif” 不是 “else if”</p>
</blockquote>
</li>
</ol>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典的基本表达式是<code>var = {&#39;键&#39;:值(字符串需要用&#39;&#39;来框住),...}</code> 打印键则会输出值来。 <code>print(var[&#39;键&#39;])</code>会输出 <code>值</code></p>
<ol>
<li>添加键-值对 <code>var[&#39;color&#39;:&#39;green&#39;]</code> <code>var[&#39;键&#39;]=值</code> 就可以为字典添加一对键值对</li>
<li>可以直接创建一个空字典 <code>var={}</code> </li>
<li>修改字典里面的值 <code>var[&#39;键&#39;]=值</code></li>
<li>山粗字典里面的键值对 <code>del var[&#39;键&#39;]</code><blockquote>
<p>删除的键值对就永远消失了</p>
</blockquote>
</li>
<li>遍历字典<code>for var1,var2 in var.items():</code>var1,var2都是两个变量 var是一个字典</li>
<li>遍历字典里面的所有键<code>for var1 in var.keys():</code>var1是变量 var是一个字典</li>
<li>按顺序的遍历字典里的所有键 <code>for var1 in sorted(var.keys()):</code> var同上</li>
<li>遍历字典里面的所有值 <code>for var1 in var.values():</code> …</li>
</ol>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ol>
<li><p>字典列表</br><br> <code>var1={...}</code></br><br> <code>var2={...}</code></br><br> <code>var3={...}</code></br><br> <code>vars=[var1, var2,var3]</code></p>
<blockquote>
<p>经常要在列表中包含大量的字典，而其中每个字典都包含特定对象的众多信息。在这个列表中，所有字典的结构都相同，因此你可以遍历这个列表，并以相同的方式处理其中的每个字典</p>
</blockquote>
</li>
<li><p>还能通过列表的索引去改存入列表中的字典 <code>for var in vars[0:3]</code>(改前三个)</p>
<blockquote>
<p>有时候，需要讲列表储存在字典中，而不是将字典存储在列表中。每当需要在字典中将一个键关联到多个值使，都可以在字典中嵌套一个列表。</p>
</blockquote>
</li>
<li><p>字典中存列表<code>var = {&#39;var1&#39;:... , var2=[... , ...] }</code><br>一个小栗子：</br><br> <code>favourite_language={</code></br><br> <code>&#39;jen&#39;:[&#39;python&#39;,&#39;java&#39;,]</code></br><br> <code>sarah:[&#39;C&#39;]</code>,<br> <code>zwz:[&#39;java&#39;] }</code><br><code>for name,languages in favourite_language.items():</code></br><br> <code>print(&quot;\n&quot;+name.title()+&quot;&#39;s favourite language are:&quot;)</code></br></p>
<pre><code>`for language in languages:`&lt;/br&gt;
    `print(&quot;\t&quot; + language.title())`</code></pre></li>
</ol>
<blockquote>
<p>这里先第一次用循环使langeguas得到了列表，第二次再通过循环使language得到了循环里面的字符串</p>
</blockquote>
<ol start="4">
<li>字典里面储存字典<code>var={ var1:{ ... : ... ,... : ... },var2:{ ... : ... ,... : ... } }</code><blockquote>
<p>一般不会字典里面嵌套字典会使代码看的比较复杂。注意！ 如果每个字典里面的键不同会使导出字典里面的值更麻烦。因此尽量少用字典嵌套字典。</p>
</blockquote>
</li>
</ol>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ol>
<li>input()函数让程序暂停运行，等用户输入一些文本<code>var = input(&quot;&quot;)</code></li>
<li>用int()来获取数值输入 如果用了input等待了用户输入的一个数字，得到的结果却是一个字符串因此我们要用<code>int(var)</code>来使得用户输出来的’数字’成为一个数字。</li>
<li>使用break退出循环 continue也可以退出循环 但是二者不同，break是退出整个循环执行吓一条语句而continue是退出本次循环，倘若循环没有结束还要继续执行循环。</li>
</ol>
<blockquote>
<p>如果进入死循环，则可以按Ctrl+C退出循环。</p>
</blockquote>
<ol start="4">
<li>还能删除包含特定值的列表元素如<code>var = [1,2,3,4,5,6]</code> <code>while 2 in var</code> <code>var.remove(1)</code> <code>print(var)</code> 会输出<code>[1,3,4,5,6]</code></li>
</ol>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><blockquote>
<p>千万要记得定义函数后面要加冒号啊 <code>：</code></p>
</blockquote>
<pre><code>`def var():` 使用def来定义一个函数。在后面可以直接调用函数，`var()`即可。</code></pre><h4 id="向函数传递信息"><a href="#向函数传递信息" class="headerlink" title="向函数传递信息"></a>向函数传递信息</h4><pre><code>`def var(man):`
`print(&quot;man+&apos;love Hxm&apos;&quot;)`
`var(&apos;zwz&apos;)`</code></pre><p>会输出 zwz love Hxm</p>
<blockquote>
<p>可以在函数定义def var()的括号内添加一个东西 在调用函数的时候就可以给那个东西任何值，如上</p>
</blockquote>
<h4 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h4><blockquote>
<p>在函数var()的定义中，变量man是一个形参——函数完成工作所需要的一项信息，在代码var(‘zwz’)中，值’zwz’是一个实参，实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在var(‘zwz’)中，实参’zwz’传递给了函数var()，这个值被储存在形参man里面。</p>
</blockquote>
<h4 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h4><ul>
<li>位置实参<ul>
<li><code>def var(man,girl):</code></br><br><code>print(&quot;man+&#39;love&#39;+ girl&quot;)</code></br><br><code>var(&#39;zwz&#39;,&#39;hxm&#39;)</code></br><br>会输出zwz love hxm<blockquote>
<p>所谓的位置实参就是对应位置一个形参对应一个实参，zwz会赋予man，hxm会赋予girl所以位置关系尤为重要，如果输入错了，那么可能会有很坏的后果wo~</p>
</blockquote>
</li>
</ul>
</li>
<li>关键字实参<ul>
<li>前面定义与上一样。在调用实参的时候比如<code>var(man=&#39;zwz&#39;,girl=&#39;hxm&#39;)</code>或者可以<code>var(girl=&#39;hxm&#39;,man=&#39;zwz&#39;)</code></li>
</ul>
</li>
<li>默认值<ul>
<li>就是在定义函数的时候给形参一个实参比如说<code>var(man,girl=&#39;hxm&#39;)</code>在最后调用函数的时候可以只给man一个实参即可</li>
</ul>
</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>-返回简单值</p>
<pre><code>-`def name(first,last):`
    `full_name=first+last`
    `return full_name`
`a = name(&apos;Edward&apos;,&apos;Erwin&apos;)`
`print(a)`
会输出Edward Erwin</code></pre><p>-让实参变得可选</p>
<pre><code>`def get_formatted_name(first_name,middle_name,last_name):`
    `if middle_name:`
        `full_name = first_name + &apos;&apos; + middle_name + &apos;&apos; +last_name`
    `else:`
        `full_name = first_name + &apos;&apos; + last_name`
    `return full.name.title()`
`name = get_formatted_name(&apos;zwz&apos;,&apos;edward&apos;,&apos;erwin&apos;)`
`print(name)`</code></pre><p>会输出 Zwz Edward Erwin</p>
<pre><code>`name = get_formatted_name(&apos;zwz&apos;,&apos;erwin&apos;)`
`print(name)`</code></pre><p>会输出Zwz Erwin</p>
<blockquote>
<p>在函数体中，我们检查是否提供中间名。Python将<strong>非空字符串</strong>读为True，因此如果函数调用中间的中间名，if middle_name将为True。这里判断你是否输入中间名而执行不同的语句。</p>
</blockquote>
<h4 id="返回字典"><a href="#返回字典" class="headerlink" title="返回字典"></a>返回字典</h4><pre><code>def name(first_name,last_name):
    full_name={&apos;first&apos;:first_name,&apos;last&apos;:last_name}
    return full_name
a = name(&apos;Edward&apos;,&apos;Erwin&apos;)
print(a)</code></pre><p>会输出</p>
<pre><code>{&apos;first&apos;:&apos;Edward&apos;,&apos;last&apos;:&apos;Erwin&apos;}</code></pre><h4 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h4><pre><code>def make_pizza(*toppings):      //注意形参中有 * 号
    print(toppings)

make_pizza(&apos;pepperoni&apos;)
make_pizza(&apos;mushrooms&apos;,&apos;green peppers&apos;,&apos;extra cheese&apos;)</code></pre><p>会输出</p>
<pre><code>(&apos;pepperoni&apos;)
(&apos;mushrooms&apos;,&apos;green peppers&apos;,&apos;extra cheese&apos;)</code></pre><blockquote>
<p>形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装在这个元组中。</p>
</blockquote>
<ul>
<li><p>使用任意数量的关键字实参</p>
<blockquote>
<p>有时候，需要接受任意数量的实参，但预先布置的传递给函数的是什么样的信息。此情况可以将函数编写成能够接受任意数量的键-值对</p>
</blockquote>
<p>  def build_profile(first,last,*<em>user_Info)    // *</em> 建立空字典</p>
<pre><code>profile={}
profile[&apos;first_name&apos;]=first                      ←←←
profile[&apos;last_name&apos;]=last                         ←←←
for key,value in user_Info.items():
    profile[key]=value
retuen profile</code></pre><p>  user_profile = bulid_profile(‘albert’,’einstein’,location=’princeton’,field=’physics’)<br>  print(user_profile)</p>
</li>
</ul>
<p>会输出</p>
<pre><code>&apos;first_name&apos;:&apos;albert&apos;
&apos;last_name&apos;:&apos;einstein&apos;
&apos;location&apos;:&apos;princeton&apos;
&apos;field&apos;:&apos;physics&apos;</code></pre><blockquote>
<p>在build_profile()的函数体内，我们创建了一个名为profile的空字典，用于储存用户简介。在←←←我们将名和姓加入到这个字典中。在循环中遍历字典中的键值对，并将每个键值对都加入字典profile中。</p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是表示一类事物共同具有的特征，比如狗狗来说一般都会打滚和坐下。因此我们可以创造一个类来储存他们的动作。就比如说：</p>
<pre><code>class Dog(): 
    def_init_(self,name,age):
        self.name = name
        self.age = age
    def sit(self):
        print(self.name + &quot;is sitting&quot;)
    def roll(self):
        print(self.name + &quot;is rolling&quot;)</code></pre><p>这样就创建了一个”狗狗”类，并且把两个狗狗通常都会的动作写进了里面。</p>
<blockquote>
<p>类中的函数叫方法，<code>_init_()</code>是一种特殊的方法，每当根据Dog()创建实例的时候就会调用它。</p>
</blockquote>
<blockquote>
<p>在<code>_init_</code>里面包含了三个形参：self，name,age.在方法的定义中，形参self必不可少，还必须位于其他形参的前面。因为调用这个函数的方法来创建Dog()实例的时候，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例可以访问类中的属性和方法。调用Dog()时只需要提供 name,age 即可self会自动传递。</p>
</blockquote>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><pre><code>my_dog=Dog(&apos;hhh&apos;,6)
print(&quot;my dog name:&quot;+my_dog.name)
print(&quot;my dog age:&quot;+str(my_dog.age))</code></pre><p>会输出</p>
<pre><code>my dog name hhh
my dog age 6</code></pre><blockquote>
<p>在这里我们用一个my_dog来储存我们提供的值储存在属性name和age。</p>
</blockquote>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><pre><code>my_dog.sit()
my_dog.roll_over()</code></pre><p>就会调用方法里面的语句，并把my_dog里面的参数赋予方法中</p>
<h4 id="给属性指定的默认值"><a href="#给属性指定的默认值" class="headerlink" title="给属性指定的默认值"></a>给属性指定的默认值</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-07 21:01:44" itemprop="dateModified" datetime="2021-02-07T21:01:44+08:00">2021-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL-从删库到跑路"><a href="#MySQL-从删库到跑路" class="headerlink" title="MySQL (从删库到跑路)"></a>MySQL (<s>从删库到跑路</s>)</h1><h2 id="为什么要学习数据库"><a href="#为什么要学习数据库" class="headerlink" title="为什么要学习数据库"></a>为什么要学习数据库</h2><ol>
<li>持久化数据</li>
<li>方便检索</li>
<li>存储大量数据</li>
<li>共享、安全</li>
<li>通过组合分析，获取的数   </li>
</ol>
<h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><ol>
<li>DB:database数据库，存储一些列有组织数据的容器</li>
<li>DBMS:database Management System 数据库管理系统，使用DBMS管理DB；</li>
<li>SQL:Structure Query Language 节后话查询语言，程序员用于和DBMS通信的语言</li>
</ol>
<h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><ol>
<li>数据先放着表中，表再放在库中</li>
<li>一个库可以有多张表，每张表都有自己唯一的标识名</li>
<li>一张表的设计，类似于Java中类的设计<blockquote>
<p>表中字段的设计，类似于属性的设计</p>
</blockquote>
</li>
</ol>
<p>orm：object relation mapping 对象关系映射</p>
<h2 id="初始化MySQL"><a href="#初始化MySQL" class="headerlink" title="初始化MySQL"></a>初始化MySQL</h2><h3 id="MySQL产品介绍"><a href="#MySQL产品介绍" class="headerlink" title="MySQL产品介绍"></a>MySQL产品介绍</h3><p>MySQL前身属于瑞典的一家AB，2008年被sun公司收购，2009年sun被Oracle公司收购</p>
<p>特点：</p>
<ol>
<li>体积小、安装比较方便</li>
<li>开源、免费</li>
<li>性能镐，稳定性好</li>
<li>兼容性好</li>
</ol>
<h3 id="MySQL产品的安装"><a href="#MySQL产品的安装" class="headerlink" title="MySQL产品的安装"></a>MySQL产品的安装</h3><p>基于C/S架构的DBMS，需要安装服务端和客户端；</p>
<h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>方式1：图形化的方式</br><br>右击–计算机–管理–MySQL服务</p>
<p>方式2：通过管理员身份运行dos</br><br>net start 服务名</br><br>net stop 服务名</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>方式1：mysql -h 主机名 -P端口号 -u用户名 -p密码</br><br>注意：</br><br>如果是本机，则-h主机名可以省略</br><br>如果端口号是3306，则-p端口号可以省略</br></p>
<p>方式2：通过图形化界面客户端</br><br>通过sqlyog，直接输入用户名、密码等链接进去即可</p>
<h3 id="MySQL-的常见命令和语法规范"><a href="#MySQL-的常见命令和语法规范" class="headerlink" title="MySQL 的常见命令和语法规范"></a>MySQL 的常见命令和语法规范</h3><ul>
<li><p>常用命令</p>
<ul>
<li><code>show databases</code> 显当前连接下所有数据库</li>
<li><code>show tables</code> 显示当前库中所有表</li>
<li><code>show tables from 库名</code> 显示指定库中所有表</li>
<li><code>show columns from 表名</code> 显示指定表所有列</li>
<li><code>use 库名</code> 打开/使用指定库名</li>
</ul>
</li>
<li><p>语法规范</p>
<ul>
<li>不区分大小写</li>
<li>每条命令结尾用粉好</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li><h1 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h1></li>
<li>– 单行注释</li>
<li>/**/ 多行注释</li>
</ul>
</li>
</ul>
<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><blockquote>
<p>DQL：Data Query Language 数据查询语言</p>
</blockquote>
<h2 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h2><p>/* </p>
<p>语法：<br>select：查询列表 from 表;</p>
<p>类似于：<code>System.out.println()</code>;</p>
<p>特点：</p>
<ol>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>查询的结果是一个虚拟的表格</li>
</ol>
<p>*/</p>
<p><code>USE myemployees</code>;</p>
<ul>
<li><p>查询表中的单个字</p>
<pre><code>SELECT last_name FROM employee;</code></pre></li>
<li><p>查询表中的多个字段</p>
<pre><code>SELECT last_name,salary,email FROM employees;</code></pre></li>
<li><p>查询表中的所有字段</p>
<pre><code>SELECT * FROM employees;</code></pre></li>
<li><p>查询常量值</p>
<pre><code>SELECT 100;

SELECT &apos;john&apos;</code></pre></li>
<li><p>查询表达式</p>
</li>
</ul>
<p>`SELECT 100*98;</p>
<ul>
<li><p>查询函数</p>
<pre><code>SELECT VERSION();</code></pre></li>
<li><p>起别名 F12：对齐格式</p>
</li>
</ul>
<p>/*</p>
<p>  1.便于理解</p>
<p>  2.如果要查询的字段有重名的情况，使用别名可以区分来</p>
<p>*/</p>
<ul>
<li><p>方法一：使用as</p>
<pre><code>SELECT 100%98 AS result;

SELECT last_name AS 姓,first_name AS 名 FROM employees;</code></pre></li>
<li><p>方法2：使用空格</p>
<pre><code>SELECT last_name 姓,first_name 名 FROM employees; </code></pre></li>
</ul>
<p><strong>案例：查询salary，显示结果为out put</strong></p>
<pre><code>SELECT salary AS &quot;out put&quot; FROM employees;</code></pre><p><strong>需求：查询first_name和last_name拼接成的全名，最终起别名为：姓 名</strong></p>
<pre><code>方法一：

`SELECT first_name+last_name AS &quot;姓 名&quot; FROM employees;`

方法二：

`SELECT CONCAT(first_name,last_name) AS &quot;姓 名&quot; FROM employees;`</code></pre><ul>
<li>去重  distinct的使用</li>
</ul>
<p><strong>需求：查询员工涉及到的部门</strong></p>
<pre><code>SELECT DISTINCT department_id FROM employees;</code></pre><p>9.查看表的结构</p>
<pre><code>DESC employees;
SHOW COLUMNS FROM employees;</code></pre><ul>
<li><p>ifnull(表达式1,表达式2)(如果前面的为null 后面要求是什么就显示什么)</p>
<pre><code>SELECT commission_pct,IFNULL(commission_pct,&apos;空&apos;) FROM employees;</code></pre></li>
</ul>
<p><strong><em>测试1-基本SQL-SELECT语句</em></strong></p>
<ol>
<li><p>下面的语句是否可以执行成功 （true）</br></p>
<pre><code>SELECT lastn_name ,job_id,salary AS sal FROM employees;</code></pre></li>
<li><p>下面的语句是否可以执行成功 （true）</br></p>
<pre><code>SELECT * FROM employees;</code></pre></li>
<li><p>找出下面语句中的错误 (false last_name，)</p>
</li>
<li><p>显示表 departments 的结构，并查询其中的全部数据</p>
<pre><code>DESC deparments;
SELECT * FROM departments;</code></pre></li>
<li><p>显示出表 employees 中的全部 job_id （不能重复)</p>
<pre><code>SELECT DISTINCT job_id FROM employees;</code></pre></li>
<li><p>显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT </br></p>
<pre><code>SELECT CONCAT(employee_id,&apos;,&apos;,`first_name`,&quot;,&quot;,`last_name`,&quot;,&quot;,`email`,&quot;,&quot;,`phone_number`,&quot;,&quot;,`job_id`,&quot;,&quot;,`salary`,&quot;,&quot;,IFNULL(commission_pct,&apos; &apos;),&quot;,&quot;,IFNULL(manager_id,&apos; &apos;),&quot;,&quot;,`department_id`,&quot;,&quot;,`hiredate`)
AS &quot;OUT_PUT&quot; FROM employees </code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Maven/" class="post-title-link" itemprop="url">Maven</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-09 20:56:02" itemprop="dateModified" datetime="2021-03-09T20:56:02+08:00">2021-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
