<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZWZ的博客嘻嘻">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-07 21:01:44" itemprop="dateModified" datetime="2021-02-07T21:01:44+08:00">2021-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL-从删库到跑路"><a href="#MySQL-从删库到跑路" class="headerlink" title="MySQL (从删库到跑路)"></a>MySQL (<s>从删库到跑路</s>)</h1><h2 id="为什么要学习数据库"><a href="#为什么要学习数据库" class="headerlink" title="为什么要学习数据库"></a>为什么要学习数据库</h2><ol>
<li>持久化数据</li>
<li>方便检索</li>
<li>存储大量数据</li>
<li>共享、安全</li>
<li>通过组合分析，获取的数   </li>
</ol>
<h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><ol>
<li>DB:database数据库，存储一些列有组织数据的容器</li>
<li>DBMS:database Management System 数据库管理系统，使用DBMS管理DB；</li>
<li>SQL:Structure Query Language 节后话查询语言，程序员用于和DBMS通信的语言</li>
</ol>
<h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><ol>
<li>数据先放着表中，表再放在库中</li>
<li>一个库可以有多张表，每张表都有自己唯一的标识名</li>
<li>一张表的设计，类似于Java中类的设计<blockquote>
<p>表中字段的设计，类似于属性的设计</p>
</blockquote>
</li>
</ol>
<p>orm：object relation mapping 对象关系映射</p>
<h2 id="初始化MySQL"><a href="#初始化MySQL" class="headerlink" title="初始化MySQL"></a>初始化MySQL</h2><h3 id="MySQL产品介绍"><a href="#MySQL产品介绍" class="headerlink" title="MySQL产品介绍"></a>MySQL产品介绍</h3><p>MySQL前身属于瑞典的一家AB，2008年被sun公司收购，2009年sun被Oracle公司收购</p>
<p>特点：</p>
<ol>
<li>体积小、安装比较方便</li>
<li>开源、免费</li>
<li>性能镐，稳定性好</li>
<li>兼容性好</li>
</ol>
<h3 id="MySQL产品的安装"><a href="#MySQL产品的安装" class="headerlink" title="MySQL产品的安装"></a>MySQL产品的安装</h3><p>基于C/S架构的DBMS，需要安装服务端和客户端；</p>
<h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>方式1：图形化的方式</br><br>右击–计算机–管理–MySQL服务</p>
<p>方式2：通过管理员身份运行dos</br><br>net start 服务名</br><br>net stop 服务名</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>方式1：mysql -h 主机名 -P端口号 -u用户名 -p密码</br><br>注意：</br><br>如果是本机，则-h主机名可以省略</br><br>如果端口号是3306，则-p端口号可以省略</br></p>
<p>方式2：通过图形化界面客户端</br><br>通过sqlyog，直接输入用户名、密码等链接进去即可</p>
<h3 id="MySQL-的常见命令和语法规范"><a href="#MySQL-的常见命令和语法规范" class="headerlink" title="MySQL 的常见命令和语法规范"></a>MySQL 的常见命令和语法规范</h3><ul>
<li><p>常用命令</p>
<ul>
<li><code>show databases</code> 显当前连接下所有数据库</li>
<li><code>show tables</code> 显示当前库中所有表</li>
<li><code>show tables from 库名</code> 显示指定库中所有表</li>
<li><code>show columns from 表名</code> 显示指定表所有列</li>
<li><code>use 库名</code> 打开/使用指定库名</li>
</ul>
</li>
<li><p>语法规范</p>
<ul>
<li>不区分大小写</li>
<li>每条命令结尾用粉好</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li><h1 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h1></li>
<li>– 单行注释</li>
<li>/**/ 多行注释</li>
</ul>
</li>
</ul>
<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><blockquote>
<p>DQL：Data Query Language 数据查询语言</p>
</blockquote>
<h2 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h2><p>/* </p>
<p>语法：<br>select：查询列表 from 表;</p>
<p>类似于：<code>System.out.println()</code>;</p>
<p>特点：</p>
<ol>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>查询的结果是一个虚拟的表格</li>
</ol>
<p>*/</p>
<p><code>USE myemployees</code>;</p>
<ul>
<li><p>查询表中的单个字</p>
<pre><code>SELECT last_name FROM employee;</code></pre></li>
<li><p>查询表中的多个字段</p>
<pre><code>SELECT last_name,salary,email FROM employees;</code></pre></li>
<li><p>查询表中的所有字段</p>
<pre><code>SELECT * FROM employees;</code></pre></li>
<li><p>查询常量值</p>
<pre><code>SELECT 100;

SELECT &apos;john&apos;</code></pre></li>
<li><p>查询表达式</p>
</li>
</ul>
<p>`SELECT 100*98;</p>
<ul>
<li><p>查询函数</p>
<pre><code>SELECT VERSION();</code></pre></li>
<li><p>起别名 F12：对齐格式</p>
</li>
</ul>
<p>/*</p>
<p>  1.便于理解</p>
<p>  2.如果要查询的字段有重名的情况，使用别名可以区分来</p>
<p>*/</p>
<ul>
<li><p>方法一：使用as</p>
<pre><code>SELECT 100%98 AS result;

SELECT last_name AS 姓,first_name AS 名 FROM employees;</code></pre></li>
<li><p>方法2：使用空格</p>
<pre><code>SELECT last_name 姓,first_name 名 FROM employees; </code></pre></li>
</ul>
<p><strong>案例：查询salary，显示结果为out put</strong></p>
<pre><code>SELECT salary AS &quot;out put&quot; FROM employees;</code></pre><p><strong>需求：查询first_name和last_name拼接成的全名，最终起别名为：姓 名</strong></p>
<pre><code>方法一：

`SELECT first_name+last_name AS &quot;姓 名&quot; FROM employees;`

方法二：

`SELECT CONCAT(first_name,last_name) AS &quot;姓 名&quot; FROM employees;`</code></pre><ul>
<li>去重  distinct的使用</li>
</ul>
<p><strong>需求：查询员工涉及到的部门</strong></p>
<pre><code>SELECT DISTINCT department_id FROM employees;</code></pre><p>9.查看表的结构</p>
<pre><code>DESC employees;
SHOW COLUMNS FROM employees;</code></pre><ul>
<li><p>ifnull(表达式1,表达式2)(如果前面的为null 后面要求是什么就显示什么)</p>
<pre><code>SELECT commission_pct,IFNULL(commission_pct,&apos;空&apos;) FROM employees;</code></pre></li>
</ul>
<p><strong><em>测试1-基本SQL-SELECT语句</em></strong></p>
<ol>
<li><p>下面的语句是否可以执行成功 （true）</br></p>
<pre><code>SELECT lastn_name ,job_id,salary AS sal FROM employees;</code></pre></li>
<li><p>下面的语句是否可以执行成功 （true）</br></p>
<pre><code>SELECT * FROM employees;</code></pre></li>
<li><p>找出下面语句中的错误 (false last_name，)</p>
</li>
<li><p>显示表 departments 的结构，并查询其中的全部数据</p>
<pre><code>DESC deparments;
SELECT * FROM departments;</code></pre></li>
<li><p>显示出表 employees 中的全部 job_id （不能重复)</p>
<pre><code>SELECT DISTINCT job_id FROM employees;</code></pre></li>
<li><p>显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT </br></p>
<pre><code>SELECT CONCAT(employee_id,&apos;,&apos;,`first_name`,&quot;,&quot;,`last_name`,&quot;,&quot;,`email`,&quot;,&quot;,`phone_number`,&quot;,&quot;,`job_id`,&quot;,&quot;,`salary`,&quot;,&quot;,IFNULL(commission_pct,&apos; &apos;),&quot;,&quot;,IFNULL(manager_id,&apos; &apos;),&quot;,&quot;,`department_id`,&quot;,&quot;,`hiredate`)
AS &quot;OUT_PUT&quot; FROM employees </code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Maven/" class="post-title-link" itemprop="url">Maven</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-09 20:56:02" itemprop="dateModified" datetime="2021-03-09T20:56:02+08:00">2021-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Linux/" class="post-title-link" itemprop="url">Linux</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-15 08:57:32" itemprop="dateModified" datetime="2021-03-15T08:57:32+08:00">2021-03-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux开始"><a href="#Linux开始" class="headerlink" title="Linux开始"></a>Linux开始</h1><h2 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h2><p><img src="https://i.loli.net/2021/01/11/lgXmkc3vY5G18RD.png" alt="1610355820_1_.jpg"></p>
<h2 id="Linux学习方向"><a href="#Linux学习方向" class="headerlink" title="Linux学习方向"></a>Linux学习方向</h2><p><img src="https://i.loli.net/2021/01/11/gCRWndlkm1reijI.png" alt="1610356119_1_.jpg"></p>
<ol>
<li>Linux运维工程师</li>
<li>Linux嵌入式开发工程师</li>
<li>在Linux下做各种程序开发</li>
</ol>
<h2 id="Linux的应用领域"><a href="#Linux的应用领域" class="headerlink" title="Linux的应用领域"></a>Linux的应用领域</h2><ul>
<li><p>个人桌面应用领域</p>
<blockquote>
<p>此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺<br>点，一直被windows所压制，但近些年来随着ubuntu、fedora [fɪˈdɔ:rə] 等优秀桌面环境的兴<br>起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高。</p>
</blockquote>
</li>
<li><p>服务器应用领域</p>
<blockquote>
<p>linux在服务器领域的应用是最强的。<br>linux免费、稳定、高效等特点在这里得到了很好的体现，近些年来linux服务器市场得到了飞<br>速的提升，尤其在一些高端领域尤为广泛。</p>
</blockquote>
</li>
<li><p>嵌入式应用领域</p>
<blockquote>
<p>近些年来linux在嵌入式领域的应用得到了飞速的提高<br>linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小<br>可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高<br>主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件<br>等都是其应用领域。以后再物联网中应用会更加广泛。</p>
</blockquote>
</li>
</ul>
<h3 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h3><p><strong>第1阶段：</strong>linux环境下的基本操作命令，包括 文件操作命令(rm mkdir chmod, chown) 编辑工具使用（vi vim）linux用户管理(useradd userdel usermod)等</p>
<p><strong>第2阶段：</strong>linux的各种配置（环境变量配置，网络配置，服务配置）</p>
<p><strong>第3阶段：</strong>linux下如何搭建对应语言的开发环境（大数据，JavaEE, Python等）</p>
<p><strong>第4阶段：</strong>能编写shell脚本，对Linux服务器进行维护。</p>
<p><strong>第5阶段：</strong>能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。</p>
<p><strong>第6阶段：</strong>深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟<br>悉各个环节的部署和维护方法。</p>
<h1 id="Linux-入门"><a href="#Linux-入门" class="headerlink" title="Linux 入门"></a>Linux 入门</h1><h2 id="CentOS安装的步骤"><a href="#CentOS安装的步骤" class="headerlink" title="CentOS安装的步骤"></a>CentOS安装的步骤</h2><ol>
<li>创建虚拟机(空间)</br><br>   这里配置网络连接的时候有三个形式：<br><img src="https://i.loli.net/2021/01/14/G3kBZzwWHiECJF8.png" alt="1610369061_1_.jpg"></li>
</ol>
<h1 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li>Linux的文件系统采用层级式的树状目录结构，在此结构中最上层是根目录”/“，然后在此目录下在创建其他目录</li>
</ul>
<blockquote>
<p><strong>Linux下，一切皆为文件</strong><br><img src="https://i.loli.net/2021/01/15/NpRXaPYesfQB7Sr.png" alt="1610706297_1_.jpg"></p>
</blockquote>
<h2 id="具体的目录结构："><a href="#具体的目录结构：" class="headerlink" title="具体的目录结构："></a>具体的目录结构：</h2><ul>
<li>/bin(重点)<ul>
<li>是Binary的缩写，这个目录存放着最经常使用的命令</li>
</ul>
</li>
<li>/sbin<ul>
<li>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
</ul>
</li>
<li>/home(重点)<ul>
<li>存放普通用户的主目录，在Linux中每一个用户都有自己的目录，一般该目录名是以用户的账号命名的。</li>
</ul>
</li>
<li>/root(重点)<ul>
<li>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
</ul>
</li>
<li>/boot(重点)<ul>
<li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</li>
</ul>
</li>
<li>/proc<ul>
<li>是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</li>
</ul>
</li>
<li>/srv<ul>
<li>service缩写，该目录存放一些服务启动之后需要提取的数据</li>
</ul>
</li>
<li>/sys<ul>
<li>这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中出现的一个文件</li>
</ul>
</li>
<li>/tmp<ul>
<li>存放一些临时的文件</li>
</ul>
</li>
<li>/dev <ul>
<li>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</li>
</ul>
</li>
<li>/media(重点)<ul>
<li>Linux系统会自动识别一些设备，例如u盘、光驱等等，识别后Linux会把识别的设备挂载到这个目录下。</li>
</ul>
</li>
<li>/mnt(重点)<ul>
<li>系统提供的该目录是为了让用户临时挂载别的文件系统的，我们可以将外部存储挂载在/mnt上，然后进入该目录就可以查看里的内容。    </li>
</ul>
</li>
<li>/opt<ul>
<li>这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可以放在该目录下。默认为空</li>
</ul>
</li>
<li>/usr/local(重点)<ul>
<li>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</li>
</ul>
</li>
<li>/var(重点)<ul>
<li>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放栈这个目录下。包括各种日志文件。</li>
</ul>
</li>
<li>/selinux[security-enhanced linux]<ul>
<li>SELinux是一种安全子系统，它能控制程序只能访问特定文件。  </li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>Linux的目录中又且只有一个根目录 /</li>
<li>Linux的各个目录存放的内容是规划好的不要乱放文件。</li>
<li>Linux是以文件的形式管理我们的设备的，因此在Linux世界里一切皆为文件。</li>
<li>各个文件目录下存放什么内容，都要知道！</li>
<li>学完之后应该有一棵Linux的目录树。</li>
</ol>
<p>#Linux 实操</p>
<h2 id="为什么要远程登录Linux呢"><a href="#为什么要远程登录Linux呢" class="headerlink" title="为什么要远程登录Linux呢"></a>为什么要远程登录Linux呢</h2><p>说明：公司开发的时候，具体的情况是这样的</p>
<ol>
<li>Linux服务器是开发小组共享的。</li>
<li>正式上线的项目是运行在公网的</li>
<li>程序员需要远程登陆到centos进行项目开发和管理</li>
<li>远程登录的客户端又Xshell 5，XFtp5，其他工具大同小异</li>
</ol>
<h2 id="Linux-Xshell-5"><a href="#Linux-Xshell-5" class="headerlink" title="Linux-Xshell 5"></a>Linux-Xshell 5</h2><p>说明: Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完 美解决了中文乱码的问题， 是目前程序员首选的软件。</p>
<p>Xshell [1] 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。</p>
<p>Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好<br>的达到远程控制终端的目的。</p>
<p><img src="https://i.loli.net/2021/01/17/AG1jmi53Zc9lwWt.png" alt="1610715401(1).jpg"></p>
<h3 id="Vi-和-Vim"><a href="#Vi-和-Vim" class="headerlink" title="Vi 和 Vim"></a>Vi 和 Vim</h3><p>所有的Linux系统都会内建vi文本编辑器</p>
<p>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别 语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别 丰富，在程序员中被广泛使用。</p>
<h3 id="三种常见模式"><a href="#三种常见模式" class="headerlink" title="三种常见模式"></a>三种常见模式</h3><p><strong>正常模式:</strong><br>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用<br>『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，<br>也可以使用『复制、贴上』来处理你的文件数据。</p>
<p><strong>插入模式:</strong><br>按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可.</p>
<p><strong>命令行模式</strong><br>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的 动作则是在此模式中达成的！</p>
<p><strong>三种模式的转换图</strong><br><img src="https://i.loli.net/2021/01/17/5WlXG72fnLiMxDH.png" alt="1610858825(1).jpg"></p>
<h3 id="vi-以及-vim常用快捷键"><a href="#vi-以及-vim常用快捷键" class="headerlink" title="vi 以及 vim常用快捷键"></a>vi 以及 vim常用快捷键</h3><p><strong>练习</strong></br><br>1)拷贝当前行 yy , 拷贝当前行向下的5行 5yy，并粘贴。</br><br>2) 删除当前行 dd  , 删除当前行向下的5行 5dd</br><br>3) 在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]</br></p>
<p>4) 设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]</br><br>5) 编辑 /etc/profile 文件，使用快捷键到底文档的最末行”G”和最首行”gg”</br></p>
<blockquote>
<p>或者点三次”[[[“回到顶部   “]]]”回到底部</p>
</blockquote>
<p>6) 在一个文件中输入 “hello” ,然后又撤销这个动作 u</br><br>7) 编辑 /etc/profile 文件，并将光标移动到 20行 shift+g</br><br><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt=""></p>
<h3 id="开机、重启、用户登录注销"><a href="#开机、重启、用户登录注销" class="headerlink" title="开机、重启、用户登录注销"></a>开机、重启、用户登录注销</h3><p><strong>基本介绍</strong></p>
<ol>
<li>shutdown:<ul>
<li>shutdown -h now:表示立即关机</li>
<li>shutdown -h 1 :表示一分钟后还击</li>
<li>shutdown -r now：立即重启</li>
</ul>
</li>
<li>halt:<ul>
<li>直接使用，等效于关机</li>
</ul>
</li>
<li>reboot:<ul>
<li>就是重启系统</li>
</ul>
</li>
<li>sync:<ul>
<li>把内存的数据同步到磁盘</li>
</ul>
</li>
</ol>
<p><strong>注意细节</strong></p>
<blockquote>
<p>当我们关机或重启时候，都应该先执行一下sync指令，把内存数据写入磁盘，防止数据丢失</p>
</blockquote>
<h3 id="用户的登录与注销"><a href="#用户的登录与注销" class="headerlink" title="用户的登录与注销"></a><strong>用户的登录与注销</strong></h3><p><strong>基本介绍</strong></p>
<ol>
<li>logout<ul>
<li>直接退出当前的连接</li>
</ul>
</li>
</ol>
<p><strong>注意细节</strong></p>
<blockquote>
<p>logout注销指令在图形运行级别无效，在运行级别3下有效。</p>
</blockquote>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>Linux的用户需要至少属于一个组。</p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a><strong>添加用户</strong></h3><p>基本语法</p>
<p><code>useradd[选项] 用户名</code></p>
<p><strong>案例</strong></p>
<p>添加一个用户xm.<br><img src="https://i.loli.net/2021/01/17/GSyJmC4ok3geHRB.png" alt="1610883707_1_.jpg"></p>
<blockquote>
<p>会产生/home/xm  也就是说在根目录下的home目录会出现一个xm</p>
</blockquote>
<p><strong>细节说明</strong></p>
<ol>
<li>当创建用户成功后，会自动的创建和用户同名的家目录。</li>
<li>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录</li>
</ol>
<h3 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a><strong>指定/修改密码</strong></h3><p>基本语法</br><br>passwd 用户名</br><br><strong>应用案例</strong></br><br>1). 给xiaoming指定密码</p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><strong>删除用户</strong></h3><p>基本语法</br><br>userdel 用户名(删除用户)<br>userdel -r 用户名(把家目录一起删)</p>
<p>1）删除用户xiaoming，但是要保留家目录<br>2）删除用户以及用户主目录</p>
<blockquote>
<p>在实际开发中，一般不会把家目录删除，因为有可能有重要的数据</p>
</blockquote>
<p>###<strong>查询用户信息</strong><br>id 用户名</br></p>
<p><strong>应用实例</strong></br><br>查看root的信息</p>
<p><img src="https://i.loli.net/2021/01/19/xls7qgRSTOWEnhM.png" alt="1611036257_1_.png"></p>
<blockquote>
<p>uid-&gt;用户id号  gid-&gt;用户所在组的id号 组-&gt; 所在组的名称<br>用户不存在则会弹出无此用户</p>
</blockquote>
<p>###<strong>切换用户</strong></p>
<blockquote>
<p>如果用户的权限不够则可以通过切换用户来操作系统以获得权限。</p>
</blockquote>
<p><strong>语法</strong><br>su 切换用户名  </p>
<p>如果切换了用户但是想回到之前的用户</p>
<p>exit即可回到</p>
<blockquote>
<p>ps. 当一个用户从高权限用户到低权限用户时，不用输入密码</p>
</blockquote>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p><strong>介绍</strong></br><br>类似于角色，系统可以对有共性的多个用户进行统一的管理。</br><br><strong>新增组</strong></br></p>
<p>groupadd 组名</p>
<p><strong>删除组</strong></p>
<p>groupdel 组名</p>
<p><strong>增加用户时直接加上组</strong></p>
<p>useradd -g 用户组 用户名</p>
<p><a href="https://imgchr.com/i/s2OMYF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/19/s2OMYF.png" alt="s2OMYF.png"></a></p>
<p><strong>修改用户的组</strong></p>
<p>usermod -g 用户组 用户名</p>
<h3 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h3><p><strong>修改用户的组</strong></p>
<p><strong>/etc/passwd 文件</strong></br><br>用户(user)的配置文件，记录用户的各种信息</br></p>
<p>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p>
<p><strong>/etc/shadow 文件</strong></br><br>口令的配置文件</br></p>
<p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
<p><strong>/etc/group 文件</strong></br><br>组(group)的配置文件，记录Linux包含的组的信息</br></p>
<p>每行含义：组名：口令：组标识符：组内用户列表</p>
<blockquote>
<p>一般组内用户列表看不见。</br><br>ps.如果创建了组vim之后看不见，一直点enter，因为vim是不完全显示</p>
</blockquote>
<h1 id="Linux实操-实用指令"><a href="#Linux实操-实用指令" class="headerlink" title="Linux实操 实用指令"></a>Linux实操 实用指令</h1><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p><strong>基本介绍</strong></p>
<ol>
<li>0：关机 </li>
<li>1：单用户(找回丢失密码)</li>
<li>2：多用户无网络服务</li>
<li>3：多用户有网洛服务</li>
<li>4：待定</li>
<li>5：图形界面</li>
<li>6：重启</li>
</ol>
<p>常用的运行级别是 3和5，要修改默认的运行级别可改文件<br><code>/etc/inittab</code>的id:5:initdefault:这一行中的数字</p>
<p>命令：init[012356]</p>
<blockquote>
<p>OS7中用systemctl代替了/etc/init </p>
</blockquote>
<p><strong>运行级别的示意图</strong><br><a href="https://imgchr.com/i/s2Otw6" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/19/s2Otw6.png" alt="s2Otw6.png"></a></p>
<h3 id="切换到指定运行级别的指令"><a href="#切换到指定运行级别的指令" class="headerlink" title="切换到指定运行级别的指令"></a>切换到指定运行级别的指令</h3><p><code>systemctl get-default</code> 获取默认的运行级别<br><code>systemctl set-default TARGET.target</code> 设置默认的运行级别</p>
<p><a href="https://imgchr.com/i/s2OmwV" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/19/s2OmwV.md.png" alt="s2OmwV.md.png"></a></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>如何找回root密码，如果不小心忘记了root密码，如何找回。</p>
<p>思路：进入到单用户模式，然后修改root密码。因为单用户模式下，root模式不用密码</p>
<p>Centos7 进入单用户模式</p>
<p>当我们设置用户密码时，有可能会忘记，这时如何登陆呢，单用户模式就可以</p>
<p>首先我们进入开机界面，按e进行选择</p>
<p><img src="https://img-blog.csdnimg.cn/20181128175655385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>会进入以下界面，</p>
<p><img src="https://img-blog.csdnimg.cn/20200509153856534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>然后找到图中红线标注的该行，在行尾添加 init=/bin/sh 并将对应的ro权限改为rw权限。（这个原文并没有写，原文他的操作系统和我们的并不一样，但基本上都是标明了ro权限的）</p>
<p><img src="https://img-blog.csdnimg.cn/20200509154024138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>按住Ctrl+x执行</p>
<p>可以进入单用户模式</p>
<p><img src="https://img-blog.csdnimg.cn/20181128175655419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>如图所示，我们还可以修改密码，默认修改root密码，也可以修改其他用户的密码passwd junjind</p>
<p>执行exec  /sbin/init 即可退出单用户模式</p>
<p><img src="https://img-blog.csdnimg.cn/20200509155218201.png" alt=""></p>
<blockquote>
<p>这个操作只能在Linux所在的那台电脑上操作，因此，你都有权限进入机房了，那肯定有权限改密码呀，因此不用担心别人随随便便改你密码</p>
</blockquote>
<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><p><strong>介绍</strong></p>
<p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p>
<p><strong>man 获得帮助信息</strong></p>
<ul>
<li>基本语法 <ul>
<li><code>man[命令或配置文件](功能描述，获得帮助信息)</code></li>
</ul>
</li>
</ul>
<p><strong>help 指令</strong></p>
<ul>
<li>基本语法<ul>
<li><code>help命令(功能描述，获得shell内置命令的帮助信息)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>说实话百度更有用</p>
</blockquote>
<h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><h3 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h3><ul>
<li>基本语法<ul>
<li>pwd (功能描述：显示当前工作目录的绝对路径)</li>
</ul>
</li>
</ul>
<h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><ul>
<li>基本语法<ul>
<li>ls[选项] [目录或是文件]</li>
</ul>
</li>
<li>常用选项<ul>
<li>-a:显示当前目录所有信息，包括隐藏的</li>
<li>-l:以列表的形式显示信息</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/sWjxwn" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/20/sWjxwn.png" alt="sWjxwn.png"></a></p>
<blockquote>
<p>ls -la 或者 ls -al 一样的</p>
</blockquote>
<h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h3><ul>
<li>基本语法<ul>
<li>cd [参数]（切换到指定目录）</li>
</ul>
</li>
<li>常用参数<ul>
<li>绝对路径和相对路径</li>
<li>cd ~或cd：回到自己的家目录</li>
<li>cd ..回到当前目录的上一级目录</li>
</ul>
</li>
</ul>
<h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h3><blockquote>
<p>mkdir指令用于创建目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>mkdir[选项] 要创建的目录</li>
</ul>
</li>
<li>常用选项<ul>
<li>-p：创建多级目录<blockquote>
<p>不带-p则只能创建一级目录</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h3><blockquote>
<p>rmdir 指令删除空目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>rmdir [选项] 要删除的空目录</li>
</ul>
</li>
</ul>
<p>注意细节：<br>    rmdir删除的是空目录，如果目录下有内容时无法删除的。</p>
<blockquote>
<p>ps如果需要删除非空目录，需要使用 rm -rf要删除的目录</p>
</blockquote>
<h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><blockquote>
<p>touch指令创建空文件</p>
</blockquote>
<ul>
<li>基本语法 <ul>
<li>touch 文件名称<blockquote>
<p>可以一次性创建多个文件，用空格隔开即可。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="cp指令-重要噢"><a href="#cp指令-重要噢" class="headerlink" title="cp指令[重要噢]"></a>cp指令[重要噢]</h3><blockquote>
<p>cp指令拷贝文件到指定目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>cp [选项] source dest</li>
</ul>
</li>
<li>常用选项<ul>
<li>-r：递归复制整个文件夹</li>
</ul>
</li>
</ul>
<p><img src="https://s3.ax1x.com/2021/01/20/sfQK4P.png" alt=""></p>
<blockquote>
<p>如果发现了目标目录下有此文件了可以通过<code>\cp -r</code> 强制覆盖</p>
</blockquote>
<h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><blockquote>
<p>rm指令移除文件或目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>rm [选项] 要删除的文件或目录</li>
</ul>
</li>
<li>常用选项<ul>
<li>-r:递归删除整个文件夹</li>
<li>-f:强制删除不提示 </li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/s43YE4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/21/s43YE4.png" alt="s43YE4.png"></a></p>
<h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><blockquote>
<p>mv移动文件与目录或重命名</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>mv oldNameFile newNameFile （重命名）</li>
<li>mv /temp/movefile /targetFolder（移动文件）</li>
</ul>
</li>
</ul>
<h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><blockquote>
<p>cat查看文件内容，是以只读的方式打开。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>cat [选项] 要查看的文件</li>
</ul>
</li>
<li>常用选项    <ul>
<li>-n:显示行号</li>
</ul>
</li>
</ul>
<p><strong>使用细节</strong><br>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 | more</p>
<p><code>cat ... | more</code> </p>
<h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h3><blockquote>
<p>more指令是一个基于vi编辑器的文本过滤器，他以全屏幕的方式按页显示文本文件的内容，more指令中内置了若干快捷键，详见操作说明。</p>
</blockquote>
<ul>
<li><p>基本语法</p>
<ul>
<li>more 要查看的文件</li>
</ul>
<p><a href="https://imgchr.com/i/s4N8Dx" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/21/s4N8Dx.png" alt="s4N8Dx.png"></a></p>
</li>
</ul>
<h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h3><blockquote>
<p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，<strong>并不是一次将整个文件加载之后再显示</strong>，而是根据显示的需要加载内容，<strong>对于显示大型文件具有较高的效率</strong></p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>less 要查看的文件</li>
</ul>
</li>
</ul>
<p>即懒加载。</p>
<h3 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和 &gt;&gt;指令"></a>&gt;指令和 &gt;&gt;指令</h3><blockquote>
<p>>输出重定向和 >> 追加</p>
<p>> 输出重定向：会将原来的文件的内容覆盖</p>
<p> >>追加：不会覆盖原来文件的内容，而是追加的文件的尾部。
</blockquote>
<ul>
<li>基本语法<ul>
<li>ls -l&gt;文件（列表的内容写入文件a.txt中(覆盖写)）</li>
<li>ls -al&gt;&gt;文件 (列表的内容追加到文件aa.txt的末尾)</li>
<li>cat 文件1 &gt; 文件2(将文件1的内容覆盖到文件2)</li>
<li>echo “内容”&gt;&gt;文件</li>
</ul>
</li>
</ul>
<h3 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h3><blockquote>
<p>echo输出内容到控制台。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>echo [选项] [输出内容]</li>
</ul>
</li>
<li>应用<ul>
<li>使用echo指令输出环境变量，输出当前的环境路径。<ul>
<li><code>echo $PATH</code></li>
</ul>
</li>
<li>使用echo输出hello,world!<ul>
<li><code>echo hello,world!</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h3><blockquote>
<p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>head 文件(查看文件的头10行内容)</li>
<li>head -n x 文件(查看文件头x行内容)</li>
</ul>
</li>
</ul>
<h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h3><blockquote>
<p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>tail 文件(查看后10行内容)</li>
<li>tail -n x 文件(查看后x行内容)</li>
<li>tail -f 文件(追踪该文档的所有更新)</li>
</ul>
</li>
</ul>
<h3 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h3><blockquote>
<p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p>
</blockquote>
<ul>
<li><p>基本语法 </p>
<ul>
<li>ln -s[源文件或目录] [软链接名]</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>在/home目录下创建一个软链接linkToRoot，连接到/root目录，并删除。</li>
</ul>
</li>
</ul>
<p><strong>创建</strong><br><a href="https://imgchr.com/i/sTo8je" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sTo8je.png" alt="sTo8je.png"></a></p>
<p><strong>删除</strong><br><a href="https://imgchr.com/i/sTod4P" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sTod4P.png" alt="sTod4P.png"></a></p>
<h3 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h3><blockquote>
<p>查看已经执行过历史命令，可以执行历史指令</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>history (查看了以前执行过的指令)</li>
<li>history 10 (查看后10个)</li>
</ul>
</li>
</ul>
<p>小技巧:用!加指令行数可以执行历史编号为那行的指令<br><a href="https://imgchr.com/i/sTT6xO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sTT6xO.png" alt="sTT6xO.png"></a></p>
<p>##时间日期类</p>
<h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h3><ul>
<li>基本语法<ul>
<li>date (显示当前时间)</li>
<li>date+%Y (显示当前年)</li>
<li>date+%m (显示当前月)</li>
<li>date+%d (显示当前日)</li>
<li>date -s 字符串时间 (设置日期)</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/sT70Og" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sT70Og.png" alt="sT70Og.png"></a></p>
<blockquote>
<p>注意那个＋号，那是格式必须的，%Y与%m之间的间隔符随意写都可%Y %m和%Y–%m都可以运行的</p>
</blockquote>
<h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><blockquote>
<p>查看日历指令</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>cal [选项] (不加选线，显示本月日历)</li>
<li>cal 年份 (显示一整年的日历)</li>
</ul>
</li>
</ul>
<h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><blockquote>
<p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>find [搜索范围] [选项]</li>
</ul>
</li>
<li>选项说明<br><a href="https://imgchr.com/i/s72kYF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/s72kYF.png" alt="s72kYF.png"></a></li>
</ul>
<blockquote>
<p>查找linux系统下大于20m的文件(+n大于 -n小于 n等于) </br><br><code>find / -size +20M</code></br><br>M要大写噢！</p>
</blockquote>
<p><strong>例子找/root目录下的.txt文件</strong></p>
<p><a href="https://imgchr.com/i/s7hVN6" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/s7hVN6.png" alt="s7hVN6.png"></a></p>
<blockquote>
<p>ps在用通识符的时候要用转义字符。</br><br><code>\*</code> 或 <code>&quot;*&quot;</code> 或 <code>&#39;*&#39;</code></p>
</blockquote>
<h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h3><blockquote>
<p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件，locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>locate 搜索文件</li>
</ul>
</li>
<li>特别说明<blockquote>
<p>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。</p>
</blockquote>
</li>
</ul>
<p>###grep指令和管道符号 | </p>
<blockquote>
<p>grep过滤查找，管道符，”|”，标识将前一个命令的处理结果输出传递给后面的命令处理。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>grep[选项] 查找内容 源文件</li>
</ul>
</li>
<li>常用的选项<ul>
<li>-n 显示匹配行及行号</li>
<li>-i 忽略字母大小写  </li>
</ul>
</li>
</ul>
<h2 id="压缩和解压缩类"><a href="#压缩和解压缩类" class="headerlink" title="压缩和解压缩类"></a>压缩和解压缩类</h2><h3 id="gzip-gunzip-指令"><a href="#gzip-gunzip-指令" class="headerlink" title="gzip / gunzip 指令"></a>gzip / gunzip 指令</h3><blockquote>
<p></br>gzip是压缩文件 gunzip是解压缩文件</p>
</blockquote>
<ul>
<li>gizp 文件(压缩文件)</li>
<li>gunizp 文件(解压缩文件)</li>
</ul>
<h3 id="zip-unzip-指令"><a href="#zip-unzip-指令" class="headerlink" title="zip/unzip 指令"></a>zip/unzip 指令</h3><blockquote>
<p>zip用于压缩文件，unzip用于解压文件，这个在项目的打包发布中很有用</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>zip [选项] XXX.zip 将要压缩的内容</li>
<li>unzip [选项] XXX.zip </li>
</ul>
</li>
<li>zip常用选项<ul>
<li>r：递归压缩，即压缩目录</li>
</ul>
</li>
<li>unzip的常用选项<ul>
<li>d&lt;目录&gt; :指定解压文件的存放目录    </li>
</ul>
</li>
</ul>
<h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><blockquote>
<p>tar 指令是打包指令，最后打包后的文件是.tar.gz的文件</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>tar [选项] XXX.tar.gz 打包的内容(功能描述：打包目录，压缩后的文件格式.tar.gz)</li>
</ul>
</li>
<li>选项说明<hr>
[![s7HRFs.png](https://s3.ax1x.com/2021/01/23/s7HRFs.png)](https://imgchr.com/i/s7HRFs)

</li>
</ul>
<p>在/root目录下打包aa.txt和a.txt 并保存<br><a href="https://imgchr.com/i/s7bFkd" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/s7bFkd.png" alt="s7bFkd.png"></a></p>
<blockquote>
<p>注意的点：打包是选项参数是 -zcvf<br></br>解包是 -zxvf</p>
</blockquote>
<p>##组管理和权限管理<br><strong>文件/目录所有者</strong></p>
<blockquote>
<p>一般为文件的创建者，谁创建了该文件，就自然的成为了该文件的所有者。</p>
</blockquote>
<h3 id="查看文件所有者"><a href="#查看文件所有者" class="headerlink" title="查看文件所有者"></a>查看文件所有者</h3><ul>
<li>指令：ls -ahl</li>
<li>实例：创建一个组police，再创建一个用户tom，将tom放在police组，然后使用tom来创建一个文件ok.txt,看看情况如何。</li>
</ul>
<p><a href="https://imgchr.com/i/sbdCnS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/24/sbdCnS.png" alt="sbdCnS.png"></a></p>
<p><a href="https://imgchr.com/i/sbdQ74" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/24/sbdQ74.png" alt="sbdQ74.png"></a></p>
<blockquote>
<p>先通过groupadd 加了一个police 再通过useradd加了一个tom用户 通过XShell登录tom用户创建了一个ok.txt文件。</p>
</blockquote>
<h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><ul>
<li>基本语法<ul>
<li>chown (change owner) 用户名 文件名</li>
<li>chown newowner:newgroup file 改变用户的所有者和所有组</li>
<li>-R 如果是目录则使其下所有子文件或目录递归生效</li>
</ul>
</li>
</ul>
<h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><ul>
<li>基本指令<ul>
<li>groupadd 组名</li>
</ul>
</li>
</ul>
<h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><ul>
<li>基本指令<ul>
<li>chgrp 组名 文件名</li>
</ul>
</li>
</ul>
<h2 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h2><p><a href="https://imgchr.com/i/sbscgs" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/24/sbscgs.png" alt="sbscgs.png"></a></p>
<ol>
<li>代表着文件的类型：-普通文件 d:目录 l:软链接 c:字符设备[键盘，鼠标] b:快文件，硬盘。</li>
<li>表示文件所有者的权限为rw</li>
<li>代表着文件所在组的用户的权限，r–只有读权限。</li>
<li>代表文件其他组的用户的权限，r–只有读权限。</li>
<li>接着后面的 <code>1</code>代表着如果是文件就代表着硬链接  如果是目录，代表着子目录的个数</li>
</ol>
<h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><p><strong>rwx作用到文件</strong></p>
<ol>
<li>[r]代表可读(read):可以读取，查看</li>
<li>[w]代表可写(write)：可以修改，但是不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写的权限，才能删除该文件</li>
<li>[x]代表可执行(execute)：可以被执行</li>
</ol>
<p><strong>rwx作用到目录</strong></p>
<ol>
<li>[r]代表可读(read):可以读取，ls查看目录内容</li>
<li>[w]代表可写(write):可以修改，目录内创建+删除+重命名目录</li>
<li>[x]代表可执行(execute):可以进入该目录</li>
</ol>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><ul>
<li>基本命令<ul>
<li>u:所有者 g:所有组 o:其他人 a:所有人(o u g的总和) </li>
<li>chmod u=rwx，g=rx,o=x 文件目录名</li>
<li>chmod o+w 文件目录名</li>
<li>chmod a-x 文件目录名</li>
</ul>
</li>
</ul>
<h3 id="最佳实践-警察和土匪游戏"><a href="#最佳实践-警察和土匪游戏" class="headerlink" title="最佳实践-警察和土匪游戏"></a>最佳实践-警察和土匪游戏</h3><p>police,bandit两个组</p>
<p>jack,jeery：警察<br>xh，xq:土匪</p>
<ol>
<li>创建组</li>
<li>创建用户</li>
<li>jack 创建一个文件，自己可以读写，本组人可以读写，其他人没有任何权限</li>
<li>jack修改该文件，让其他组人可以读，本组人可以读写</li>
<li>xh 投靠警察，看看是否可以读写</li>
</ol>
<h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><h3 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h3><blockquote>
<p>crotab进行定时任务的设置。</br><br>任务调度：是指系统在某个实践执行的特定的命令或程序。</br><br>任务调度分类:</br>1.系统工作，有些重要的工作必须周而复始地运行，如病毒扫描等。</br><br>2.个别用户工作，个别用户可能希望执行某些程序，比如对mysql数据库的备份</p>
</blockquote>
<ul>
<li><p>基本语法</p>
<ul>
<li>crontab [选项]</li>
</ul>
</li>
<li><p>常用选项<br><a href="https://imgchr.com/i/sOKie1" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOKie1.png" alt="sOKie1.png"></a></p>
</li>
<li><p>快速入门</p>
</li>
</ul>
<p>设置任务调度文件：/etc/crontab 设置个人任务调度。执行crontab –e命令。 接着输入任务到调度文件<br>如：*/1 * * * * ls –l  /etc/ &gt; /tmp/to.txt<br>意思说每小时的每分钟执行ls –l /etc/ &gt; /tmp/to.txt命令</p>
<p>##<strong>参数细节说明</strong></p>
<ul>
<li>5个占位符的说明</li>
</ul>
<p><a href="https://imgchr.com/i/sOKq6H" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOKq6H.png" alt="sOKq6H.png"></a></p>
<ul>
<li>特殊符号说明</li>
</ul>
<p><a href="https://imgchr.com/i/sOMC9S" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOMC9S.png" alt="sOMC9S.png"></a></p>
<ul>
<li>特定时间执行任务案例</li>
</ul>
<p><a href="https://imgchr.com/i/sOMnhT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOMnhT.png" alt="sOMnhT.png"></a></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol>
<li>案例1：每隔1分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中 <ul>
<li><ol>
<li><code>vim mytask1.sh</code>并在里面输入<code>date &gt;&gt; /home/mydate</code></li>
</ol>
</li>
<li><ol start="2">
<li>给sh文件执行权限<code>chmod 744 mytask1.sh</code></li>
</ol>
</li>
<li><ol start="3">
<li>使用crontab定时调用<code>crontab -e</code>进入定时进程接着<code>*/1 * * * * /home/mydate</code></li>
</ol>
</li>
<li><ol start="4">
<li>一分钟后即可</li>
</ol>
</li>
</ul>
</li>
<li>案例2：每隔1分钟， 将当前日期和日历都追加到 /home/mycal 文件中 <ul>
<li><ol>
<li><code>vim mytask2.sh</code>并在里面输入<code>date &gt;&gt; /tmp/mycal</code>和<code>cal &gt;&gt; /tmp/mycal</code></li>
</ol>
</li>
<li><ol start="2">
<li>给sh文件执行权限<code>chmod 744 mytask2.sh</code></li>
</ol>
</li>
<li><ol start="3">
<li>使用crontab定时调用<code>crontab -e</code>进入定时进程接着<code>*/1 * * * * /tmp/mycal</code></li>
</ol>
</li>
<li><ol start="4">
<li>一分钟后即可</li>
</ol>
</li>
</ul>
</li>
<li>案例3:    每天凌晨2:00 将mysql数据库 testdb ，备份到文件中。</li>
</ol>
<h2 id="Linux磁盘分区和挂载"><a href="#Linux磁盘分区和挂载" class="headerlink" title="Linux磁盘分区和挂载"></a>Linux磁盘分区和挂载</h2><h3 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h3><p><strong>1) mbr分区:</strong></p>
<ol>
<li>最多支持四个主分区 </li>
<li>系统只能安装在主分区 </li>
<li>扩展分区要占一个主分区</li>
<li>MBR最大只支持2TB，但拥有最好的兼容性</li>
</ol>
<p><strong>2) gtp分区:</strong></p>
<ol>
<li>支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区）</li>
<li>最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）</li>
<li>windows7 64位以后支持gtp</li>
</ol>
<h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a><strong>Linux分区</strong></h3><p><strong>原理介绍</strong></p>
<ol>
<li><p>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独 立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</p>
</li>
<li><p>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目 录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一 个目录下获得。</p>
</li>
</ol>
<p><strong>硬盘说明</strong></p>
<ol>
<li><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p>
</li>
<li><p>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属 盘）,“</del>”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就 是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为 第二个IDE硬盘上的第二个主分区或扩展分区。</p>
</li>
<li><p>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余 则和IDE硬盘的表示方法一样。</p>
</li>
</ol>
<p>###查看所有设备挂载情况</p>
<ul>
<li>基本命令<ul>
<li>lsblk 或者 lsblk -f</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/sONxfA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sONxfA.png" alt="sONxfA.png"></a></p>
<blockquote>
<p>详情如下</p>
</blockquote>
<p><a href="https://imgchr.com/i/sOUEkQ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOUEkQ.png" alt="sOUEkQ.png"></a></p>
<h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><blockquote>
<p>增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p>
</blockquote>
<ul>
<li><p>步骤</p>
<ul>
<li><ol>
<li>虚拟机添加硬盘</br><br>在VM点设置虚拟机添加磁盘然后下一步下一步即可</li>
</ol>
</li>
<li><ol start="2">
<li>分区 <code>fdisk/dev/sdb</code></li>
</ol>
</li>
</ul>
<p><a href="https://imgchr.com/i/sjxz80" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sjxz80.png" alt="sjxz80.png"></a></p>
</li>
</ul>
<p><a href="https://imgchr.com/i/sjzcR0" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sjzcR0.png" alt="sjzcR0.png"></a><br>    - 3. 格式化 <code>mkfs -t ext4 /dev/sdb1</code></p>
<p><a href="https://imgchr.com/i/svSaf1" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/svSaf1.png" alt="svSaf1.png"></a><br>    - 4. 挂载 先创建一个目录 <code>mount /dev/sdb1 /home/newdisk</code><br>    - 5. 设置可以自动挂载(永久挂载，当重启系统后，仍可以挂载到 /home/newdisk)</p>
<p><a href="https://imgchr.com/i/svCvct" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/svCvct.png" alt="svCvct.png"></a></p>
<p><a href="https://imgchr.com/i/svFJ0K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/svFJ0K.png" alt="svFJ0K.png"></a></p>
<h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><h3 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h3><ul>
<li>基本语法<ul>
<li>df -h</li>
</ul>
</li>
</ul>
<h3 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h3><ul>
<li>基本语法<ul>
<li>du -h /目录</li>
</ul>
</li>
</ul>
<p><strong>查询指定目录的磁盘占用情况，默认为当前目录</strong></p>
<ul>
<li>选项  <ul>
<li>-s 指定目录占用大小汇总</li>
<li>-h 带计量单位</li>
<li>-a 含文件</li>
<li>–max-depth=1 子目录深度</li>
<li>-c 列出明细的同时，增加汇总值</li>
</ul>
</li>
</ul>
<h3 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况-工作实用指令"></a>磁盘情况-工作实用指令</h3><ol>
<li><p>统计/home文件夹下文件的个数</p>
<ul>
<li><p><code>ls -l /home | grep &quot;^-&quot; | wc -l</code></p>
<blockquote>
<p><code>&quot;^-&quot;</code>代表筛选即把文件筛选出来 wc是统计</p>
</blockquote>
<p><a href="https://imgchr.com/i/sz0qgS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/27/sz0qgS.png" alt="sz0qgS.png"></a></p>
<blockquote>
<p>grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
</blockquote>
<p><a href="https://imgchr.com/i/szBM8K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/27/szBM8K.png" alt="szBM8K.png"></a></p>
</li>
</ul>
</li>
<li><p>统计/home 下目录的个数</p>
<ul>
<li><code>ls -l /home | grep &quot;^d&quot; | wc -l</code></li>
</ul>
</li>
<li><p>统计/home文件夹下的个数，包括文件夹的子目录的个数</p>
<ul>
<li><code>ls -lR /home | grep &quot;^-&quot; | wc -l</code></li>
</ul>
</li>
<li><p>统计/home文件夹下的个数，包括文件夹的子文件夹的个数</p>
<ul>
<li><code>ls -lR /home | grep &quot;^d&quot; | wc -l</code></li>
</ul>
</li>
<li><p>以树状显示我们的目录</p>
<ul>
<li>tree 目录<blockquote>
<p>如果tree无效则先安装 yum install tree</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="配置指定固定的ip"><a href="#配置指定固定的ip" class="headerlink" title="配置指定固定的ip"></a>配置指定固定的ip</h3><ul>
<li><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code><br><a href="https://imgchr.com/i/szcmUH" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/27/szcmUH.png" alt="szcmUH.png"></a></li>
</ul>
<p><strong>修改后要重启服务</strong></p>
<ul>
<li><code>service network restart</code></li>
</ul>
<h3 id="ifcfg-eth33文件说明"><a href="#ifcfg-eth33文件说明" class="headerlink" title="ifcfg-eth33文件说明"></a>ifcfg-eth33文件说明</h3><p>DEVICE=eth0 <strong>#接口名（设备,网卡）</strong></br><br>HWADDR=00:0C:2x:6x:0x:xx  <strong>#MAC地址</strong></br><br>TYPE=Ethernet    <strong>#网络类型</strong>（通常是Ethemet） UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44  <strong>#随机id</strong></br><br>ONBOOT=yes <strong>系统启动的时候网络接口是否有效（yes/no)</strong></br><br>BOOTPROTO=static <strong>IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</strong></br><br>IPADDR=192.168.184.130 <strong>IP地址</strong></br><br>GATEWAY=192.168.184.2 <strong>网关</strong> </br><br>DNS1=192.168.184.2 <strong>域名解析器</strong></br></p>
<h2 id="进程管理-重点"><a href="#进程管理-重点" class="headerlink" title="进程管理(重点)"></a>进程管理(重点)</h2><h3 id="进程的基本介绍"><a href="#进程的基本介绍" class="headerlink" title="进程的基本介绍"></a>进程的基本介绍</h3><ol>
<li>在Linux中，每个执行的<strong>程序(代码)</strong>都称为一个进程。每个进程都分配一个ID号</li>
<li>每一个进程都会对应一个父进程，而这个父进程可以复制多个子进程，例如www服务器</li>
<li>每个进程都可能以两种形式存在，<strong>前台和后台</strong>。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但是由于屏幕上无法看到的进程，通常使用后台方式执行。</li>
<li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束。</li>
</ol>
<h3 id="查看系统执行的进程"><a href="#查看系统执行的进程" class="headerlink" title="查看系统执行的进程"></a>查看系统执行的进程</h3><ul>
<li>基本语法<ul>
<li>ps -aux</li>
</ul>
</li>
</ul>
<p><strong>ps显示的信息选项：<br></strong></p>
<ol>
<li>PID : 进程识别号</li>
<li>TTY ： 终端机号</li>
<li>TIME ： 此进程所消耗的cpu时间</li>
<li>CMD : 正在执行的命令或进程名</li>
</ol>
<p><strong>2)    指令说明</strong></p>
<ul>
<li>System V展示风格</li>
<li>USER：用户名称</li>
<li>PID：进程号</li>
<li>%CPU：进程占用CPU的百分比</li>
<li>%MEM：进程占用物理内存的百分比</li>
<li>VSZ：进程占用的虚拟内存大小（单位：KB）</li>
<li>RSS：进程占用的物理内存大小（单位：KB）</li>
<li>TT：终端名称,缩写 .</li>
<li>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通<br>优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li>
<li>STARTED：进程的启动时间</li>
<li>TIME：CPU时间，即进程使用CPU的总时间</li>
<li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li>
</ul>
<h3 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h3><ul>
<li><p>基本语法</p>
<ul>
<li>kill [选项] 进程号(通过进程号杀死进程)</li>
<li>killall 进程名称 (通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢的时候有用)</li>
</ul>
</li>
<li><p>常用选项</p>
<ul>
<li>-9 表示强迫进程立即结束</li>
</ul>
</li>
<li><p>案例</p>
<ol>
<li>踢掉某个非法登录用户<br><a href="https://imgchr.com/i/yiTQ5d" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/29/yiTQ5d.png" alt="yiTQ5d.png"></a></li>
<li>终止远程登录服务sshd，在适当的时候再次启动<ul>
<li>ps -aux | grep sshd</li>
<li>kill PID(此PID是要结束的用户的ID)</li>
</ul>
</li>
<li>终止多个gedit编辑器<ul>
<li>killall gedit</li>
</ul>
</li>
<li>强制杀掉一个终端<ul>
<li>kill -9 UID(进程的UID)</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="服务-service-管理"><a href="#服务-service-管理" class="headerlink" title="服务(service)管理"></a>服务(service)管理</h2><blockquote>
<p>介绍：</br><br>service 本质就是进程但是我们运行在后台，通常都会监听某个端口，等待其他程序的请求，比如(mysql,sshd,防火墙等),因此我们又称为守护进程，是Linux中非常重要的知识点。</p>
</blockquote>
<h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><blockquote>
<p>通过chkconfig命令可以给每个服务的各个运行级别设置自启动/关闭</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>chkconfig –list|grep xxx（查看服务）</li>
<li>chkconfig 服务名 –list</li>
<li>chkconfig –level 5 用户名 on/off</li>
</ul>
</li>
</ul>
<blockquote>
<p>CentOS 6适用</p>
</blockquote>
<p>###systemctl list-unit-files</p>
<blockquote>
<p>是上面的指令，在CentOS 7中的实现</p>
</blockquote>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><blockquote>
<p>top与ps指令很相似，它们都用来显示正在执行的进程。Top和ps最大的不同之处，在于top在执行一段时间可以更新正在运行的进程。</p>
</blockquote>
<ul>
<li><p>基本语法</p>
<ul>
<li>top [选项]</li>
</ul>
</li>
<li><p>基本选项</p>
<ul>
<li>-d</li>
<li>-i</li>
<li>-p</li>
</ul>
</li>
<li><p>案例</p>
</li>
</ul>
<ol>
<li>输入top之后输入u，即可查找特定用户的进程状态</li>
<li>输入top之后输入k，再输入特定的ID号即可杀掉该指令</li>
</ol>
<blockquote>
<p>我安装了一个htop，所以使用htop更好</p>
</blockquote>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><ul>
<li><p>基本语法</p>
<ul>
<li>netstat[选项]</li>
</ul>
</li>
<li><p>选项说明</p>
<ul>
<li>-an 按一定顺序排序输出</li>
<li>-p 显示哪一个进程在调用</li>
</ul>
</li>
<li><p>应用案例</p>
<ul>
<li>查看服务名为sshd的服务的信息</li>
</ul>
</li>
</ul>
<h2 id="RPM与YUM包"><a href="#RPM与YUM包" class="headerlink" title="RPM与YUM包"></a>RPM与YUM包</h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><ul>
<li>介绍<blockquote>
<p>一种用于互联网下载包的打包及安装工具，它包含在<strong>某些Linux分发版</strong>中，他声称具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，着一文件格式名称虽然打上了ReaHat的标志，但是理念是通用的</p>
</blockquote>
</li>
</ul>
<p><strong>rpm包的管理</strong></br></p>
<p>rpm包的简单查询指令:查询已安装的rpm列表 rpm -qa|grep xx</p>
<ul>
<li>指令等<ul>
<li>rpm -q 软件名：查询软件包是否安装</li>
<li>rpm -qi 软件包名：查询软件包信息</li>
<li>rpm -ql 软件包名：查询软件包中的文件</li>
<li>rpm -qf 文件全路径名 查询文件所属的软件包</li>
<li>rpm -e 删除</li>
<li>rpm -ivg RPM包全路径名称<ul>
<li>参数说明<ul>
<li>i:install 安装</li>
<li>v:verbose 提示</li>
<li>h:hash 进度条</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="yum包"><a href="#yum包" class="headerlink" title="yum包"></a>yum包</h3><blockquote>
<p>Yum是一个Shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p>
</blockquote>
<p><strong>yum的基本指令</strong></br></p>
<ul>
<li><p>查询yum服务器是否有需要安装的软件</p>
<ul>
<li>yum list|grep xx 软件列表</li>
</ul>
</li>
<li><p>安装指定的yum包</p>
<ul>
<li>yum install xxx 下载安装  </li>
</ul>
</li>
<li><p>查询是否有 firefox的rpm包<br><a href="https://imgchr.com/i/yEHT58" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/31/yEHT58.md.png" alt="yEHT58.md.png"></a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Junit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Junit/" class="post-title-link" itemprop="url">Junit</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-25 17:14:04" itemprop="dateModified" datetime="2020-09-25T17:14:04+08:00">2020-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Junit-单元测试："><a href="#Junit-单元测试：" class="headerlink" title="Junit 单元测试："></a>Junit 单元测试：</h1><ul>
<li><p>测试分类：</p>
<ul>
<li>1.黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</li>
<li>2.白盒测试：需要写代码的。关注程序具体的执行流程。</li>
</ul>
</li>
<li><p>Junit使用：白盒测试</p>
<ul>
<li>步骤：<ul>
<li>1.定义一个测试类(测试用例)<ul>
<li>建议：<ul>
<li>测试类名：被测试的类名Test    CalculatorTest </li>
</ul>
</li>
</ul>
</li>
<li>2.定义测试方法：可以独立运行<ul>
<li>建议：<ul>
<li>方法名：test测试的方法名   testAdd()</li>
<li>返回值：void</li>
<li>参数列表：空参</li>
</ul>
</li>
</ul>
</li>
<li>3.给方法加@Test</li>
<li>4.导入junit依赖环境</li>
</ul>
</li>
<li>判定结果：<ul>
<li>红色：失败</li>
<li>绿色：成功</li>
<li>一般我们会使用断言操作来处理结果Assert.assertEquals(期望的结果,运行的结果);</li>
</ul>
</li>
<li>补充：<ul>
<li>@Before:修饰的方法会在测试方法之前被自动执行</li>
<li>@After:修饰的方法会在测试方法执行之后被自动执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>- 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Java/" class="post-title-link" itemprop="url">Java</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-17 14:58:56" itemprop="dateModified" datetime="2020-06-17T14:58:56+08:00">2020-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-从入门到入土"><a href="#Java-从入门到入土" class="headerlink" title="Java (从入门到入土)"></a>Java (从入门到入土)</h1><p>Java 的固定的书写格式：<code>public static void main(String[] args){...}</code></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>Java虚拟机的内存可以分为三个区域，栈stack、堆heap、方法区method area。<ul>
<li><ol>
<li>栈：栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）</li>
<li>JVM为每个线程创建了一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）</li>
<li>栈属于线程私有，不能实现线程间的共享</li>
<li>栈的储存特性是：先进后出，后进先出</li>
<li>栈是由系统自动分配，速度快！栈是一个连续的内存空间。 </li>
</ol>
<ul>
<li><ol>
<li>堆用于存储创建好的对象和数组（数组也是对象）</li>
<li>JVM只有一个堆，被所有线程共享</li>
<li>堆是一个不连续的内存空间，分配灵活，速度慢。</li>
</ol>
</li>
<li>1.方法区（又叫静态区）特点：JVM只有一个方法区，被所有线程共享！<ol start="2">
<li>方法区实际也是堆，只是用于存储类、常量相关的信息！</li>
<li>用于存放程序中永远是不变的唯一的内容。(类信息[class对象]、静态变量、字符串常量等)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是一种常见解决问题的方法，即把问题逐渐简单化。递归的基本思想就是”自己低矮哦用自己”，一个使用递归技术的方法将会直接或间接的调用自己 .</p>
<ul>
<li>递归体</br><br>例如：输出在a里面调用自己的时候<br>没有递归体和递归头则会陷入死循环</li>
</ul>
<p><code>static int count = 0;</code></p>
<pre><code>static void a() {
    System.out.println(&quot;a&quot;);
    count++;
    if (count &lt; 10) {
        a();
    } else {
        return;
    }</code></pre><blockquote>
<p>if-else 语句可以完美结果问题.</p>
</blockquote>
<p>但是递归体耗时耗力很影响内存，因此能不用递归的地方就不用递归，能用递归一般能用迭代来完成。</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Java作为一种面向对象语言支持</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<ol>
<li>对象：对象是类的一个实例，比如一条狗(python也是拿狗做例子- -)它有状态：颜色、名字、品种；有行为：摇尾巴、吃、叫等。</li>
</ol>
<p>很简单的例子，比如你是个男的，你想要女朋友女朋友就是一个类（class），你可以选很多人比如：石原里美，新垣结衣等等这些就是对象（object）</p>
<p>相比于软件，软件也有状态和行为。软件的对象的状态就是属性，行为通过方法体现。同样的，方法操作对象内部状态的改变，对象的互相调用也是通过方法来完成的。</p>
<ol start="2">
<li>类：类是一个模板，它描述一类对象的行为和状态 看例子：</li>
</ol>
<pre><code>public class Dog{
  String breed;
  int age;
  String color;
  void barking(){
  }

  void hungry(){
  }

  void sleeping(){
  }
}</code></pre><p>一个类可以包含以下类型变量：</p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>
</ul>
<p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。例子：</p>
<pre><code>Public class Puppy{
public Puppy(){
}

public Puppy(String name){
    // 这个构造器仅有一个参数：name
    }
}    </code></pre><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。</p>
<ol>
<li>声明：声明一个对象，包括对象名称和类型。</li>
<li>实例化：使用关键字new来创建一个对象。</li>
<li>初始化：使用new创建对象时，调用构造方法对象</li>
</ol>
<pre><code>public class Puppy{
       public Puppy(String name){
      //这个构造器仅有一个参数：name
      System.out.println(&quot;小狗的名字是 : &quot; + name ); 
   }
   public static void main(String[] args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( &quot;tommy&quot; );
   }
}</code></pre><h4 id="源代码的声明规则："><a href="#源代码的声明规则：" class="headerlink" title="源代码的声明规则："></a>源代码的声明规则：</h4><ol>
<li>一个源代码只能有一个Public类但可以有多个非Public类</li>
<li>源文件名应该与Public类名保持一致。</li>
<li>类如果在一个包内，package语句应该位于首行。</li>
<li>import语句位于package和Public类之间。</li>
<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ol>
<h5 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h5><p>包主要用于对类和接口分类。</p>
<h5 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h5><p>在Java中，如果给出一个完整的限定名，包括包名和类名，则Java编译器就可以很容易的定位源代码或类。</p>
<pre><code>import java.io.*; //从java.io中导入 .* 所有的类</code></pre><h3 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h3><ol>
<li>byte 数据类型是8位，有符号，以二进制补码来表示的整数Min值为-128 Max值为127</li>
<li>short 数据类型16位有符号二进制补码表示的整数 Min：-32768 Max:32767</li>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数 Min：-2^31 Max:2^31-1</li>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数 Min:-2^63 Max:2^63-1 </li>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数</li>
<li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数</li>
<li>boolean 数据类型表示一位的信息 只有True和False两个值</li>
<li>char 类型是一个单一的 16 位 Unicode 字符</li>
</ol>
<h4 id="Java常量"><a href="#Java常量" class="headerlink" title="Java常量"></a>Java常量</h4><p>Java常量用final声明 <code>final double PI = 3.1415926</code></p>
<h3 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h3><ul>
<li>类变量:独立于方法之外的变量，用static修饰</li>
<li>实例变量:独立于方法之外的变量，不过没用static修饰</li>
<li>局部变量:类的方法中的变量</li>
</ul>
<pre><code>public class Variable{
    static int allClicks=0;    // 类变量

    String str=&quot;hello world&quot;;  // 实例变量

    public void method(){

        int i =0;  // 局部变量

    }
}</code></pre><h3 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h3><p>主要分为两类</p>
<ol>
<li>访问修饰符</li>
<li>非访问修饰符<br>修饰符用来定义类、方法或变量，通常放在语句的最前端。例如</li>
</ol>
<pre><code>public class ClassName {
       // ...
}
private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;
public static void main(String[] arguments) {
   // 方法体
}</code></pre><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li>default(默认，啥都不写)：同一包内可见，不使用任何修饰符。</li>
<li>private：在同一类内可见。使用对象：变量、方法。注意：不能修饰类(外部类)</li>
<li>public：对所有类可见，使用对象：类、接口、变量、方法</li>
<li>protect：对同一包内的类和所有子类可见。使用对象：变量、方法。注意不能修饰类（外部类）</li>
</ul>
<p><strong>private</strong></br><br>私有访问修饰符是最严格的访问级别，所有被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为<br>private。</br><br>声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。</br><br>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据例子：</p>
<pre><code>public class Logger{
    private String format;
    public String getFormat(){
        return format;
    }
    public void setFormat(String format){
        this.format=format;
    }
}</code></pre><p>实例中Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类可以访问private定义的变量，我们构造了两个public的方法来获取<code>getFormat()</code>和设置format<code>setFormat(String)</code>的值.</p>
<p><strong>public</strong></br><br>被声明为public的类，方法，构造方法和接口可以被其他类访问。其中类的所有公有方法和变量都能被子类继承。</p>
<p><strong>protected</strong></br><br>protected需要从以下两个点来分析说明：</p>
<ul>
<li>子类和基类在同一包内:被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li>子类与基类不在同一个包内：那么子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li>
</ul>
<blockquote>
<p>在面向对象设计中，被定义为包含所有实体共性的class类型，被称为“基类”。</p>
</blockquote>
<p>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类(内部类除外).</br><br>接口及接口的成员变量和成员方法不能声明为 protected。<br><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif" alt=""></p>
<blockquote>
<p>以我的理解，应该是包内所有类可访问，但包外的子类继承之后才能用。</p>
</blockquote>
<h4 id="需要注意的继承规则"><a href="#需要注意的继承规则" class="headerlink" title="需要注意的继承规则"></a>需要注意的继承规则</h4><ul>
<li>父类中声明为public的方法在子类中也必须要是public</li>
<li>父类中声明为protected的方法在子类中要么声明为protected要么声明为private。</li>
<li>父类中声明为private的方法，不能被继承。</li>
</ul>
<h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><ol>
<li>static修饰符，用来修饰类方法和类变量</li>
<li>final 修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li>
<li>abstract修饰符，用来创建抽象类和抽象方法。</li>
<li>synchronized和volatile修饰符，主要用于线程的编程。</li>
</ol>
<h3 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h3><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><pre><code>`String greeting = &quot;zwz&quot;;`</code></pre><p>在遇到字符串常量时，这里的值是”zwz”，编译器会使用该值创建一个String对象。与其他对象一样，可以使用关键字的构造方法来创建String对象。例如</p>
<pre><code>public class StringDemo{
   public static void main(String args[]){
      char[] helloArray = { &apos;r&apos;, &apos;u&apos;, &apos;n&apos;, &apos;o&apos;, &apos;o&apos;, &apos;b&apos;};
      String helloString = new String(helloArray);  
      System.out.println( helloString );
   }
}</code></pre><p>编译结果是 <code>runoob</code></p>
<blockquote>
<p>注意String类是用final修饰的，所以不可以修改，一旦创建了String对象，那他的值就无法改变了</p>
</blockquote>
<h4 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h4><p>如果想对值进行修改，那么需要用这俩类。</p>
<p>与String类不同的是，StringBuffer 和 StringBuilder类的对象能够被多次修改，并且不产生新的未被使用的对象。</p>
<p>StringBuilder与StringBuffer之间最大的区别就说前者不是线程安全的(不能同步访问)<br>但是前者的速度比后者大，所以多数情况用前者类。但是在要求线程安全的情况下，必须使用后者类。小栗子：</p>
<pre><code>public class Test{
  public static void main(String args[]){
    StringBuffer sBuffer = new StringBuffer(&quot;菜鸟教程官网：&quot;);
    sBuffer.append(&quot;www&quot;);
    sBuffer.append(&quot;.runoob&quot;);
    sBuffer.append(&quot;.com&quot;);
    System.out.println(sBuffer);  
  }
}</code></pre><h5 id="常用的用法-和python很像"><a href="#常用的用法-和python很像" class="headerlink" title="常用的用法(和python很像)"></a>常用的用法(和python很像)</h5><table>
        <tr>
            <th>1</th>
            <th>public StringBuffer append(String s)
    将指定的字符串追加到此字符序列。</th>
        </tr>
        <tr>
            <th>2</th>
            <th>public StringBuffer reverse()
     将此字符序列用其反转形式取代。</th>
        </tr>
        <tr>
            <th>3</th>
            <th>public delete(int start, int end)
移除此序列的子字符串中的字符。</th>
        </tr>
        <tr>
            <th>4</th>
            <th>ublic insert(int offset, int i)
将 int 参数的字符串表示形式插入此序列中。</th> 
        </tr>
        <tr>
            <th>5</th>
            <th>replace(int start, int end, String str)
使用给定 String 中的字符替换此序列的子字符串中的字符。</th>
        </tr>
</table>

<h3 id="Java-时间日期"><a href="#Java-时间日期" class="headerlink" title="Java 时间日期"></a>Java 时间日期</h3><p>Java.util 包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象。</p>
<pre><code>`Date()`</code></pre><p>第二个构造函数接收一个参数，参数是从1970年1月1日起的毫秒数。</p>
<pre><code>`Date(long millisec)`</code></pre><h4 id="获取当前的日期和时间"><a href="#获取当前的日期和时间" class="headerlink" title="获取当前的日期和时间"></a>获取当前的日期和时间</h4><p>使用Date对象的toString()方法来打印当前日期和时间</p>
<pre><code>import java.util.Date;
public static void main(String arg[]){
    //初始化Date 对象
    Date date = new Date();

    //使用toString()显示日期时间
    System.out.println(date.toString());
}    </code></pre><p>结果会显示(当前的日期)：<code>Thu Apr 30 10:23:01 CST 2020</code></p>
<h4 id="比较日期"><a href="#比较日期" class="headerlink" title="比较日期"></a>比较日期</h4><p>Java使用以下2种方法来比较两个日期：</p>
<ul>
<li>使用getTime()方法获取两个日期(1970.1.1到现在的毫秒数)，然后比较这两个值。</li>
<li>使用方法before(),after(),equals()。比如new Date(99,2,12).before(new Date(99,2,18))返回True;</li>
</ul>
<h4 id="使用SimpleDateFormat格式化日期"><a href="#使用SimpleDateFormat格式化日期" class="headerlink" title="使用SimpleDateFormat格式化日期"></a>使用SimpleDateFormat格式化日期</h4><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期格式来运行。例如</p>
<pre><code>import  java.util.*;
import java.text.*;

public class DateDemo {
   public static void main(String args[]) {

      Date dNow = new Date( );
      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);

      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));
   }
}</code></pre><p>会输出<code>2020-04-30 05:17:50</code><br>其中<code>SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</code>这条语句确立了转换格式，其中yyyy是完整的公元年，MM是月份，dd是日期，HH：mm:ss是小时、分钟、秒。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。<br>多态就是同一个接口，使用不同的实例而执行不同操作。</p>
<h4 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h4><ol>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
<h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ol>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ol>
<h3 id="Java正则表达式-对不起暂时看不懂"><a href="#Java正则表达式-对不起暂时看不懂" class="headerlink" title="Java正则表达式(对不起暂时看不懂)"></a>Java正则表达式(对不起暂时看不懂)</h3><ol>
<li>正则表达式定义了字符串的模式。</li>
<li>正则表达式可以用来搜索、编辑或处理文本。</li>
<li>正则表达式并不仅限某一种语言，但是在每一种语言中有细微的差别。</li>
</ol>
<h3 id="Java方法与构造方法-见另一博客-方法与构造方法"><a href="#Java方法与构造方法-见另一博客-方法与构造方法" class="headerlink" title="Java方法与构造方法(见另一博客-方法与构造方法)"></a>Java方法与构造方法(见另一博客-方法与构造方法)</h3><h3 id="数组的拷贝，扩容和删除"><a href="#数组的拷贝，扩容和删除" class="headerlink" title="数组的拷贝，扩容和删除"></a>数组的拷贝，扩容和删除</h3><pre><code>public class TestArrayCopy {
    public static void main(String[] args) {
     String[] str = {&quot;阿里&quot;,&quot;京东&quot;,&quot;尚学堂&quot;,&quot;百度&quot;,&quot;亚马逊&quot;};

     removeElement(str,1);

     str = extendRange(str);

    }

    public static void testBasicCopy(){
        String[] s1 = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;,&quot;ee&quot;};
        String[] s2 = new String[10];
        System.arraycopy(s1,2,s2,6,3);
        for (int i = 0 ;i&lt;s2.length;i++) {
            System.out.println(i+&quot;-- &quot;+s2[i]);
        }
    }

    //测试从数组中删除某个元素（本质上还是数组的拷贝）
    public static void testBasicCopy2(){
        String[] s1 = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;,&quot;ee&quot;};
        //String[] s2 = new String[5];

        System.arraycopy(s1,3,s1,3-1,s1.length-3);


        s1[s1.length-1] = null;
        for (int i = 0 ;i&lt;s1.length;i++) {
            System.out.println(i + &quot;-- &quot; + s1[i]);
        }
    }

    //测试删除数组中指定索引位置的元素，并返回
    public static String[] removeElement(String[] s,int index){


        System.arraycopy(s,index+1,s,index,s.length-index-1);


        s[s.length-1] = null;
        for (int i = 0 ;i&lt;s.length;i++) {
            System.out.println(i + &quot;-- &quot; + s[i]);

        }
        return s;
    }

    //数组的扩容(本质是：先定义一个更大的数组，然后讲原数组内容原封不动拷贝到新数组里)
    public static String[] extendRange(String[] s1){
    //String[] s1 = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;};

    String[] s2 = new  String[s1.length+10];

    System.arraycopy(s1,0,s2,0,s1.length);
    for (String temp:s2){
        System.out.println(temp);
    }
        return s2;
    }

}</code></pre><p>作用为删除的会输出：</br><br>0– 阿里 1–尚学堂 2– 百度 3–亚马逊 4– null (删除了京东)</p>
<p>作用为扩容的会输出：</br><br>阿里 尚学堂 百度 亚马逊 null null null null null null null null null null null</p>
<p>由于先调用了remove所以京东不见了。</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>对于包装类来说，这些类的用途主要包含两种：</p>
<ol>
<li>作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。</li>
<li>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化!)。</li>
</ol>
<p>例子：</p>
<pre><code>/*
Integer类的使用。其他包装类用法类似，课下自己学
*/
public class TestWrappedClass {
    public static void main(String[] args) {
        //基本数据类型转换成包装类对象
        Integer b = Integer.valueOf(30);
        Integer a = new Integer(3);

        //把包装类对象转成基本数据类型
        int c = b.intValue();
        double d = b.intValue();

        //把字符串转换成包装类对象
        Integer e = new Integer(&quot;999&quot;);
        Integer f = Integer.parseInt(&quot;9999988&quot;);

        //把包装类对象转换成字符串
        String str = f.toString();

        //常见的常量
        System.out.println(&quot;int类型最大的整数：&quot;+Integer.MAX_VALUE);
    }
}</code></pre><p>会输出Int型Max值：2147483647</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>在JDK1.5以后提供了自动装箱和拆箱什么意思呢？之前<code>Interge i =100</code>这段代码是错误的，但是现在是对的；</p>
<pre><code>Integer i = 100;//这就是自动装箱
相当于编译器自动执行了一下代码
Integer i = Integer.valueOf(100).</code></pre><p>自动拆箱：</p>
<pre><code>Integer i = 100;
int j = i;//自动拆箱
//相当于编译器自动为您作以下的语法编译：
int j = i.intValue();</code></pre><p>但是要注意空指针异常问题例如：</p>
<pre><code>public class Test1 {
    public static void main(String[] args) {
        Integer i = null;
        int j = i;
    }
}</code></pre><p>这里会报空指针错；因为null表示i没有指向任何对象的实体，但作为对象名称是合法的。</p>
<h4 id="包装类缓存问题"><a href="#包装类缓存问题" class="headerlink" title="包装类缓存问题"></a>包装类缓存问题</h4><p>整型、char型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。<br>比如：</p>
<pre><code>public class Test3 {
    public static void main(String[] args) {
        Integer in1 = -128;
        Integer in2 = -128;
        System.out.println(in1 == in2);//true 因为123在缓存范围内
        System.out.println(in1.equals(in2));//true
        Integer in3 = 1234;
        Integer in4 = 1234;
        System.out.println(in3 == in4);//false 因为1234不在缓存范围内
        System.out.println(in3.equals(in4));//true
    }
}</code></pre><p>结果是:</br><br>true</br><br>true</br><br>false</br><br>true</br></p>
<p>运行的效果图为<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495596432165735.png" alt=""></p>
<blockquote>
<p>意思就是当年应用在缓存区内的数字可以直接调用缓存区中的对象，所以  123==123(在缓存中调用的是同一个对象)为True 但是in3 1234== in4 1234 是不同的对象所以为False 因此以后比较大小的时候用<code>equals</code>比较同一个对象是不是一个则用<code>==</code></p>
</blockquote>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h4><p>以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中储存，如</p>
<pre><code>import java.io.File;
import java.io.IOException;
import java.util.Date;
/*
测试File类
*/
public class TestFile {
    public static void main(String[] args) throws IOException {
        File f = new File(&quot;d:/a.txt&quot;); //绝对路径：在d盘目录下创建a.txt
        System.out.println(f);
        f.renameTo(new File(&quot;d:/b.txt&quot;));// 改名字

        System.out.println(System.getProperty(&quot;user.dir&quot;));

        File f2 = new File(&quot;gg.txt&quot;);  // 相对路径：默认放到user.dir目录下(即这里是面向对象目录下)
        f2.createNewFile();
    }
}</code></pre><p>在此，user.dir就是本项目的目录，如我在面向对象目录中创建了个 gg.txt 文件.而我又在D盘根下创建了一个a.txt改名为了b.txt。</p>
<p><strong>通过File对象可以访问文件的属性：</strong></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495611382530451.png" alt=""></p>
<h4 id="测试File类访问属性的基本用法"><a href="#测试File类访问属性的基本用法" class="headerlink" title="测试File类访问属性的基本用法"></a>测试File类访问属性的基本用法</h4><pre><code>System.out.println(f2.exists());
System.out.println(f2.isDirectory());
System.out.println(f2.isFile());
System.out.println(new Date(f2.lastModified()));
System.out.println(f2.getName());
System.out.println(f2.getPath());</code></pre><p>结果</p>
<pre><code>true
false
true
Tue May 05 21:18:22 CST 2020
gg.txt
gg.txt</code></pre><p><strong>通过File对象创建空文件或目录(在该对象所指的文件或目录不存在的情况下)</strong><br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495611400819053.png" alt=""></p>
<h4 id="使用mkdir创建目录"><a href="#使用mkdir创建目录" class="headerlink" title="使用mkdir创建目录"></a>使用mkdir创建目录</h4><pre><code>import java.io.File;
public class TestFile3 {
    public static void main(String[] args) throws Exception {
        File f = new File(&quot;d:/c.txt&quot;);
        f.createNewFile(); // 会在d盘下面生成c.txt文件
        f.delete(); // 将该文件或目录从硬盘上删除
        File f2 = new File(&quot;d:/电影/华语/大陆&quot;);
        boolean flag = f2.mkdir(); //目录结构中有一个不存在，则不会创建整个目录树
        System.out.println(flag);//创建失败
        boolean flag1 = f3.mkdirs();//目录结构中有一个不存在也没关系；创建整个目录树
        System.out.println(flag1);//创建成功
    }
}</code></pre><p>结果</p>
<pre><code>false
true</code></pre><h4 id="递归遍历目录结构和树状展现"><a href="#递归遍历目录结构和树状展现" class="headerlink" title="递归遍历目录结构和树状展现"></a>递归遍历目录结构和树状展现</h4><pre><code>import java.io.File;

public class PrintFileTree {
    public static void main(String[] args) {
        File f = new File(&quot;E:\\Desktop&quot;);

        printFile(f,0);
    }


    static void printFile(File file,int level){

        //输出层数
        for(int i = 0;i&lt;level;i++){
            System.out.println(&quot;-&quot;);
        }

        System.out.println(file.getName());
        if (file.isDirectory()){
            File[] files = file.listFiles();

            for (File temp:files){
            printFile(temp,level+1);
            }    //强化for语句
        }
    }
}</code></pre><p>会输出</p>
<pre><code>Desktop
-
720P_4000K_178868721.mp4
-
Kaede cosplay.mp4</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code>/*
测试枚举*/
public class TestEnum {
    public static void main(String[] args) {
        System.out.println(Season.SPRING);

        Season a = Season.AUTUMN;

        switch (a){
            case SPRING:
                System.out.println(&quot;春天来啦，播种的季节&quot;);
                break;
            case SUMMER:
                System.out.println(&quot;夏天来了游泳的季节&quot;);
                break;
            case AUTUMN:
                System.out.println(&quot;秋天来了收获的季节&quot;);
                break;
            case WINTER:
                System.out.println(&quot;冬天来了冬眠的季节&quot;);
                break;
        }

   }
}

enum Season{
    SPRING,SUMMER,AUTUMN,WINTER
}
enum Weak{
    星期一,星期二,星期三,星期四,星期五,星期六,星期天
}</code></pre><p>挺简单的= =</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>引子：</strong>在工作中，可能会遇到很多异常的情况比如：写某个模块，用户输入的不符合你的要求，你的程序要打开某个文件，这个文件不存在或者格式不对，你要读取数据库的数，数据为空，程序运行的时候内存或硬盘满了等等…</p>
<p>这些问题我们称之为异常，英文名为Exception，就是意料之外的意思。</p>
<p>异常机制本质就是当程序出现错误，程序安全退出的机制。</p>
<p>Java是采用面向对象的方式来处理异常的。处理过程：</p>
<ol>
<li>抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。</li>
<li>捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</li>
</ol>
<p>比如：</p>
<pre><code>public static void main(String[] args){
    int i=1/0; //除数为0
    System.out.println(i);
}</code></pre><p>运行结果会是</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero;</code></pre><p>Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。</p>
<p>Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：</p>
<ol>
<li>RuntimeException 运行时异常</li>
<li>CheckedException 已检查异常</li>
</ol>
<h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>JDK 中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。</p>
<p>Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。Java异常类的层次结构如图6-2所示。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272017528669.png" alt=""></p>
<h4 id="RuntimeException运行时异常"><a href="#RuntimeException运行时异常" class="headerlink" title="RuntimeException运行时异常"></a>RuntimeException运行时异常</h4><pre><code>    public class TestException {
    public static void main(String[] args) {
        int a = 0;
        int b = 1;
        if (a!=0) {
            System.out.println(b / a);
        }

        String str = null;
        if (str != null) {
            str.length();
        }

        Animal d = new Dog();
        if (d instanceof Cat) {
            Cat c = (Cat) d;
        }
    }
}
class Animal{

}
class Dog extends Animal{

}
class Cat extends Animal{

}</code></pre><p>里面有 <code>/0</code>异常 有空指针异常，还有类型转换异常</p>
<blockquote>
<p>if里面都是解决异常的方法。</p>
</blockquote>
<h4 id="CheackedException"><a href="#CheackedException" class="headerlink" title="CheackedException"></a>CheackedException</h4><p>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273524104532.png" alt=""></p>
<h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>捕获异常是通过3个关键词来实现的：try–catch–finally。用try执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可以又多条；finally语句最多只有一条，根据自己的需要可有可无)<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273755315926.png" alt=""></p>
<p><strong>1.try:</strong></br><br>try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码，代码中可以产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常作相应的处理。</p>
<blockquote>
<p>一个try语句必须带有至少一个catch语句块或finally语句块。</p>
</blockquote>
<p><strong>ps.</strong>异常处理的代码执行结束后不会回到try语句去执行未执行的代码。</p>
<p><strong>2.catch:</strong></br><br>n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p>n-常用方法，这些方法均继承自Throwable类 。</p>
<p>u-toString ()方法，显示异常的类名和产生异常的原因</p>
<p>u-getMessage()方法，只显示产生异常的原因，但不显示类名。</p>
<p>u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。</p>
<p>n-catch捕获异常时的捕获顺序：</p>
<p>u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。</p>
<p><strong>3.finally:</strong></br><br>n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。</p>
<p>n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。</p>
<p>综合以上的三点可得：</p>
<pre><code>try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}</code></pre><p>try-catch-finally语句块的执行过程： 程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行。如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句执行完之后程序会继续执行finally语句块，finally语句块是可选的    ，如果有，无论是否发生异常都会执行finally语句。</p>
<p>pss.</p>
<ol>
<li>即使try和catch里面有return，也会执行finally语句。执行完再return退出。</li>
<li>finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到System.exit(0)；结束程序运行。</li>
</ol>
<p>实例：</p>
<pre><code>/*
使用try catch来处理异常
*/
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class TestExpection02 {
    public static void main(String[] args) {
        readMyFile();
    }

    public static void readMyFile(){
        FileReader reader = null;
        try
        {
            reader = new FileReader(&quot;d:/c.txt&quot;);
            char c1 = (char)reader.read();
            System.out.println(c1);

        } catch(FileNotFoundException e)  //子类异常在父类异常前面
        {
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        }finally {
            try{
                if (reader != null){
                    reader.close();
                }
            }catch (IOException e){
                e.printStackTrace();
            }
        }
    }
}</code></pre><p>结果是：</p>
<pre><code>java.io.FileNotFoundException: d:\c.txt (系统找不到指定的文件。)
at java.io.FileInputStream.open0(Native Method)
at java.io.FileInputStream.open(FileInputStream.java:195)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)
at java.io.FileReader.&lt;init&gt;(FileReader.java:58)
at cn.sxt.test.TestExpection02.readMyFile(TestExpection02.java:17)
at cn.sxt.test.TestExpection02.main(TestExpection02.java:10)</code></pre><h4 id="异常处理方法2：throws"><a href="#异常处理方法2：throws" class="headerlink" title="异常处理方法2：throws"></a>异常处理方法2：throws</h4><p>当CheckedException产生时，不一定立刻处理它，可以把异常throws(扔出去)出去.在某些情况下不需要处理法伤的异常，而是向上传递给调用它的方法处理。</p>
<p>如果一个方法中产生某种异常但是并不确定如何处理这种异常，则应该根据异常规范在方法的部首声明该方法可能抛出的异常例子(我不太会)</p>
<pre><code>import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test9 {
    public static void main(String[] args) {
        try {
            readFile(&quot;joke.txt&quot;);
        } catch (FileNotFoundException e) {
            System.out.println(&quot;所需文件不存在！&quot;);
        } catch (IOException e) {
            System.out.println(&quot;文件读写错误！&quot;);
        }
    }  
    public static void readFile(String fileName) throws FileNotFoundException,          
    IOException {
        FileReader in = new FileReader(fileName);
        int tem = 0;
        try {
            tem = in.read();
            while (tem != -1) {
                System.out.print((char) tem);
                tem = in.read();
            }
        } finally {
            in.close();
        }
    }
}</code></pre><p>注意：方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不可超过父类的声明范围。</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ol>
<li><p>我们在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类。即自定义异常类。</p>
</li>
<li><p>自定义异常类只需要从Exception类或它的子类派生一个子类即可。</p>
</li>
<li><p>自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理；若干不想处理,可以让自定义异常类继承运行时异常RuntimeExcepion类。</p>
</li>
<li><p>习惯上，自定义异常类应该包含2个构造器：默认的构造器，另一个是带有详细信息的构造器。</p>
<pre><code>public class TestException03 {
public static void main(String[] args) {
    Person p = new Person();
    p.setAge(-10);
    }
}    

class Person{
private int age;

public int getAge() {
    return age;
}

public void setAge(int age) {
    if(age&lt;0){
        throw new IllegalAgeException(&quot;年龄不可以为负数&quot;);
        }
    this.age = age;
    }
}
class IllegalAgeException extends RuntimeException{
public IllegalAgeException(){

}
public IllegalAgeException(String msg){
    super(msg);//引用父类的方法
    }
}</code></pre><p>输出结果</p>
<p> Exception in thread “main” cn.sxt.test.IllegalAgeException: 年龄不可以为负数<br> at cn.sxt.test.Person.setAge(TestException03.java:18)<br> at cn.sxt.test.TestException03.main(TestException03.java:6)</p>
<h4 id="学会百度！"><a href="#学会百度！" class="headerlink" title="学会百度！"></a>学会百度！</h4><p>众所周知，百度是万能的。一般我们遇到的异常别人都遇到过，cv过去就好了。</p>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li><p>Error与Exception都继承自Throwable类</p>
</li>
<li><p>Error类层次描述了Java运行时系统内部错误和资源耗尽错误。</p>
</li>
<li><p>Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。</p>
</li>
<li><p>常见的异常类型</p>
</li>
</ol>
<ul>
<li><p>ArithmeticException </p>
<blockquote>
<p>算术异常</p>
</blockquote>
</li>
<li><p>NullPointerException</p>
<blockquote>
<p>空指针异常</p>
</blockquote>
</li>
<li><p>ClassCastException</p>
<blockquote>
<p>类型转换异常</p>
</blockquote>
</li>
<li><p>ArrayIndexOutOfBoundsException</p>
<blockquote>
<p>数组下标异常</p>
</blockquote>
</li>
<li><p>NumberFormatException</p>
<blockquote>
<p>数字格式化异常</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li><p>方法重写中声明异常原则：子类声明的异常范围不能超过父类声明的范围</p>
</li>
<li><p>异常处理的三种方式</p>
</li>
</ol>
<ul>
<li><p>捕获异常:try-catch-finally</p>
</li>
<li><p>声明异常:throws</p>
</li>
</ul>
<ol start="7">
<li>自定义异常类只需从Exception类或者它的子类派生一个子类即可。</li>
</ol>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>开发和学习中时刻需要和数据打交道，如何组织这些数据是我们编程中重要的内容。我们一般通过”容器”来容纳和管理数据，那什么是”容器”呢？ 生活中能容纳东西的，程序中也有类似功能，就是用来容纳和管理数据的。</p>
<p>数组也是一种容易。但是相对于容器来说不方便。</br><br><strong>数组的劣势：</strong>不灵活。需要事先定义容量，不能随着需求的变化而扩容。比如:我们在一个用户管理系统中，要把今天注册的所有用户取出来，这样用户有多少我们事先是不知道的。所以在这里不能使用数组。<br><strong>数组的优势：</strong>是一种简单的线性序列，可以快速访问数组元素，效率高。如果从效果和类型检查角度讲。数组是最好的。</p>
<p>基于我们对数组的不满意因此引出了容器，也叫集合(Collection)，一下是容器的接口层次结构图：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495613220648265.png" alt=""><br>要学容器我们先学泛型。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li>添加</li>
</ol>
<ul>
<li>add 有两种用法<br>第一种是直接add对象，把对象加在最后面</li>
<li>第二种是在指定位置加对象</li>
</ul>
<ol start="2">
<li>判断是否存在</li>
</ol>
<ul>
<li>通过方法contains 判断一个对象是否在容器中。判断标准： 是否是同一个对象，而不是name是否相同</li>
</ul>
<ol start="3">
<li>获得指定位置的对象</li>
</ol>
<ul>
<li>通过get获取指定位置的对象，如果输入的下标越界，一样会报错</li>
</ul>
<ol start="4">
<li>获取对象所处的位置</li>
</ol>
<ul>
<li>indexOf用于判断一个对象在ArrayList中所处的位置。与contains一样，判断标准是对象是否相同，而非对象的name值是否相等</li>
</ul>
<ol start="5">
<li>删除元素</li>
</ol>
<ul>
<li>remove用于把对象从ArrayList中删除<br>remove可以根据下标删除ArrayList的元素<br>。也可以根据对象删除</li>
</ul>
<ol start="6">
<li>替换</li>
</ol>
<ul>
<li>set用于替换指定位置的元素</li>
</ul>
<ol start="7">
<li>获取大小</li>
</ol>
<ul>
<li>size 用于获取ArrayList的大小</li>
</ul>
<ol start="8">
<li>转换为数组</li>
</ol>
<ul>
<li>toArray可以把一个ArrayList对象转换为数组。<br>需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组</li>
</ul>
<ol start="9">
<li>把另一个容器的对象都加进来</li>
</ol>
<ul>
<li>addAll 把另一个容器所有对象都加进来</li>
</ul>
<ol start="10">
<li>清空一个容器</li>
</ol>
<ul>
<li>clear 清空一个ArrayList</li>
</ul>
<pre><code>package ArrayList;

import Basic.Hero;
import com.sun.scenario.effect.impl.sw.java.JSWBlend_SRC_OUTPeer;

import java.util.ArrayList;

public class practiceCommonMethods {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();

        //初始化5个对象
        for(int i = 0;i &lt; 5;i++){
            heros.add(new Hero(&quot;hero &quot; + i));
        }
        Hero spe = new Hero(&quot;special hero&quot;);
        heros.add(spe);

        System.out.println(heros + &quot; &quot;);

        //判断一个对象是否在容器里面
        //判断标准：是否是同一个对象，而不是name是否相同；
        System.out.print(&quot;虽然一个新的对象名字叫hero 1，但是contains的返回是：&quot;);
        System.out.println(heros.contains(new Hero(&quot;hero 1&quot;)));
        System.out.print(&quot;然而对于spe，contains的返回是：&quot;);
        System.out.println(heros.contains(spe));

        //通过get获取指定索引的元素
        System.out.println(heros.get(5));
        //越界会报错
        //System.out.println(heros.get(8));
        System.out.println(&quot;special hero的位置是&quot;+heros.indexOf(spe));
        System.out.println(heros.size());

        //remove用于把对象从ArrayList中删除
        //remover可以根据下标删除ArrayList的元素
        //remove下标为2的对象
        heros.remove(2);
        System.out.print(heros+&quot; &quot;);

        //set用于替换指定位置的元素
        //把下标为4的元素替换成hero 5；
        System.out.println();
        heros.set(4,new Hero(&quot;hero 5&quot;));
        System.out.print(heros + &quot; &quot;);
        System.out.println();

        //用toArray的方法把ArrayList变成Array，并增强for循环输出
        Hero []hs = (Hero[]) heros.toArray(new Hero []{});
        for (Hero temp : hs)
            System.out.print(temp + &quot; &quot;);

        //清空ArrayList里面的所有元素
        System.out.println();
        heros.clear();
        System.out.print(heros);
    }
}</code></pre><p>会输出</p>
<pre><code>[hero 0, hero 1, hero 2, hero 3, hero 4, special hero] 
虽然一个新的对象名字叫hero 1，但是contains的返回是：false
然而对于spe，contains的返回是：true
special hero
special hero的位置是5
6
[hero 0, hero 1, hero 3, hero 4, special hero] 
[hero 0, hero 1, hero 3, hero 4, hero 5] 
[]</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><pre><code>package ArrayList;

import Basic.Hero;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/*
集合框架的遍历
*/

public class practiceErgodic {
    public static void main(String[] args) {
        List&lt;Hero&gt; heros = new ArrayList&lt;&gt;();

        //放5个Hero进入容器
        for (int i = 0; i &lt; 5; i++) {
            heros.add(new Hero(&quot;hero name&quot; + i));
        }

        //第一种遍历for循环
        System.out.println(&quot;------------for 循环---------------&quot;);
        for (int i = 0; i &lt; heros.size(); i++) {
            Hero h = heros.get(i);
            System.out.println(h);
        }

        //◀第二种迭代器遍历
        System.out.println(&quot;---------- while的iterator遍历 ---------------&quot;);
        Iterator&lt;Hero&gt; it = heros.iterator();
        //从最开始的位置判断&quot;下一个&quot;位置是否有数据
        //如果有就通过next取出来，并把指针向下移动
        //知道&quot;下一个&quot;位置没有数据了
        /*(1) 使用方法iterator()要求容器返回一个Iterator。
        第一次调用Iterator的next()方法时，它返回序列的第一个元素。
        注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
　　      (2) 使用next()获得序列中的下一个元素。
　　      (3) 使用hasNext()检查序列中是否还有元素。
　　      (4) 使用remove()将迭代器新返回的元素删除。*/
        while (it.hasNext()) {
            Hero h1 = it.next();
            System.out.println(h1);
        }
        System.out.println(&quot;---------- for的iterator遍历 --------------&quot;);
        for (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext(); ) {
            Hero hero = iterator.next();
            System.out.println(hero);
        }
        //增强for循环遍历
        System.out.println(&quot;---------- 增强for循环遍历 --------------&quot;);
        for (Hero h2 : heros) {
            System.out.println(h2);
        }

        //练习输出非八倍数的元素
        System.out.println(&quot;练习--------------------------------------------------&quot;);
        List&lt;Hero&gt; heros1 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 100; i++) {
            if (i%8 != 0 )
                heros1.add(new Hero(&quot;hero&quot; + i));
        }
        for(Hero h3 : heros1){
            System.out.print(h3 + &quot; &quot;);
        }
    }
}</code></pre><p>会输出</p>
<pre><code>    ------------for 循环---------------
hero name0
hero name1
hero name2
hero name3
hero name4
---------- while的iterator遍历 ---------------
hero name0
hero name1
hero name2
hero name3
hero name4
---------- for的iterator遍历 --------------
hero name0
hero name1
hero name2
hero name3
hero name4
---------- 增强for循环遍历 --------------
hero name0
hero name1
hero name2
hero name3
hero name4
练习--------------------------------------------------
hero1 hero2 hero3 hero4 hero5 hero6 hero7 hero9 hero10 hero11 hero12 hero13 hero14 hero15 hero17 hero18 hero19 hero20 hero21 hero22 hero23 hero25 hero26 hero27 hero28 hero29 hero30 hero31 hero33 hero34 hero35 hero36 hero37 hero38 hero39 hero41 hero42 hero43 hero44 hero45 hero46 hero47 hero49 hero50 hero51 hero52 hero53 hero54 hero55 hero57 hero58 hero59 hero60 hero61 hero62 hero63 hero65 hero66 hero67 hero68 hero69 hero70 hero71 hero73 hero74 hero75 hero76 hero77 hero78 hero79 hero81 hero82 hero83 hero84 hero85 hero86 hero87 hero89 hero90 hero91 hero92 hero93 hero94 hero95 hero97 hero98 hero99 </code></pre><h4 id="集合框架LinkedList"><a href="#集合框架LinkedList" class="headerlink" title="集合框架LinkedList"></a>集合框架LinkedList</h4><p>序列分先进先出FIFO,先进后出FILO</br><br>FIFO在Java中又叫Queue 队列</br><br>FILO在Java中又叫Stack 栈</br><br>测试LinkedList的特有的方法</p>
<pre><code>package ArrayList;

import Basic.Hero;

import java.util.LinkedList;

/*
与ArrayList一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。

除了实现了List接口外，LinkedList还实现了双向链表结构Deque，可以很方便的在头尾插入删除数据
什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，
每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，
不用关心除此之外的其他佛珠在哪里。
*/
public class practiceLinkedList {
    public static void main(String[] args) {
        //LinkedList是一个双向链表结构的list
        LinkedList&lt;Hero&gt; ll = new LinkedList&lt;&gt;();

        //所以可以很方便的在头部和尾部插入数据
        //在遭遇过i有插入新的英雄
        ll.addLast(new Hero(&quot;hero1&quot;));
        ll.addLast(new Hero(&quot;hero2&quot;));
        ll.addLast(new Hero(&quot;hero3&quot;));
        System.out.println(ll);

        //在最前面插入新的英雄
        ll.addFirst(new Hero(&quot;heroX&quot;));
        System.out.println(&quot;添加完元素后的List：&quot;+ll);

        //查看最前面的英雄
        System.out.println(&quot;查看最前的元素：&quot;+ll.getFirst());
        //查看最后面的英雄
        System.out.println(&quot;查看最后的元素：&quot;+ll.getLast());

        //查看不会导致英雄被删除
        System.out.println(&quot;查看后的List：&quot;+ll);

        //取出最前面的英雄
        System.out.println(&quot;取出最头的元素：&quot;+ll.removeFirst());

        //取出最后的英雄
        System.out.println(&quot;取出最后的元素：&quot;+ll.removeLast());

        //取出会导致英雄被删除
        System.out.println(&quot;取出元素之后的List：&quot; + ll);
    }
}</code></pre><p>会输出</p>
<pre><code>[hero1, hero2, hero3]
添加完元素后的List：[heroX, hero1, hero2, hero3]
查看最前的元素：heroX
查看最后的元素：hero3
查看后的List：[heroX, hero1, hero2, hero3]
取出最头的元素：heroX
取出最后的元素：hero3
取出元素之后的List：[hero1, hero2]</code></pre><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue是FIFO的</p>
<pre><code>package ArrayList;

import Basic.Hero;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class practiceQueue {
    public static void main(String[] args) {
        //和ArrayList一样，LinkedList也实现了List接口
        List ll = new LinkedList&lt;Hero&gt;();

        //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口
        //Queue代表FIFO先进先出的队列
        Queue&lt;Hero&gt; q = new LinkedList&lt;&gt;();
        System.out.print(&quot;初始化队列：\t&quot;);
        q.offer(new Hero(&quot;hero 1&quot;));
        q.offer(new Hero(&quot;hero 2&quot;));
        q.offer(new Hero(&quot;hero 3&quot;));
        q.offer(new Hero(&quot;hero 4&quot;));
        System.out.println(q);

        System.out.println(&quot;把第一个元素poll()出来：\t&quot;);
        //取出第一个Hero，FIFO先进先出
        System.out.println(q.poll());

        System.out.println(&quot;取出第一个元素后的队列：\t&quot;);
        System.out.println(q);

        //把第一个拿出来看看，单不取出来
        System.out.println(&quot;查看peek()第一个元素：\t&quot; + q.peek());
        System.out.println(q);
    }
}</code></pre><p>会输出</p>
<pre><code>初始化队列：    [hero 1, hero 2, hero 3, hero 4]
把第一个元素poll()出来：    
hero 1
取出第一个元素后的队列：    
[hero 2, hero 3, hero 4]
查看peek()第一个元素：    hero 2
[hero 2, hero 3, hero 4]</code></pre><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。</br></p>
<p>如何选用ArrayList、LinkedList、Vector?</p>
<ol>
<li>需要线程安全时，用Vector。</li>
<li>不存在线程安全问题时，并且查找较多用ArrayList(一般使用它)。</li>
<li>不存在线程安全问题时，增加或删除元素较多用LinkedList。</li>
<li><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3>Map的储存方式是以键(key)-值(value)对的方式储存的,储存的”键值对”通过键来标识，所以”键对象”不能重复</li>
</ol>
<p>Map接口实现类有HashMap、TreeMap、HashTable、Properties等<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495617463792119.png" alt=""></p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap采用哈希算法实现，是Map接口最常用的实现类。由于底层采用了Hash表储存数据，我们要求键不能重复，如果发生重复，新的键值会替换旧的键值对。HashMap在查找、删除、修改方面都有非常高的效率。</p>
<pre><code>package ArrayList;

import Basic.Hero;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class practiceHashMap {
    public static void main(String[] args) {
        HashMap&lt;String, String&gt; dictionary = new HashMap&lt;&gt;();
        dictionary.put(&quot;adc&quot;,&quot;物理英雄&quot;);
        dictionary.put(&quot;apc&quot;,&quot;法术英雄&quot;);
        dictionary.put(&quot;t&quot;,&quot;坦克&quot;);

        System.out.println(dictionary.get(&quot;t&quot;));

        HashMap&lt;String,Hero&gt; heroHashMap = new HashMap&lt;&gt;();

        heroHashMap.put(&quot;gareen&quot;,new Hero(&quot;gareen1&quot;));
        System.out.println(heroHashMap);

        //key为gareen已经有value了，再以gareen作为key放入数据，会导致原英雄被覆盖
        //不会增加新的元素到Map里
        heroHashMap.put(&quot;gareen&quot;,new Hero(&quot;gareen2&quot;));
        System.out.println(heroHashMap);

        //清空map
        heroHashMap.clear();
        Hero hero = new Hero(&quot;gareen&quot;);

        //同一个对象可以作为值插入到map中，只要对应的key不一样
        heroHashMap.put(&quot;gareen1&quot;,hero);
        heroHashMap.put(&quot;gareen2&quot;,hero);
        System.out.println(heroHashMap.values());
    }
}</code></pre><p>会输出</p>
<pre><code>坦克
{gareen=gareen1}
{gareen=gareen2}
{gareen2=gareen, gareen1=gareen}</code></pre><blockquote>
<p>一个获取键值的好方法</p>
</blockquote>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class TestMap {
    public static void main(String[] args) {
        Employee e1 = new Employee(1001,&quot;zwz&quot;,50000);
        Employee e2 = new Employee(1002,&quot;hxm&quot;,40000);
        Employee e3 = new Employee(1003,&quot;haha&quot;,5000);
        Employee e4 = new Employee(1004,&quot;xixi&quot;,6000);
        //WEmployee e5 = new Employee(1001,&quot;6&quot;,6000);

        Map&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;();
        map.put(1001,e1);
        map.put(1002,e2);
        map.put(1003,e3);
        map.put(1004,e4);
        //map.put(1001,e5);

        Employee emp = map.get(1001);

        System.out.println(emp.getSalary());
        //System.out.println(map);
    }
}

//雇员信息
class Employee{
    private int id;
    private  String name;
    private double salary;

    @Override
    public String toString() {
        return &quot;id= &quot; + id + &quot;name= &quot; + name + &quot;薪水= &quot;+salary;
    }

    public Employee(int id, String name, double salary) {
        super();
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}</code></pre><blockquote>
<p>不妨把class Employee 看成一个结构体。Map定义的泛型是&lt;Interge，Employee&gt; 用对象把Employee信息包起来然后放进了HashMap的value里面。等于保存了多个信息。再用get方法即可看到雇员的信息了。</p>
</blockquote>
<h4 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h4><ol>
<li>HashMap：线程不安全，效率高。允许key或value为null；</li>
<li>HashTable：线程安全，效率低，不允许key或value为null；</li>
</ol>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class practiceCollections {
    public static void main(String[] args) {
        //初始化集合numbers
        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; 10; i++) {
            numbers.add(i);
        }
        System.out.println(&quot;集合中的所有元素&quot;);
        System.out.println(numbers);

        Collections.reverse(numbers);

        System.out.println(&quot;反转集合中的所有元素&quot;);
        System.out.println(numbers);

        Collections.shuffle(numbers);
        System.out.println(&quot;混淆List数据中的顺序&quot;);
        System.out.println(numbers);

        Collections.sort(numbers);
        System.out.println(&quot;顺序排列集合中的元素&quot;);
        System.out.println(numbers);

        Collections.swap(numbers,0,5);
        System.out.println(&quot;交换第一个和第六个数子厚的集合&quot;);
        System.out.println(numbers);

        Collections.rotate(numbers,8);
        System.out.println(&quot;向右滚动8个集合&quot;);
        System.out.println(numbers);

        // ---------------------------------------------------
        /*首先初始化一个List,长度是10，值是0-9。
            然后不断的shuffle，直到前3位出现
            3 1 4
            shuffle 1000,000 次，统计出现的概率*/
        List&lt;Integer&gt; number2 = new ArrayList&lt;&gt;();
        int count = 0 ;
        for (int i = 0;i &lt; 10;i++){
            number2.add(i);
        }
        for (int i = 0;i &lt; 1000000; i++){
            Collections.shuffle(number2);
            if (number2.get(0)==3 &amp;&amp; number2.get(1)==1 &amp;&amp; number2.get(2)==4) {
                count++;
            }
        }
        System.out.println(count);
    }
}</code></pre><p>会输出</p>
<pre><code>集合中的所有元素
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
反转集合中的所有元素
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
混淆List数据中的顺序
[6, 1, 9, 2, 7, 0, 5, 8, 4, 3]
顺序排列集合中的元素
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
交换第一个和第六个数子厚的集合
[5, 1, 2, 3, 4, 0, 6, 7, 8, 9]
向右滚动8个集合
[2, 3, 4, 0, 6, 7, 8, 9, 5, 1]
1312    </code></pre><h3 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h3><p><strong>泛型：</strong>它可以帮助我们建立类型安全的集合，遍历时不用强制类型转换，提高了可读性以及安全性。</br><br>泛型本质就是：”数据类型的参数化”。我们可以把”泛型”理解为数据类型的一个占位符(形参)，即高数编译器，在调用泛型时必须传入实际类型。</p>
<blockquote>
<p>说白了就是避免转型</p>
</blockquote>
<h2 id="I-O看我的另一篇吧"><a href="#I-O看我的另一篇吧" class="headerlink" title="I/O看我的另一篇吧"></a>I/O看我的另一篇吧</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/IO%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/IO%E6%B5%81/" class="post-title-link" itemprop="url">IO流</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-27 16:54:42" itemprop="dateModified" datetime="2020-06-27T16:54:42+08:00">2020-06-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="I-O流-input-output"><a href="#I-O流-input-output" class="headerlink" title="I/O流(input/output)"></a>I/O流(input/output)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分别为<code>输入input</code>和<code>输出output</code></p>
<ul>
<li>即流向内存是输入流</li>
<li>流出内存的输出流</li>
</ul>
<p>Java中I/O操作主要是指使用Java.io包下的内容，进行输入、输出操作。</p>
<ul>
<li>输入也叫做读取数据</li>
<li>输出也叫做写出数据</li>
</ul>
<p>根据数据的流向分为 输入流和输出流。</br></p>
<ul>
<li>输入流：把数据从<strong>其他设备</strong>上读取到<strong>内存</strong>中的流。</li>
<li>输出流：把数据从<strong>内存</strong>中写出到<strong>其他设备</strong>上的流。</li>
</ul>
<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li>字节流：以字节为单位，读写数据的流</li>
<li>字符流：以字符为单位，读写数据的流。</li>
</ul>
<p><img src="https://i.loli.net/2020/06/17/OtcnW52hIbA9gH1.png" alt="1592404932_1_.jpg"></p>
<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><hr>
<h2 id="一切皆为字节"><a href="#一切皆为字节" class="headerlink" title="一切皆为字节"></a>一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个字节，那么传输亦是如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用上面样的流对象，底层传输的始终为二进制数据</p>
<h2 id="字节输出流-OutputStream"><a href="#字节输出流-OutputStream" class="headerlink" title="字节输出流[OutputStream]"></a>字节输出流[OutputStream]</h2><p>java.io.OutputStream抽象类是表示字节输出流的所以类的超类(父类),将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code>:关闭此输出流并释放与此流相关联的系统资源。</li>
<li><code>public void flush()</code>：刷新此输出流，并强制任何缓冲的输出字节被写出。</li>
<li><code>public void write(byte[] b)</code>：将b.length字节从指定的字节数组写入此输出流。</li>
<li><code>public void write(byte[] b,int off, int len)</code>:从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。</li>
<li><code>public abstract void write(int b)</code>：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>使用流之后必须close关闭资源。</p>
</blockquote>
<h2 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h2><p><code>OutputStream</code>很多子类，这是其中之一。<br><code>java.io.FileOutputStream</code>类是文件输出流，用于将数据写出到文件。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public FileOutputStream(File file)</code>:创建文件输出流以写入由指定的File对象表示的文件。</li>
<li><code>public FileOutputStream(String name)</code>：创建文件输出流以指定的名称写入文件。</li>
</ul>
<p>当年创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，就会创建该文件，如果由，会清空这个文件的数据。</p>
<p>例子：</p>
<pre><code>public class testOutputStream {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        fos.write(97);
        fos.close();

        //一次写多个字节的方法、
        FileOutputStream fos1 = new FileOutputStream(new File(&quot;b.txt&quot;));
        byte []bytes = {65,66,67,68,69};  //ABCDE
        fos1.write(bytes,2,3);

        //写入字符串
        byte[] bytes1 = &quot;你好&quot;.getBytes();
        System.out.println(Arrays.toString(bytes1));//[-28, -67, -96, -27, -91, -67]
        fos1.write(bytes1);
        fos1.close();
    }
}</code></pre><p>会输入<code>CDE你好</code> 进入b.txt文件中</p>
<blockquote>
<p>输入中文的话可以用字节数组 <code>byte []b = &quot;中文字符串&quot;.getbytes()</code>; 接着.write(b)即可。</p>
</blockquote>
<h3 id="数据的追加续写"><a href="#数据的追加续写" class="headerlink" title="数据的追加续写"></a>数据的追加续写</h3><p>每次运行以上的代码都会创建输出流对象，都会清空目标文件中的数据，通过</p>
<ul>
<li>public FileOutputStream(File file,boolean append):创建文件输出流以写入由指定的File对象表示的文件。</li>
<li>public FileOutputStream(String name,boolean append)：创建文件输出流以指定的名称写入文件。</li>
</ul>
<p>这俩方法都需要放入一个布尔类型的值即<code>true</code> / <code>false</code></p>
<pre><code>public class TestOutputStream02 {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot;,true);
        for (int i = 1;i&lt;=10;i++){
            fos.write(&quot;你好&quot;.getBytes());
            fos.write(&quot;\r\n&quot;.getBytes());
        }

        fos.close();
    }
}</code></pre><p>会输出 10行你好</p>
<blockquote>
<p>回车符<code>\r</code>换行符<code>\n</code>：</p>
</blockquote>
<blockquote>
<ul>
<li>回车符：回到一行的开头。</li>
<li>换行符：下一行。</li>
</ul>
</blockquote>
<h2 id="字节输入流-InputStream"><a href="#字节输入流-InputStream" class="headerlink" title="字节输入流[InputStream]"></a>字节输入流[InputStream]</h2><p><code>java.io.InputStream</code>抽象类表示字节输入流的所有类的超类，可以读取字节信息到内存中，它定义了字节输入流的基本共性方法。</p>
<ul>
<li><code>public void close()</code>：关闭输入流及其关联的系统资源</li>
<li><code>public abstract int read()</code>：从输入流读取数据的下一个字节。</li>
<li><code>public int read(byte []b)</code>：从输入读取一些字节数，并将他们存储到字节数组b中。</br><br>小例子：</li>
</ul>
<pre><code>    public classTestInputStream {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
        //每次读取完指针都会往后移动一位
        /*System.out.println(fis.read());
        System.out.println(fis.read());
        System.out.println(fis.read());*/

        /*
            (len = fis.read())!=-1
                1.fis.read();读取一个字节
                2.len = fis.read();把读取到的字节赋值给变量len
                3.len != -1 的时候进入循环
         */
        int len = 0;
        while ((len = fis.read())!=-1){
            System.out.print((char) len + &quot; &quot;);
        }

        //如果变成
        /*while(fis.read()!=-1){
            System.out.print(len + &quot; &quot;);
        }

        则会输出 98 -1；
        因为在判断的时候已经读了一位了，打印的时候往后挪一位，因此打印不出97和99
        */
        fis.close();
        /*byte []b =
        System.out.println(fis.read(b));*/
    }
}</code></pre><p>会输出文件中的 a b c</p>
<p>优化循环版</p>
<pre><code>byte []bytes = new byte[1024];
    int len = 0;
    while ((len = fis.read(bytes)) != -1) {
    // 每次读取后,把数组的有效字节部分，变成字符串打印
        System.out.println(new String(bytes,0,len));//len 每次读取的有效字节个数
    }
    fis.close();
}</code></pre><h3 id="练习文件复制"><a href="#练习文件复制" class="headerlink" title="练习文件复制"></a>练习文件复制</h3><pre><code>public class TestCopyFile {
    public static void main(String[] args) throws IOException {
        //1.创建一个字节输入流对象，构造方法中绑定要读取的数据流
        FileInputStream fis = new FileInputStream(&quot;C:\\1.jpg&quot;);
        //2，创建一个字节输出流，构造方法中绑定要写入的目的地
        FileOutputStream fos = new FileOutputStream(&quot;d:\\1.jpg&quot;);
        //使用数组缓冲读取多个字节，写入多个字节
        byte []bytes  = new  byte[1024];
        int len = 0;
        while ((len = fis.read(bytes))!=-1){
            fos.write(bytes,0,len);
        }
        fos.close();
        fis.close();
    }
}</code></pre><blockquote>
<p>Tips：流先开后关，后开先关</p>
</blockquote>
<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="Reader-字符输入流"><a href="#Reader-字符输入流" class="headerlink" title="Reader [字符输入流]"></a>Reader [字符输入流]</h2><h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><pre><code>java.io.Reader:字符输入流，是字符输入流的最顶层的父类，
    定义了一些共性的成员方法，是一个抽象类

    共性成员方法：
        int read() 读取一个字符并返回；
        int read(char []c) 一次读取多个字符，将字符读入数组
        close() 关闭字符输入流的资源

    java.io.FileReader extends InputStreamReader extends Reader
    FileReader：文件字符输入流
    作用：把硬盘的文件的数据以字符的方式读取到内存中

    构造方法:
        FileReader(String fileName)
        FileReader(File file)
        参数：读取文件的数据源
            String fileName:文件的路径
            File file:一个文件
        FileReader构造方法的作用：
            1.创建一个FileReader对象
            2.把FileReader对象指向要读取的文件


public class TestReader {
    public static void main(String[] args) throws IOException {
        //1.创建FileReader对象，构造方法中绑定要读取的数据源
        FileReader fr = new FileReader(&quot;b.txt&quot;);
        //2.使用FileReader对象中的方法read读取文件
        //int read()读取单个字符
        /*int len = 0;
        while ((len = fr.read())!= -1){
            System.out.print((char)len);
        }*/
        //一次多个字符
        char[] chars = new char[1024];
        int len = 0;
        while ((len = fr.read(chars))!= -1){
            System.out.println(new String(chars,0,len));
        }
        fr.close();
    }
}</code></pre><h2 id="Writer-字符输出流"><a href="#Writer-字符输出流" class="headerlink" title="Writer [字符输出流]"></a>Writer [字符输出流]</h2><h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><pre><code>/*
    java.io.Writer:字符输出流，是所有字符输出流的最顶层的父类，是一个抽象类

    共性的成员方法：
        void write(int c) 写入单个字符。
        void write(char [] c) 写入字符数组
        abstract void write (char []c,int off,int len)写入字符数组的某一部分，off数组的开始索引。len写的字符个数。
        void write(String str)写入字符串
        void write(String str,int off, int len)写入字符串的某一部分,off,len与上同理
        void flush()刷新该流的缓冲。
        void close()关闭流。

    java.io.FileWriter extends OutputStreamWriter extends Writer
*/
public class TestWriter {
    public static void main(String[] args) throws IOException {

        //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地
        FileWriter fw = new FileWriter(&quot;d.txt&quot;);
        //2.使用FileWriter中的方法write，-&gt;把数据写入到内存的缓冲区中&lt;-(字符转换为字节的过程)
        fw.write(97);
        //3.使用fileWrite中的flush方法，把内存缓冲区的数据，刷新到文件中
        fw.flush();
        //4.释放资源
        fw.close();
    }
}</code></pre><p>我们也可以用一个数组批量的写入数据</p>
<pre><code>public class TestWriter02 {
    public static void main(String[] args) throws IOException {
        FileWriter fw2 = new  FileWriter(&quot;f.txt&quot;);
        char []cs = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;};
        fw2.write(cs);
        fw2.close();
    }
}</code></pre><p>在<code>f.txt</code>中会有abcde</p>
<h2 id="IO-异常处理"><a href="#IO-异常处理" class="headerlink" title="IO 异常处理"></a>IO 异常处理</h2><blockquote>
<p><strong>JDK7</strong>以前的处理方法</p>
</blockquote>
<pre><code>/*
    jdk1.7之前，try catch finally处理流中的异常
    格式：
        try{
            可能回产出异常的代码
        }catch(异常类变量 文件名){
            异常的处理逻辑
        }finally{
            一定会指定的代码
            资源释放
        }
*/
public class TestTryCatch {
    public static void main(String[] args){
        //提高变量fw的作用域
        FileWriter fw = null;
        try{
            //可能会产生异常的代码
            fw = new FileWriter(&quot;w:/g.txt&quot;,true);
            for (int i = 0; i &lt; 10;i++){
                fw.write(&quot;Hello World&quot;+ i +&quot;\r\n&quot;);
            }
            fw.close();
        }catch (IOException e){
            //异常的处理逻辑
            System.out.println(e);
        }finally {
            //一定会执行的代码
            //创建对象失败了，fw的默认值是null，null是不能调用方法的，会抛出NullPointerException，需要增加一个判断，不是null在把资源释放掉
            if (fw != null) {
                try {
                    //fw.close()方法声明抛出了IOException异常对象，所以我们就处理这个异常对象，要么throws要么try/catch
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre><blockquote>
<p>然鹅在<strong>JDK9</strong>的改进可以在try中创建对象被传入的对象无需手动close</p>
</blockquote>
<pre><code>改进前格式：
public class HandleException2 {
    public static void main(String[] args) {
    // 创建流对象
    try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) {
    // 写出数据
    fw.write(&quot;黑马程序员&quot;); //黑马程序员
    } catch (IOException e) {
    e.printStackTrace();
        }
    }
}

改进后
// 被final修饰的对象
final Resource resource1 = new Resource(&quot;resource1&quot;);
// 普通对象
Resource resource2 = new Resource(&quot;resource2&quot;);
// 引入方式：直接引入
try (resource1; resource2) {
// 使用对象
}</code></pre><h2 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>java.io.Properties</code>继承于<code>Hashtable</code>,来表示一个持久的属性集。它使用键值对结构储存数据，每个键及其对应的字符串都是一个字符串(那就不用写泛型了hhhh)。该类经常被Java类使用，比如获取系统属性时，<code>System.getProperties</code>方法就是返回一个<code>Properties</code>对象。</p>
<h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public properties()</code>:创建一个空的属性列表</li>
</ul>
<h4 id="基本储存方法"><a href="#基本储存方法" class="headerlink" title="基本储存方法"></a>基本储存方法</h4><ul>
<li><p><code>public Object setProperty(String key ,String value)</code>：保存一对属性。</p>
</li>
<li><p><code>public String getProperty(String key)</code>：使用此属性列表中指定的键搜索属性值。</p>
</li>
<li><p><code>public Set&lt;String&gt; stringPropertyNames()</code>:所有键的名称的集合。</p>
<p>  public class TestProperties {</p>
<pre><code>public static void main(String[] args) {
    show01();
}

private static void show01(){
    //创建Properties集合对象
    Properties prop = new Properties();
    //使用setProperty往里面添加元素
    prop.setProperty(&quot;zwz&quot;,&quot;175&quot;);
    prop.setProperty(&quot;hxm&quot;,&quot;147&quot;);
    prop.setProperty(&quot;yhx&quot;,&quot;160&quot;);

    //使用StringPropertyName把Properties集合中的键取出，存放在set集合中;
    Set&lt;String&gt; set = prop.stringPropertyNames();
    //遍历set集合，取出Properties集合的每一个键
    for (String key : set){
        //使用getProperty王法通过key获取value
        String value = prop.getProperty(key);
        System.out.println(key + &quot;=&quot;+ value);
    }
}</code></pre><p>  }</p>
</li>
</ul>
<p>输出结果会是</p>
<pre><code>hxm=147
zwz=175
yhx=160</code></pre><h4 id="在Property集合中于流相关的操作"><a href="#在Property集合中于流相关的操作" class="headerlink" title="在Property集合中于流相关的操作"></a>在Property集合中于流相关的操作</h4><p><code>public void load(InputStream inStream)</code>：从字节输入流中读取键值对</p>
<pre><code>public class TestProperties03 {
    public static void main(String[] args) throws IOException {
        show03();
    }
    /*
        可以使用Properties集合中的load方法，把硬盘中保存的文件(键值对)，读取到集合中使用
        void load(InputStream inStream)
        void load(Reader reader)
        参数：
            InputStream inStream:字节输入流，不能读取含有中文的键值对
            Reader reader：字符输入流，读取含有中文的键值对
        使用步骤：
            1.创建Properties对象
            2.使用Properties的load方法，保存键值对文件
            3.遍历Properties集合


    */
    public static void show03() throws IOException {
        //1.创建Properties对象
        Properties p = new Properties();
        //2.使用Properties的load方法，保存键值对文件
        p.load(new FileReader(&quot;prop.txt&quot;));
        //3.遍历Properties集合
        Set&lt;String&gt; set = p.stringPropertyNames();
        for (String key : set){
            String value = p.getProperty(key);
            System.out.println(key + &quot;=&quot; + value);
        }
    }
}</code></pre><hr>
<h1 id="缓冲流，转换流，序列化流"><a href="#缓冲流，转换流，序列化流" class="headerlink" title="缓冲流，转换流，序列化流"></a>缓冲流，转换流，序列化流</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>缓冲流：可以高效读写</li>
<li>转换流：可以转换编码方式</li>
<li>序列化流：可以持久存储对象</li>
</ol>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流是对四个基本的FileXXX流的增强，所以也是四个流：</p>
<ul>
<li><p>字符缓冲流<code>BufferedInputStream</code>,<code>BufferedOutputStream</code></p>
</li>
<li><p>字符缓冲流：<code>BufferedRead</code>,<code>BufferedWritter</code></p>
</li>
<li><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。<br>##字节缓冲流<br>###构造方法</p>
<p>  //创建字节缓冲输入流<br>  BufferedInputStream bis = new BufferedInputStream(new FileInputStrem(“xxx.txt”));<br>  //创建字节缓冲输出流<br>  BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(“xxx.txt”));</p>
</li>
</ul>
<p>比较一下复制文件的效率</br><br>此处是未使用</p>
<pre><code>public class TestCopyFile {
    public static void main(String[] args) throws IOException {
        long start = System.currentTimeMillis();
        //1.创建一个字节输入流对象，构造方法中绑定要读取的数据流
        FileInputStream fis = new FileInputStream(&quot;e:\\我们的回忆.rar&quot;);
        //2，创建一个字节输出流，构造方法中绑定要写入的目的地
        FileOutputStream fos = new FileOutputStream(&quot;d:\\我们的回忆.rar&quot;);
        //使用数组缓冲读取多个字节，写入多个字节
        byte []bytes  = new  byte[1024];
        int len = 0;
        while ((len = fis.read(bytes))!=-1){
            fos.write(bytes,0,len);
        }
        fos.close();
        fis.close();
        long end = System.currentTimeMillis();
        System.out.println(&quot;未用缓冲流所用的时间：&quot;+(end - start)+&quot;ms&quot;);
    }
}</code></pre><p>耗时</p>
<pre><code>未用缓冲流所用的时间：3810ms</code></pre><p>此处是使用了</p>
<pre><code>public class TestCopyFile02 {
    public static void main(String[] args) throws IOException {
        long start = System.currentTimeMillis();
        FileOutputStream fos = new  FileOutputStream(&quot;d:/1.jpg&quot;);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        FileInputStream fis = new FileInputStream(&quot;c:/1.jpg&quot;);
        BufferedInputStream bis = new BufferedInputStream(fis);

        int len = 0;
        byte []bytes = new byte[1024];
        while ((len = bis.read(bytes))!=-1){
            bos.write(bytes,0,len);
        }

        bis.close();
        bos.close();
        long end = System.currentTimeMillis();
        System.out.println(&quot;用缓冲流所用的时间：&quot;+(end - start)+&quot;ms&quot;);
    }</code></pre><p>结果</p>
<pre><code>用缓冲流所用的时间：47ms</code></pre><p>特有的方法</p>
<ul>
<li>BufferedReader:<code>public String readLine()</code>：读一行文字</li>
<li>BufferedWriter:<code>public void newLine()</code>：写一行行分隔符，由系统属性定义符号。<blockquote>
<p>(windows: \r\n Linux:\n Mac:\r)</p>
</blockquote>
</li>
</ul>
<h3 id="练习文本排序"><a href="#练习文本排序" class="headerlink" title="练习文本排序"></a>练习文本排序</h3><pre><code>public class TestFileSort {
    public static void main(String[] args) throws IOException {
        //1.创建一个HashMap对象，可以key存储每行的序号(1,2,3,...);value:存储每行文本
        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();
        //2.创建字符缓冲输入流对象，构造方法中绑定字符输入流
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        // 3.创建字符缓冲输出流对象，构造方法中绑定字符输出流
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));
        //4.使用字符缓冲输入流中的方法readline，逐行读取
        String line;
        while((line = br.readLine())!=null){
            //5.对读取到的文本进行切割，获得行中序号和文本内容
            String []arr = line.split(&quot;\\.&quot;);
            //6.把切割好的序号和文本的内容存储到HashMap中(key序号是有序的，会自动排序)
            map.put(arr[0],arr[1]);
        }

        //7.遍历HashMap
        for (String key:map.keySet()){
            String value = map.get(key);
            //8.把每一个键值对，拼接成文本行
            line = key + &quot;.&quot; + value;
            //9.把拼接好的文本，使用字符缓冲输出流中的方法write，写到文件中
            bw.write(line);
            bw.newLine();//换行
        }
        bw.close();
        br.close();
    }
}</code></pre><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h3><p><strong>字符编码</strong></br><br>计算机中存储的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则。将字符存储到计算机中，成为编码。反之，将储存在计算机中的二进制数按某种规则解析显示出来，称为解码。</p>
<p><strong>字符集</strong></br></p>
<ul>
<li>字符集：也叫编码表，是一个系统支持的所有字符的集合。包括各国文字、标点符号、图形符号、数字等。</li>
</ul>
<p>常见的字符集有ASCII字符集、GBK字符集、Unicode字符集等等……<br><img src="https://i.loli.net/2020/06/26/yIg8HsWpFKETXuj.png" alt="1593171632_1_.jpg"><br>三种字符集就不赘述了。</p>
<h3 id="编码的问题"><a href="#编码的问题" class="headerlink" title="编码的问题"></a>编码的问题</h3><p>在IDEA里面，<code>FileReader</code>读取文本文件，因为IDEA是默认以 utf-8的格式编码，Windows默认以GBK编码，所以读取会有乱码，那么怎么读呢？看下一小节。</p>
<p>###InputStreamReader类<br>转换流<code>Java.io.InputStreamReader</code>的超类是Reader，是字节流到字符流的桥梁，它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台默认的字符集。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>InputStreamReader(InputStream in)：创建一个使用默认字符集的字符流。</li>
<li>InputStreamReader(InputStream in，String charsetName)：创建一个指定字符集的字符流。</li>
</ul>
<h4 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h4><pre><code>public class TestInputStreamReader {
    public static void main(String[] args) throws IOException{
        read_utf_8();
    }

    private static void read_utf_8() throws IOException {
        //1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称
        //如果不按照编码格式解码会出现乱码
        //InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;utf_8.txt&quot;),&quot;GBK&quot;);
        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;utf_8.txt&quot;),&quot;utf-8&quot;);
        int len;
        while ((len = isr.read())!=-1){
            System.out.print((char)len);
        }
        isr.close();
    }
}</code></pre><p>同理写入的时候也这样的</p>
<pre><code>public class TesrOutputStreamWriter {
    public static void main(String[] args) throws IOException {
        write_utf_8();
    }

    private static void write_utf_8() throws IOException {
        //1.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称
        //如果按照GBK格式写入文件，那么在IDEA中打开会是乱码
        //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;utf_8.txt&quot;),&quot;GBK&quot;);
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;utf_8.txt&quot;));
        //2.使用OutputStreamWriter对象中的write方法，把字符转换为字节存储缓冲区中(编码)
        osw.write(&quot;你好&quot;);
        osw.flush();
        osw.close();
    }
}</code></pre><p><img src="https://i.loli.net/2020/06/26/nwzoXIcQiOqSlKP.png" alt="1593174877_1_.jpg"></p>
<h4 id="练习：转换文件编码"><a href="#练习：转换文件编码" class="headerlink" title="练习：转换文件编码"></a>练习：转换文件编码</h4><pre><code>public class TestChangeCode {
    public static void main(String[] args) throws IOException {
        //1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表GBK
        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;我是GBK格式的文本.txt&quot;), &quot;GBK&quot;);
        //2.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表UTF-8
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;我是utf-8格式的文件&quot;));
        //3.使用InputStreamReader对象中的read方法读取文件
        int len;
        while ((len = isr.read())!=-1){
            osw.write(len);
        }
        //释放资源
        osw.close();
        isr.close();
    }
}</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Java提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该(对象的数据)、(对象的类型)、(对象中存储的属性)。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。</p>
<p><img src="https://i.loli.net/2020/06/26/BLc2FpPtQMCKY8f.png" alt="1593175730_1_.jpg"></p>
<h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p>java.io.ObjectOutputStream类，将Java对象的初始数据类型写到文件中，实现持久储存</p>
<p><strong>序列化操作</strong></p>
<ol>
<li><p>想要序列化，必须满足两个条件：</p>
<ul>
<li><p>该类(必须必须必须！！！)实现<code>java.io.Serializable</code>接口，<code>Serializable</code>是一个标记接口，不实现此接口的类将不会使用任何状态的序列化或反序列化，会抛出<code>NotSerializableException</code>. </p>
</li>
<li><p>该类的所有属性必须是可序列化的。如果有一个属性不需要序列化。则必须用<code>transient</code>(瞬态)关键字修饰</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/06/26/fYXEjicyDTv1VOU.png" alt="1593177870_1_.png"></p>
<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>####反序列操作1<br>    /*<br>     使用步骤：<br>        1.创建ObjectInputStream对象<br>        2.使用ObjectInputStream对象的方法，readObject()读取保存对象的文件<br>        3.释放资源<br>        4.使用读取的对象(打印)</p>
<pre><code>*/
public class TestObjectInputStream {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //1.创建ObjectInputStream对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));
        //2.使用ObjectInputStream对象的方法，readObject()读取保存对象的文件
        Object o = ois.readObject();
        //3.释放资源
        ois.close();
        //4.运用
        System.out.println(o);
    }
}</code></pre><p>对于JVM可以反序列化的对象，他必须是能够找到class文件的类。如果找不到.class文件，会抛出一个<code>ClassNotFoundException</code>异常。</p>
<p>####反序列操作2<br>当JVM反序列化对象时，能找到.class文件，但是.class文件在序列化对象之后发生了修改，那么反序列化操作也会失败。会抛出<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li>
<li>该类包含位置数据类型</li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code>接口给需要序列化的类，提供一个版本的序列化。<code>SerialVersionUID</code>该版本号的目的在于验证序列化的对象和对应的类是否版本匹配。</p>
<h4 id="训练：序列化集合"><a href="#训练：序列化集合" class="headerlink" title="训练：序列化集合"></a>训练：序列化集合</h4><pre><code>/*
    练习，序列化集合
        当我们想在文件中保存多个对象的时候
        可以把多个对象存储到一个集合中
        对集合进行序列化于反序列化
    分析：
        1.定义一个Person对象的ArrayList集合
        2.往ArrayList集合中存储Person对象
        3.创建一个序列化流ObjectOutputStream对象
        4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化
        5.创建一个反序列化ObjectInputStream对象
        6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
        7.把Object类型转换为ArrayList类型
        8.遍历ArrayList
        9.释放资源
*/
public class TestSerializedCollection {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //1.定义一个Person对象的ArrayList集合
        ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;();
        //2.往ArrayList集合中存储Person对象
        list.add(new Person(&quot;曾炜圳&quot;,18));
        list.add(new Person(&quot;黄雪蔓&quot;,18));
        list.add(new Person(&quot;姚海霞&quot;,20));
        //3.创建一个序列化流ObjectOutputStream对象
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;序列化对象.txt&quot;));
        //4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化
        oos.writeObject(list);
        //5.创建一个反序列化ObjectInputStream对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;序列化对象.txt&quot;));
        //6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
        Object o = ois.readObject();
        //7.把Object类型转换为ArrayList类型
        ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)(o);
        //8.遍历ArrayList
        for (Person person : list2) {
            System.out.println(person);
        }
        //9.释放资源
        ois.close();
        oos.close();
    }
}</code></pre><blockquote>
<p>Person类中有相应的name，age，get，set方法以及toString方法</p>
</blockquote>
<p>##打印流<br>###概述<br>平时我们控制台打印输出。调用<code>print</code>方法和<code>println</code>方法完成的这两个方法都来源于java.io.PrintStream类，该类能够方便打印各种数据类型的值。</p>
<p>###PrintStream类<br>####构造方法</p>
<ul>
<li><p>public PrintStream(String fileName)：使用指定的文件名创建一个打印流。<br>举栗子：</p>
<p>  PrintStream ps = new PrintStream(“ps.txt”);</p>
</li>
</ul>
<h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><pre><code>public class TestPrintStream{
    public static void main(String[] args)throws IOException{
        //调用系统的打印流，在控制台直接输出97
        System.out.println(97);

        //创建打印流，指定文件的名称
        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);

        //设置系统的打印流流向，输出到ps.txt中
        System.setOut(ps);
        //调用系统的打印流,ps.txt中输出97
        System.out.println(97);
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Html-css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Html-css/" class="post-title-link" itemprop="url">Html-css</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-07 17:54:28" itemprop="dateModified" datetime="2020-03-07T17:54:28+08:00">2020-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Html-CSS"><a href="#Html-CSS" class="headerlink" title="Html/CSS"></a>Html/CSS</h1><p>这个语法是真的简单，web开发都可以学一学喔！</p>
<hr>
<h3 id="先介绍一下Html吧"><a href="#先介绍一下Html吧" class="headerlink" title="先介绍一下Html吧"></a>先介绍一下Html吧</h3><p>主要框架可以不记得。VM或者Vscode都可以打一个英文字符的感叹号<code>!</code>然后回车实现框架。<br/></p>
<ol>
<li>title标签之间可以改网页的名字。</li>
<li>head标签之内可以加入CSS样式或者js代码</li>
<li>body标签是网页”身体”里面可以布局，写内容，可以写js</li>
</ol>
<h3 id="再介绍一下HTML的标签吧"><a href="#再介绍一下HTML的标签吧" class="headerlink" title="再介绍一下HTML的标签吧"></a>再介绍一下HTML的标签吧</h3><ul>
<li>h1~h6 标题</li>
<li>br 段内换行</li>
<li>span 段内分组</li>
<li>p 段落标签</li>
<li>pre 预留格式</li>
<li>hr 水平线</li>
<li>a 超链接 (可以链接本地电脑的其他网站、其他站点、或者虚拟超链接#)</li>
<li>img 图片标签</li>
<li>div 区域</li>
<li>ul 无序列表</li>
<li>ol 有序列表</li>
<li>li 列表，嵌套于ul ol中</li>
<li>table 表格</li>
<li>tr 行</li>
<li>td 列 嵌套于tr中</li>
<li>th 表头单元格 嵌套于tr中</li>
<li>form 表单</li>
<li>input type=”” value=”” (type里面的值有 text文本 password 密码 submit 确定 reset  重置 radio 单选框 checkbox 多选框)(value输入中文就可以显示文字了)</li>
<li>select option 标签用于下弹的框</li>
<li>textarea 文本域</li>
<li>em\strong 斜体/强调 均无语意 嵌套于p中</li>
<li>dl/dt/dd 自定义列表/列表项/描述 嵌套于dl中<blockquote>
<p>光看是学不会的，主要要多敲！</p>
</blockquote>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="CSS的样式添加方式"><a href="#CSS的样式添加方式" class="headerlink" title="CSS的样式添加方式"></a>CSS的样式添加方式</h3></li>
</ul>
<ol>
<li>CSS可以行内添加(如<code>&lt;p width=&quot;300px&quot;&gt;</code>等)</li>
<li>内嵌样式(在head标签之间加入style标签，写进style里面)</li>
<li>外部引用(用 <strong>link标签引入</strong> 写比较大的页面的时候用这个可以方便维护)。</li>
</ol>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ol>
<li>标签选择器(<code>h1{font-size:20px</code>)</li>
<li>类别选择器(<code>.one{font-size:10px} &lt;p class=&quot;one&quot;</code>&gt;)</li>
<li>ID选择器(<code>#one{font-size:12px} &lt;p id=&quot;one&quot;&gt;</code>)</li>
</ol>
<h3 id="CSS文字样式"><a href="#CSS文字样式" class="headerlink" title="CSS文字样式"></a>CSS文字样式</h3><ol>
<li>px (像素)</li>
<li>em（字符，自适应用户所用字体）</li>
<li>% (百分比）</li>
</ol>
<h3 id="CSS颜色"><a href="#CSS颜色" class="headerlink" title="CSS颜色"></a>CSS颜色</h3><ol>
<li>red…（直接输入颜色名）</li>
<li>rbg(x1,x2,x3,x4) (x4为透明度)</li>
<li>rgb(x%,x%,x%) (百分比值)</li>
</ol>
<h3 id="CSS常用标签"><a href="#CSS常用标签" class="headerlink" title="CSS常用标签"></a>CSS常用标签</h3><blockquote>
<p>由于太多了就列一点常用的吧</p>
</blockquote>
<ol>
<li>color (颜色)</li>
<li>text-align (对齐) (center\left\right\justify)</li>
<li>line-height (行高) (居中一般与当前的框架高的相同)</li>
<li>text-decoration (装饰线)（none\underline\overline\line-through）</li>
<li>float（浮动)（left\right…）</li>
<li>padding (内边距) (px)</li>
<li>margin (外边距) (a,b,c,d)（上\右\下\左）</li>
<li>vertical-align （属性设置元素的垂直对齐方式）</li>
<li>transform（2D/3D 转换）</li>
<li>overflow (超出边框时的操作) (hidden\auto…)</li>
<li>transition (动画效果持续时长) (.s 多少s)</li>
<li>border (边框) （solid #xxx）</li>
<li>position (规定元素的定位类型) （absolute..）</li>
<li>display (显示) (none/block…)<blockquote>
<p>能力有限就这为止吧哈哈哈</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">HashMap底层实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-09 21:21:20" itemprop="dateModified" datetime="2020-06-09T21:21:20+08:00">2020-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><p>HashMap底层实现采用了哈希表，是非常重要的数据结构。(redis数据库的核心技术和HashMap一样),因此，很重要。</p>
<p>数据结构由数组和链表来实现对数据的存储，各有特点</br></p>
<ol>
<li>数组：占用空间连续。寻址容易，查询速度快。但是，增删的效率低</br></li>
<li>链表：占用空间不连续，寻址困难查询速度慢，但是增删的效率很高</li>
</ol>
<p>那么哈希表就是集合数组与链表于一身的存在(查询快，增删也快)；</p>
<h3 id="HashMap基本结构"><a href="#HashMap基本结构" class="headerlink" title="HashMap基本结构"></a>HashMap基本结构</h3><p>哈希表的基本结构是”数组+链表”。<br>打开HashMap源码，发现有俩个核心的内容：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495618960152437.png" alt=""><br>其中的Entry[] table 就是HashMap的核心数组结构，我们称之为”位桶数组”。Entry源码<br><img src="https://i.loli.net/2020/06/09/jZwnPI9vJB6oXkH.png" alt="HashMap底层源码之一.png"></p>
<blockquote>
<p>Node即是Entry(实现了Map.Entry接口)</p>
</blockquote>
<p>一个Entry对象储存了：</br></p>
<ol>
<li>key键对象value：值对象</br></li>
<li>next：下一个节点</br></li>
<li>hash：键对象的hash值</br><br>很显然每一个Entry对象是一个单向链表结构，就犹如：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619082593896.png" alt=""><br>然后，Node[]数组的结构，也是HashMap的结构</li>
</ol>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619119905721.png" alt=""></p>
<blockquote>
<p>意思就是把链表嵌入数组中这样既有了数组的查询快的优点 亦有了链表增删快的优点。</p>
</blockquote>
<h4 id="储存数据过程put-key-value"><a href="#储存数据过程put-key-value" class="headerlink" title="储存数据过程put(key,value)"></a>储存数据过程put(key,value)</h4><p>明白了HashMap的基本结构后，了解HashMap如何储存数据的。此处的核心是如何产生Hash值，该值用了对应数组的储存位置。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619181777762.png" alt=""></p>
<p>目的是要把”key - value两个对象”成对存放到HashMap的Node[]数组中</p>
<ol>
<li><p>获得key对象的hashcode，调用key对象的hashcode()方法获得hashcode。</p>
</li>
<li><p>根据hashcode计算出hash值(要求在[0，length-1]区间,减少”hash冲突”)</p>
<ul>
<li><p>一种极端简单且低下的算法是：hash值 = hashcode/hashcode;</p>
<blockquote>
<p>也就是说hash为1。键值对对象都会储存在数组索引为1的位置，这样跟一个链表没什么区别了。</p>
</blockquote>
</li>
<li><p>一种简单常用的算法(相除取余算法)：hash值 = hashcode%数组长度</p>
<blockquote>
<p>这种算法可以让hash值均匀的分布在[0，数组长度-1]的区间。早期的HashTable就是采用这种算法。但是这种算法用了”除法”，效率低下。JDK后来改进了算法。首先约定数组的长度必须为2的整数幂，这样采用位运算可以实现取余的效果：hash值 = hashcode&amp;(数组长度-1)。 </p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>事实上为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)(JDK牛逼)！<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619395858263.png" alt=""></p>
<ol start="3">
<li>生成Node对象</br><br>就跟上面一样，一个Node对象包含四部分：key对象，value对象，next对象，hash值。(next对象用于指向下一个Node对象的引用)。现在算出了hash值。下一个Entry对象的引用为null。</li>
</ol>
<p>4.将Node对象对应的数组索引位置还没有放Node对象，则直接将Node对象储存进数组；如果对应索引位置有Node对象，则将已有的Node对象的next指向本Node对象，形成链表。</p>
<h3 id="总结如上"><a href="#总结如上" class="headerlink" title="总结如上"></a>总结如上</h3><p>当添加一个元素(key - value)时，首先计算key的hash值，以此确定插入数组中的位置，但是存在同一hash值的元素，已经被放进看同一数组位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一个位置，就形成了链表，同一个链表上的Hash值是相同的，所以说数组的存放方式是链表。JDK8中，当链表长度大于8时，链表就转换成了红黑树，从而又提高了查找效率。</p>
<h3 id="取数据的过程get-key"><a href="#取数据的过程get-key" class="headerlink" title="取数据的过程get(key)"></a>取数据的过程get(key)</h3><p>我门需要通过key对象来获取”键值对”对象，进而返回value对象。明白了储存数据过程，取数就比较简单了</p>
<p>1）获得key的hashcode，通过hash()散列算法算得hash值，进而定位到数组的位置。</br><br>2)在链表上一个个去比较key对象，调用equals()方法，将key对象和链表上所有节点的key对象进行比较，直到碰到返回true的节点对象为止。</br><br>3）返回equals()为true的节点对象的value对象。</p>
<p>明白存取数据的过程，我们再看一下hashcode()和equals方法的关系：</br><br>Java中规定，两个内容相同(equals()为true)的对象必须有相同的hashcode。因为如果equals()为true而两个对象的hashcode不同；那在整个储存过程中就产生了悖论。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>HashMao的位桶数组，初始化大小16。实际使用时候，显然大小是可变的。如果位桶数组中的元素达到(0.75*数组 length)，重新调整数组大小变成了原来的二倍</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Git/" class="post-title-link" itemprop="url">Git</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-12 21:52:26" itemprop="dateModified" datetime="2020-04-12T21:52:26+08:00">2020-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
</blockquote>
<blockquote>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
</blockquote>
<blockquote>
<p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
</blockquote>
<h3 id="版本控制工具的功能"><a href="#版本控制工具的功能" class="headerlink" title="版本控制工具的功能"></a>版本控制工具的功能</h3><ul>
<li>协同修改<ul>
<li>多人并行不悖的修改服务端的同一个文件</li>
</ul>
</li>
<li>数据备份<ul>
<li>不仅保存目录和文件的当前状态，还能够保存每一个提交的历史状态。</li>
</ul>
</li>
<li>版本管理<ul>
<li>在保存每一个版本文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。在这方面SVN采用的是增量式管理的方式，而Git采取了文件系统快照的方式</li>
</ul>
</li>
<li>权限控制<ul>
<li>对团队中参与开发的人员进行权限控制。</li>
<li>对团队外开发贡献的代码进行审核 ——Git独有</li>
</ul>
</li>
<li>历史记录<ul>
<li>查看修改人，修改时间，修改内容，日志信息。</li>
<li>将本地文件恢复到某一个历史状态。</li>
</ul>
</li>
<li>分支管理<ul>
<li>允许开发团队在文件过程中多条生产线同时推进任务，进一步提高效率。<h3 id="Git优点"><a href="#Git优点" class="headerlink" title="Git优点"></a>Git优点</h3></li>
</ul>
</li>
</ul>
<ol>
<li>大部分操作在本地完成，不需要联网。</li>
<li>完整性保证。</li>
<li>尽可能添加数据而不是删除或修改数据</li>
<li>分支操作非常快捷</li>
<li>与Linux命令全面兼容</li>
</ol>
<h3 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h3><p>一般流程如下：</p>
<ul>
<li>克隆Git资源为工作目录。</li>
<li>在克隆的资源上添加或修改文件</li>
<li>如果其他人修改了，你可以更新资源</li>
<li>在提交前查看修改</li>
<li>提交修改</li>
<li>在修改完成后发现错，可以撤回提交并再次修改并提交。<br><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png" alt=""></li>
</ul>
<h3 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h3><p>工作区：就是你在电脑里面可以看到的目录。<br>暂存区：英文名叫stage或者index。一般存放在 .git 目录下的index文件(.git/index)中，所以我们把暂存区有时也叫做索引(index)。<br>版本库：工作区有个隐藏目录 .git，这个不算工作区，耳式Git的版本库。<br><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt=""></p>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>是多功能命令，根据目标文件的状态不同，命令效果也不同</br><br>1）. 可以用它跟踪新文件</br><br>2）. 把已经跟踪的文件放进暂存区</br><br>3）. 还能用于合并时把有冲突的文件标记为已解决状态等</br><br>如图：add把工作区的文件加入了暂存区。</p>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>git commit主要是将在暂存区里的改动提交到本地的版本库。每次使用git commit都会产生40位的哈希值，这个哈希值也叫commit-id.</br><br>commit-id在版本回退时候很有用搭配reset可以进行版本的进退。</p>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>git reset [选项] [commit-id]有三个选项可以选择 –soft、–mixed、–hard</p>
<ol>
<li>git reset –soft仅将head指针指向历史版本。</li>
<li>git reset –mixed将head指针指向历史版本，且用历史版本的暂存区覆盖当前的暂存区</li>
<li>git reset –hard将head指针指向历史版本，同时覆盖工作区和暂存区的内容(比较危险，慎用)</li>
</ol>
<h4 id="git-checkout-git-checkout-lt-file-gt"><a href="#git-checkout-git-checkout-lt-file-gt" class="headerlink" title="git checkout / git checkout &lt;-file&gt;"></a>git checkout / git checkout &lt;-file&gt;</h4><p>git checkout或checkout – <file> 会将暂存区全部或指定的文件替换工作区的文件，这个操作很危险，会清除工作区中未添加到暂存区的改动。</p>
<h4 id="git-rm-–cached"><a href="#git-rm-–cached" class="headerlink" title="git rm –cached"></a>git rm –cached</h4><p>执行<code>git rm --cached</code>命令的时候会直接从暂存区删除文件，工作区则不会做出改变。</p>
<h4 id="git-checkout-HEAD-git-checkout-HEAD"><a href="#git-checkout-HEAD-git-checkout-HEAD" class="headerlink" title="git checkout HEAD / git checkout HEAD "></a>git checkout HEAD / git checkout HEAD <file></h4><p>当执行<code>git checkout HEAD</code>或者<code>git checkout Head &lt;file&gt;</code>时候，会用HEAD指向master分支中的全部或部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区未提交的改动。</p>
<h3 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h3><ol>
<li><p><strong>git init</strong>来初始化一个仓库，Git的很多指令都需要在Git的仓库中运行，所以git init是使用Git的第一个命令。执行完git init后会出现一个<code>.git</code>隐藏目录。在当前目录下git bash 输入<code>ls lA</code>(Linux通用)即可出现。</p>
</li>
<li><p><strong>git clone</strong>可以从现有Git仓库中拷贝项目</br><br>格式一般为git clone <repo> <directory></p>
<ul>
<li><p>repo:Git 仓库。</p>
</li>
<li><p>directory:本地目录。<br>例子：比如克隆Ruby语言的Git代码仓库Grit，使用以下命令</p>
<p><code>git clone git://github.com/schacon/grit.git</code></p>
</li>
</ul>
</li>
</ol>
<p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</br><br>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<pre><code>`git clone git://github.com schacon/grit.git mygrit`</code></pre><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>可以查看在上次提交之后是否有修改。</p>
<pre><code>$ git status
On branch master

Initial commit

Changes to be committed:
  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)

    new file:   README
    new file:   hello.php</code></pre><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>执行git diff来查看执行git status的结果的详细信息<br>git diff命令显示已写入缓存与已修改但未写入缓存的改动的区别。git diff有两个主要的应用场景</p>
<ul>
<li>尚未缓存的改动：<strong>git diff</strong></li>
<li>查看已缓存的改动：<strong>git diff –cached</strong></li>
<li>查看已缓存的与未缓存的所有改动：<strong>git diff HEAD</strong></li>
<li>显示摘要而非整个diff：<strong>git diff –stat</strong></li>
</ul>
<h4 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h4><p>git mv命令用于移动或者重命名一个文件、目录、软连接。<br>例如重命名：$ git mv [原文件名] [修改后文件名]</p>
<h3 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><p>几乎每一个版本控制系统都以某种形式支持分支。使用分支就意味着可以从开发主线上分离开，不影响主线继续工作。创建分支：</p>
<pre><code>`git branch (branchname)`</code></pre><p>切换分支命令：</p>
<pre><code>`git checkout (branchname)`</code></pre><p>当切换分支的时候，Git会用该分支最后提交的快照替换你的工作目录内容，所有多个分支不需要多个目录。</p>
<p>合并分支命令：</p>
<pre><code>`git merge`</code></pre><p>你可以多次合并到一分支，也可以选择在合并之后直接删除被并入的分支。</p>
<h3 id="Git-分支管理-1"><a href="#Git-分支管理-1" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><h4 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h4><p>列出分支基本命令:</p>
<pre><code>`git branch`</code></pre><p>没有参数时，git branch会列出你在本地的分支。</p>
<pre><code>$ git branch
* master</code></pre><p>这里是说我们有个叫做master的分支，并且该分支还是当前分支。在git init之后会默认创建master分支。</br><br>我们通过git checkout(branch)修改到我们需要切换的分支</p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>删除分支命令：</p>
<pre><code>`git branch -d (branchname)`</code></pre><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>分支合并命令：</p>
<pre><code>`git merge`</code></pre><h3 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h3><p>在使用Git提交若干更新之后，又或者克隆了某个项目，想回顾一下提交历史，我们可以使用git log命令查看。</p>
<ul>
<li>git log –oneline可以看历史记录的简介版本</li>
<li>还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项</li>
<li>可以用 –reverse 参数来逆向显示所有日志</li>
<li>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分</li>
<li>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</li>
</ul>
<h3 id="Git-查看提交历史-1"><a href="#Git-查看提交历史-1" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h3><p>在使用了Git提交若干更新后，或克隆了某个项目，想回顾下提交历史，我们可以用git log命令查看</p>
<pre><code>git log</code></pre><p>可以回顾历史版本</p>
<pre><code>git log --oneline</code></pre><p>可以来查看历史记录的简介的版本。</p>
<pre><code>git log --reverse</code></pre><p>可以用 –reverse参数来逆向显示所有日志。</p>
<pre><code>git log --author</code></pre><p>可以查找指定用户的提交日志例如</p>
<pre><code>git log --author=zwz --oneline</code></pre><p>可以查找zwz提交的简单版本的日志。</p>
<p>如果要指定日期，还可以执行几个选项<code>--since</code>和<code>--before</code>,也可以用<code>--until</code>和<code>--after</code>。</p>
<pre><code>git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges</code></pre><p>可以看三周前且在四月十八日之后的所有提交。</p>
<p>###Git 标签<br>如果达到了一个重要的阶段，并希望永远记住那个特别的快照，你可以使用git tag给它打上标签。比如说，我们想为项目发布一个版本”1.0”版本。于是可以使用git tag -a v1.0命令给最新一个提交打上(HEAD)”v1.0”的标签</p>
<p>-a选项一样为创建一个带注解的标签.不用-a选项也可以执行的，但他不会记录这标签什么时候打的，谁打的，也不会让你添加个标签的注解</p>
<pre><code>git tag -a v1.0</code></pre><p>当执行git tag -a命令时，Git会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样，当我们执行<code>git log --decorate</code>时就可以看到我们的标签了。</p>
<p>如果忘记给某个提交打标签了，又将他发布了，我们可以给它追加标签。</p>
<pre><code>git tag -a v0.9 hash_id</code></pre><p>指定标签信息命令：</p>
<pre><code>git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></pre><p>PGP签名标签命令：</p>
<pre><code>git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></pre><h3 id="Git-amp-Github"><a href="#Git-amp-Github" class="headerlink" title="Git&amp;Github"></a>Git&amp;Github</h3><h4 id="为创建远程库地址别名"><a href="#为创建远程库地址别名" class="headerlink" title="为创建远程库地址别名"></a>为创建远程库地址别名</h4><pre><code>git remote -v</code></pre><p>可以查看当前所有远程地址的别名</p>
<pre><code>git remote add [别名] [远程地址(就是GitHub的地址)]</code></pre><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><pre><code>git push [别名] [分支名]</code></pre><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><pre><code>git clone [远程地址]</code></pre><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><ul>
<li>pull =fetch+merge </li>
<li>git fetch [远程库地址别名] [远程分支名]</li>
<li>git merge [远程库地址别名/远程分支名]</li>
<li>git pull [远程库地址别名] [远程分支名]</li>
</ul>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>要点</p>
<ol>
<li>如果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取</li>
<li>拉取下来后如果进入冲突状态,则按照分支冲突解决操作即可</li>
</ol>
<h4 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h4><p>在GitHub里面别人的项目右上角点击fork</p>
<h4 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h4><ol>
<li>机内当前用户的目录<code>$ cd~</code></li>
<li>删除.ssh目录 <code>$ rm -rvf .ssh</code></li>
<li>运行命令生成.ssh密钥目录 <code>$ ssh-keygen -t rsa -C 595488485@qq.com</code></li>
<li>进入.ssh目录查看文件列表<code>$ cd .ssh</code> <code>$ls -lF</code></li>
<li>查看id_rsa.pub文件内容<code>$ cat id_rsa.pub</code></li>
<li>复制id_rsa.pub文件内容，登录GitHub，点击头像用户→Setting→SSH and GPG keys</li>
<li>New SSH Key</li>
<li>输入复制的密钥信息</li>
<li>回到Git bush 创建远程地址别名<code>git remote add origin_ssh [地址在SSH里面clone]</code></li>
<li>推送文件测试.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/File&%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/File&%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">File&递归</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-16 18:52:36" itemprop="dateModified" datetime="2020-07-16T18:52:36+08:00">2020-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="File类、递归"><a href="#File类、递归" class="headerlink" title="File类、递归"></a>File类、递归</h1><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>java.io.File</code>类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public File(String pathname)</code>：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的File实例。</li>
<li><code>public File(String parent, String child)</code>：从<strong>父路径名字符串和子路径名字符串</strong>创建新的File实例。</li>
</ul>
<p>举例子：</p>
<pre><code>/*
    路径：
        绝对路径：完整的路径
            以盘符(C:  D: ...)开始的路径
                c:\\1.txt
        相对路径：是一个简化的路径
            相对指的是相对于当前项目的根目录
            如果使用当前项目的根目录，路径可以简化书写

        注意：
            1.路径是不区分大小写
            2.路径中的文件名称分隔符windows用反斜杠，反斜杠是转义字符。两个反斜杠代表一个反斜杠
*/
public class Demo02FilePath {
    public static void main(String[] args) {
        /*
            File类的构造方法
        */
        show01();
        show02(&quot;c:\\&quot;,&quot;a.txt&quot;);//c:\a.txt
        show02(&quot;d:\\&quot;,&quot;a.txt&quot;);//d:\a.txt
        show03();
    }
    /*
        File(File parent, String child)根据parent抽象路径名和chile路径名字符串创建一个新File实例
        参数：把路径分为两部部分
            File parent:父路径
            String child：子路径
        好处：
            父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径可以变化
            父路径是File类型，可以使用File的方法对路径进行一些操作，再使用路径创建对象
    */
    private static void show03() {
        File parent = new File(&quot;c:\\&quot;);
        File file1 = new File(parent,&quot;hhh&quot;);
        System.out.println(file1);
    }

    /*
        File(String parent,String child) 根据parent 路径名字字符串和 child 路径名字符串创建一个新 File 实例
        参数：把路径分成了两部分
        String parent：父路径
        String child：子路径
        好处：
            父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径可以变化
    */
    private static void show02(String parent,String child) {
        File file = new File(parent,child);
        System.out.println(file);//c:\a.txt
    }

    /*
        File(String pathname)通过将给定路径名字符串转换为抽象路径名来创建一个新File实例
        参数：
            String pathname：字符串的路径名称
            路径名称可以是以文件皆为，也可以是以文件夹结尾
            路径可以是相对路径，也可以是绝对路径
            路径可以存在，也可以是不存在
            创建File对象，只是把字符串路径封装成File对象，不考虑路径的真假情况
    */
    private static void show01() {
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        System.out.println(f1);//重写了Object类的toString方法

        File f2 = new File(&quot;b.txt&quot;);
        System.out.println(f2);
    }
}</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul>
<li><code>public String getAbsolutePath()</code>; 返回此File的绝对路径名字符串</li>
<li><code>public String getPath()</code>; 将此File转换为路径名字符串</li>
<li><code>public String getName()</code>; 返回由此File表示的文件或目录的名称。</li>
<li><code>public long length()</code> ;返回由此File表示的文件的长度</li>
</ul>
<p>演示</p>
<pre><code>public class Demo03FileMethods {
    public static void main(String[] args) {
        show01();
        show02();
        show03();
        show04();
    }
    /*
        public long length() ;返回由此File表示的文件的长度
        获取的是构造方法指定的文件的大小，以字节为单位
        注意：
            文件夹是没有大小概念的，不能获取文件夹的大小
            如果构造方法中给出的路径不存在，那么length方法返回0;
    */
    private static void show04() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\1.jpg&quot;);
        long length = f1.length();
        System.out.println(length);
    }

    /*
        public String getName(); 返回由此File表示的文件或目录的名称。
        获取的就是构造方法传递路径结尾的部分(文件/文件夹)
    */
    private static void show03() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        File f2 = new File(&quot;C:\\java练习\\File&quot;);
        System.out.println(f1.getName());
        System.out.println(f2.getName());
    }

    /*
         public String getPath(); 将此File转换为路径名字符串
         获取构造方法中的路径
    */
    private static void show02() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        File f2 = new File(&quot;a.txt&quot;);
        System.out.println(f1.getPath());
        System.out.println(f2.getPath());

        System.out.println(f1); //默认调用toString方法，toString方法调用getPath()方法
    }

    /*
        public String getAbsolutePath(); 返回此File的绝对路径名字符串.
        获取构造方法中传递的路径
        无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径
    */
    private static void show01() {
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        String absolutePath1 = f1.getAbsolutePath();
        System.out.println(absolutePath1);

        File f2 = new File(&quot;a.txt&quot;);
        System.out.println(f2.getAbsolutePath());
    }
}</code></pre><p>输出结果</p>
<pre><code>C:\java练习\File\a.txt
C:\java练习\File\a.txt
-----------------------
C:\java练习\File\a.txt
a.txt
C:\java练习\File\a.txt
-----------------------
a.txt
File
-----------------------
3149546</code></pre><blockquote>
<p>API中说明:length(),表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便携的路径，开发常用。</li>
</ul>
<hr>
<pre><code>public class FilePath{
    public static void main(String[] args){
        //D盘下的bbb.java文件
        File f = new File(&quot;D:\\bbb.java&quot;);
        System.out.println(f.getAbsolutePath());

        //项目下的bbb.java文件
        File f2 = new File(&quot;bbb.java&quot;);
        System.out.println(f.getAbsolutePath());
    }
}

输出结果：
D:\bbb.java
D:\C:\java练习\File\bbb.java</code></pre><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li>public boolean exists():此File类表示的文件或目录是否实际存在。</li>
<li>public boolean isDirectory():此File表示的是否为目录。</li>
<li>public boolean isFile():此File表示的是否为文件。</li>
</ul>
<p>方法演示。</p>
<pre><code>public class Demo04FileExists {
    public static void main(String[] args) {
        show01();
        show02();
    }
    /*
        public boolean isDirectory() : 此File表示的是否为目录
            用于判断构造方法中给定的路径是否以文件夹结尾
                是：true
                否：false
        public boolean isFile():此File表示的是否为文件。
            用于判断构造方法中给定的路径是否以文件结尾
                是：true
                否：false
        注意：
            电脑的硬盘中只有文件或者文件夹，两个方法是互斥的
            这两个方法使用前提，路径必须存在，否则都返回false
    */
    private static void show02() {
        System.out.println(&quot;-------------show02----------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\src\\Demo01\\File&quot;);
        System.out.println(f1.isDirectory());
        System.out.println(f1.isFile());
    }

    /*
        public boolean exists():此File类表示的文件或目录是否实际存在。
        用于判断构造方法中的路径是否存在
            存在:true
            不存在：false
    */
    private static void show01() {
        System.out.println(&quot;-------------show01----------------&quot;);
        File f1 = new File(&quot;C:\\&quot;);
        System.out.println(f1.exists());

        File f2 = new File(&quot;f:\\&quot;);
        System.out.println(f2.exists());

        File f3 = new File(&quot;a.txt&quot;);
        System.out.println(f3.exists());
    }
}</code></pre><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li>public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时候，创建一个新的空文件。</li>
<li>public boolean delete():删除由此File表示的文件或目录。</li>
<li>public boolean mkdir():创建由此File表示的目录。</li>
<li>public boolean mkdirs():创建由此File表示的目录，包括任何必须但不存在的父目录。</li>
</ul>
<p>方法演示</p>
<pre><code>public class Demo05FileCreateAndDelete {
    public static void main(String[] args) throws IOException{
        show01();
        show02();
        show03();
    }
    /*
         public boolean delete():删除由此File表示的文件或目录。
         此方法，可以删除构造方法路径中给出的文件/文件夹
         返回值：布尔值
            true：文件/文件夹删除成功 返回true
            false：文件夹中有内容，不会删除 返回false；构造方法中路径不存在false
         注意：
            delete方法是直接在硬盘删除文件和文件夹，不走回收站，删除须谨慎

    */
    private static void show03() {
        System.out.println(&quot;-------------show03-------------&quot;);
        File f2 = new File(&quot;C:\\java练习\\File\\11\\22\\33\\4.txt&quot;);
        boolean b1 = f2.delete();
        System.out.println(b1);
    }

    /*
        public boolean mkdir():创建单级文件夹
        public boolean mkdirs():既可以创建单级也可以创建多级
        返回值:布尔值
            true：文件夹不存在，创建文件夹，返回true
            false：文件夹不存在，不会创建，返回false；构造方法中给出的路径不存在返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常
    */
    private static void show02() {
        System.out.println(&quot;-------------show02-------------&quot;);
        File f1 = new File(&quot;aaa.txt&quot;);
        boolean b1 = f1.mkdir();
        System.out.println(b1);

        File f2 = new File(&quot;11\\22\\33\\4.txt&quot;);
        boolean b2 = f2.mkdirs();
        System.out.println(b2);
    }

    /*
        public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时候，创建一个新的空文件。
        创建文件的路径和名称在构造方法中给出(构造方法的参数)
        返回值:布尔值
            true：文件不存在，创建文件，返回true
            false：文件存在，不会创建，返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常

        public boolean createNewFile() throws IOException
        该方法会抛出异常
    */
    private static void show01() throws IOException {
        System.out.println(&quot;-------------show01-------------&quot;);
        File f1 = new File(&quot;1.txt&quot;);
        boolean b1 = f1.createNewFile();
        System.out.println(b1);
    }
}</code></pre><blockquote>
<p>API中说明:delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><ul>
<li>public String[] List():返回一个String数组，表示该File目录中的所有子文件或目录</li>
<li>public File[] listFiles():返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
<p>方法</p>
<pre><code>/*
注意：
    List方法和listFiles方法遍历的是构造方法中给出的目录
    如果构造方法中给出的目录的路径不存在，会抛出空指针异常
    如果构造方法中给出的路径不是一个目录，也会抛出空指针异常
*/
public class Demo06FileList {
    public static void main(String[] args) {
        Show01();
        Show02();
    }
    /*
        - public File[] listFiles():返回一个File数组，表示该File目录中的所有的子文件或目录。
        遍历构造方法中给出的目录，会获得目录中所有文件/文件夹的名称,把文件/文件夹封装成File对象，多个File对象存储到File数组中
    */
    private static void Show02() {
        File file = new File(&quot;C:\\java练习\\File&quot;);
        File[] files = file.listFiles();
        for (File f : files){
            System.out.println(f);
        }
    }

    /*
        - public String[] List():返回一个String数组，表示该File目录中的所有子文件或目录
        遍历构造方法中给出的目录，会获得目录中所有文件/文件夹的名称，把多个名称存储到一个字符串String类型的数组

    */
    private static void Show01() {
        File file = new File(&quot;C:\\java练习\\File&quot;);
        String[] list = file.list();
        for (String s : list){
            System.out.println(s);
        }

    }
}</code></pre><blockquote>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历哦。</p>
</blockquote>
<p>#递归</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>递归：方法自己调用自己</p>
<ul>
<li><p>递归分类：</p>
<pre><code>- 直接递归成为方法自己调用自己
- 间接递归可以A方法屌用B方法，B方法调用C方法，C方法调用A方法</code></pre></li>
<li><p>注意事项：</p>
<pre><code>- 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</code></pre><ul>
<li>递归虽然有限制条件，但是递归次数不能太多，不然也会发撒哼栈内存溢出</li>
<li>构造方法禁止递归！</li>
</ul>
</li>
<li><p>递归的使用前提：当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归</p>
<pre><code>public class Recursive {
    public static void main(String[] args) {
    a(1);
}

private static void a(int i) {
    System.out.println(i);
    if (i==20000){
        return;
    }
    a(++i);
}</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>运行该代码会使栈空间爆满，以至于抛出栈溢出异常</p>
</blockquote>
<h2 id="递归累加求和"><a href="#递归累加求和" class="headerlink" title="递归累加求和"></a>递归累加求和</h2><pre><code>/*
    练习：
        使用递归计算1-n之间的和
*/
public class Demo02Recursive {
    public static void main(String[] args) {
        int s =sum(3);
        System.out.println(s);
    }
    /*
        定义一个方法，使用递归计算1-n之间的和
        1+2+3+...+n
        n + (n-1) + (n-2)+...+1
        已知：
            最大值：n
            最小值：1
        使用递归必须明确：
            1，递归的结束条件
                获取到1的时候结束
            2.递归的目的
                获取下一个被加的数字(n-1)
    */
    private static int sum(int n) {

        if (n==1){
            return 1;
        }
        //获取下一个被加的数字(n-1)
        return n+sum(n-1);
    }
}</code></pre><p><img src="https://i.loli.net/2020/07/15/SoduBbYEKMtrwqA.png" alt="1594785660_1_.jpg"></p>
<blockquote>
<p>该图是计算1加到3的算法 </p>
<p>一开始调用方法入栈，然后递归继续入栈，接着当条件符合的时候弹栈输出结果，即，sum(3-1)是2 sum(2-1)是1</p>
</blockquote>
<h2 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h2><pre><code>/*
    练习：
        使用递归计算阶乘
        n的阶乘：n! = n*(n-1)*(n-2)*...*3*2*1
        5的阶乘：5! = 5*(5-1)*(5-2)*...*(5-4)
*/
public class Demo03Recursive {
    public static void main(String[] args) {
        int a = fact(-10);
        System.out.println(a);
    }
    /*
        定义方法使用递归计算阶乘
        5的阶乘：5! = 5*(5-1)*(5-2)*...*(5-4)
    */
    private static int fact(int n) {
        if (n == 1){
            return 1;
        }
        else if (n &lt; 0){
            System.out.println(&quot;fail&quot;);
            return -1;
        }
        else
            return n*fact(n-1);
    }
}</code></pre><h2 id="打印多级目录"><a href="#打印多级目录" class="headerlink" title="打印多级目录"></a>打印多级目录</h2><pre><code>/*
    练习：
        递归打印多级目录
    需求：
        遍历c:\\java练习文件夹，及其子文件夹
*/
public class Demo04Recursive {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历

    */
    public static void getAllFile(File dir){
        System.out.println(dir);
        File[] files = dir.listFiles();
        for (File f : files){
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()){
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            }else
                //f是一个文件，直接打印
                System.out.println(f);
        }
    }
}    </code></pre><p><img src="https://i.loli.net/2020/07/15/Y2GSzAmCjlcD71w.png" alt="1594791605_1_.jpg"></p>
<blockquote>
<p>图与代码不太相符，原理一样</p>
</blockquote>
<p>#综合案例</p>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><pre><code>/*
    练习：
        递归打印多级目录
    需求：
        遍历c:\\java练习文件夹，及其子文件夹
        只要.java结尾的文件
*/
public class Demo05Recursive {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历

    */
    public static void getAllFile(File dir){
        //System.out.println(dir);
        File[] files = dir.listFiles();
        for (File f : files){
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()){
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            }else{
                /*
                //f是一个文件，直接打印
                *//*
                    只要.java结尾的文件
                    1.把File对象f转换为字符串对象
                *//*
                //String name = f.getName();//转换为字符串
                //String path = f.getPath();
                String string = f.toString();

                //把字符串，转换为小写
                s = string.toLowerCase();

                //  2.调用String类中的方法endWith判断字符串是否是以.java结尾
                boolean b = string.endsWith(&quot;.java&quot;);

                //  3.如果是以.java结尾的文件，则输出就行
                if (b == true){
                System.out.println(f);
                */
                if (f.getName().toLowerCase().endsWith(&quot;.java&quot;)){
                    System.out.println(f);
                }
            }
        }
    }
}</code></pre><blockquote>
<p><code>/**/</code>在这里面的代码是最原始，正常人的思想，后面简版是改进后的</p>
</blockquote>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code>作为参数，接口中只有一个方法。</p>
<p><code>boolean accept(File pathname)</code>：测试pathname是否应该包含当前File目录中，符合返回true，过滤掉则返回false，保留规则：</p>
<ol>
<li>要么是.java文件。</li>
<li>要么是目录用于继续遍历。</li>
</ol>
<p>通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印</p>
<p><img src="https://i.loli.net/2020/07/16/MPAh5sxQuVvwFU8.png" alt="1594872854_1_.jpg"></p>
<p>实现代码</p>
<pre><code>public class Demo02Filter {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    public static void getAllFile(File dir) {
        //传递过滤器对象 使用匿名内部类 FileFilter方法
        /*File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File pathname) {
                //过滤规则，pathname是文件夹，或是.java结尾的文件返回true
                return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(&quot;.java&quot;);
            }
        });*/

        /*File [] files = dir.listFiles(new FilenameFilter() {
            //传递过滤器对象 使用匿名内部类 FileFilter方法 FilenameFilter方法
            @Override
            public boolean accept(File dir, String name) {
                return new File(dir,name).isDirectory() || name.toLowerCase().endsWith(&quot;.java&quot;);
            }
        });*/

        //传递过滤器对象 使用匿名内部类 FileFilter方法 Lambda表达式
        File [] files = dir.listFiles((dir1, name) -&gt; new File(dir1,name).isDirectory() || name.toLowerCase().endsWith(&quot;.java&quot;));

        for (File f : files) {
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()) {
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            } else {
                if (f.getName().toLowerCase().endsWith(&quot;.java&quot;)) {
                    System.out.println(f);
                }
            }
        }
    }
}</code></pre><blockquote>
<p>ps：IDEA里面写了匿名内部类的方法可以变成Lambda表达式不用自己写hhh</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
