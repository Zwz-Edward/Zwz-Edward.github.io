<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZWZ的博客嘻嘻">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-07 12:12:36" itemprop="dateModified" datetime="2020-07-07T12:12:36+08:00">2020-07-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程-amp-同步"><a href="#线程-amp-同步" class="headerlink" title="线程&amp;同步"></a>线程&amp;同步</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><p>一开始我们写的程序都是只有一条线程在占用 CPU 即 main(主)线程。如：</p>
<pre><code>/*
    主线程：执行主(main)方法的线程

    单线程程序：java程序中中只有一个线程
    执行从main方法开始，从上到下依次执行

    JVM执行main方法，main方法会进入到栈内存
    JVM会找操作系统开辟一条main方法通向CPU的执行路径
    CPU就可以通过这个路径来执行main方法
    而该路径有个名字叫做main(主)线程

*/
public class TestThread {
    public static void main(String[] args) {
        Person s = new Person(&quot;曾炜圳&quot;);
        s.run();

        Person s1 = new Person(&quot;黄雪蔓&quot;);
        s1.run();
    }
}</code></pre><blockquote>
<p>Person里面有对应的set，get方法。以及相应的run方法和构造方法</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><hr>
<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>
<p><img src="http://m.qpic.cn/psc?/V1330WLB2ZBOB6/.GvYSzOiitXBn4c048fBdVfnLcQfAW*9TCoZEMW8qqkXq8J0wn5vM*raZqQDS*G4APLepQic9cYmq2KBe6pBQA!!/mnull&bo=BAP.AgAAAAARB8s!&rf=photolist&t=5" alt=""></p>
<p>当执行的线程任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>public Thread():分配一个新的线程对象。</li>
<li>public Thread(String name):分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target):分配一个带有指定目标新的线程对象。</li>
<li>public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li>public String getName():获得当前线程的名字</li>
<li>public void start():导致此线程开始执行，Java虚拟机调用此线程的run方法。</li>
<li>public void run():此线程要执行的任务在此处定义代码。</li>
<li>public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停(暂停停止执行)。</li>
<li>public static Thread currentThread():返回正在执行的线程对象的引用。</li>
</ul>
<blockquote>
<p>翻阅API文档可抑制创建线程方式就两种：一种是继承Thread类方式，一种是实现Runnable接口方式。接下来分析Runnable接口方式</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码，程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也与预期一样，就说线程安全的。</p>
<p>我们通过一个案例，演示线程的安全问题：</p>
<pre><code>/*
    实现卖票案例
*/
public class RunnableImplements02 implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        //先判断票是否存在
        while (true) {
            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                ticket--;
            }
        }
    }
}


public class TestThreadSafe {
    public static void main(String[] args) {
        //创建一个Runnable接口的实现类对象
        RunnableImplements02 r = new RunnableImplements02();
        //创建一个Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread t0 = new Thread(r);
        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);

        t1.start();
        t0.start();
        t2.start();
    }
}    </code></pre><p>会出现了</p>
<pre><code>Thread-0--&gt;正在卖第100张票
Thread-2--&gt;正在卖第100张票
Thread-1--&gt;正在卖第100张票
Thread-1--&gt;正在卖第97张票
Thread-2--&gt;正在卖第97张票
Thread-0--&gt;正在卖第97张票
...</code></pre><p>如下是图解：</p>
<hr>
<blockquote>
<p>多线程执行run方法遇到的问题</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/28/YsFigBZl2nDSpxu.png" alt="1593352976_1_.jpg"></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当我们使用多个线程访问同一资源的时候，而且多线程对资源有写的操作，就容易出现线程安全问题。</p>
<p>要解决上述问题并发访问同一个资源的安全性问题：也就是解决重复票与不存在票的问题，Java提供了同步机制(synchronized)来解决</p>
<p>为了保证每个线程都能正常执行原子操作Java引入了线程同步机制。那么怎么去使用呢？有三种方法完成同步操作。</p>
<ol>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制</li>
</ol>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li>同步代码块：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只是岁这个区块的资源实行互斥访问.</li>
</ul>
<p>格式:</p>
<pre><code>synchronized(同步锁){
    需要同步操作的代码
}</code></pre><p>同步锁：</p>
<p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。<br>    1. 锁对象可以是任意类型。<br>    2. 多个线程对象，需要同一把锁。</p>
<blockquote>
<p>注意：在任何时候，只允许一个线程拥有同步锁，谁拿到锁谁就可以进入代码块。其他的线程只能等着，即(BLOCKED)状态。</p>
</blockquote>
<pre><code>/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的一种方案：使用同步代码块
    格式
        synchronized(锁对象){
            可能会出现线程安全问题的代码(访问了共享数据的代码)
        }
    注意：
        1.通过代码块中的锁对象，可以使用任意的对象
        2.必须保证多个线程使用的锁对象是同一个
        3.锁对象作用：
            把同步代码块锁住，只让一个线程在同步代码块中执行
*/
public class RunnableImpl implements Runnable                                                           {
        //定义一个多个线程共享的票源
        private int ticket = 100;

        //创建一个锁对象
        Object obj = new Object();

        //设置线程任务：卖票
        @Override
        public void run() {
            //先判断票是否存在
            while (true) {
                //创建一个同步代码块
                synchronized (obj){
                    if (ticket &gt; 0) {
                        //提高安全问题出现的概率，让程序睡眠
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        //票存在,卖票 ticket--
                        System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                        ticket--;
                    }
                }
            }
        }
    }</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><p>从而就不会出现票为负或者同一票被多线程同时卖出了</p>
<blockquote>
<p>同步代码块运行的原理</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/29/JC3mKRZbAwdf9lV.png" alt="1593407072_1_.jpg"></p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul>
<li>同步方法:使用synchronized修饰的方法，就叫做同步方法。保证A线程执行该方法的时候，其他线程只能在方法外等着</li>
</ul>
<p>格式是：</p>
<pre><code>public synchronized void method(){
    可能会产生线程安全问题的代码
}</code></pre><blockquote>
<p>同步锁是谁？<br>对于非static方法，同步锁就是this。<br>对于static方法，我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<p>使用同步方法代码如下：</p>
<pre><code>/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的第二种方案：使用同步方法
    使用步骤:
        1.把访问了共享数据的代码抽取出来，放到一个方法中
        2.在方法上添加一个synchronize修饰符

    格式：定义方法的格式
    修饰符 synchronize 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码(访问了共享数据的代码)
    }
*/
public class RunnableImpl implements Runnable {
        //定义一个多个线程共享的票源
        private int ticket = 100;

        //创建一个锁对象
        Object obj = new Object();

        //设置线程任务：卖票
        @Override
        public void run () {
            System.out.println(&quot;this:&quot; + this);
            //先判断票是否存在
            while (true) {
                payTicket();
            }
        }


        /*
            定义一个同步方法
            同步方法也会把方法内部的代码锁住
            只让一个线程执行
            同步方法的锁对象是谁？
            就是实现类对象 new RunnableImpl()
            也就是this
        */
        public synchronized void payTicket(){
            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                ticket--;
            }
        }
}</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        System.out.println(&quot;run：&quot; + run);
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。</p>
<p>Lock锁也叫做同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code>：加同步锁</li>
<li><code>public void unlock()</code>：释放锁</li>
</ul>
<p>使用方法如下：</p>
<pre><code>import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的三种方案：使用lock锁
    java.util.concurrent.locks
    lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁对操作。
    Lock接口中的方法:
        void lock()获取锁
        void unlock()释放锁
    java.util.concurrent.locks.ReentrantLock implements Lock接口

    使用步骤：
        1.在成员位置创建一个ReentrantLock对象
        2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
        3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁

*/
public class RunnableImpl implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //1.在成员位置创建一个ReentrantLock对象
    Lock l = new ReentrantLock();

    //设置线程任务：卖票
    @Override
    public void run() {
        System.out.println(&quot;this:&quot; + this);
        //先判断票是否存在
        while (true) {
            //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
            l.lock();

            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                    //票存在,卖票 ticket--
                    System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                    ticket--;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
                    l.unlock();//无论程序是否异常都会把锁释放
                }
            }
        }
    }</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        System.out.println(&quot;run：&quot; + run);
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><blockquote>
<p>线程的状态</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/29/CAv8iy34BNsPajh.png" alt="1593433469_1_.jpg"></p>
<ul>
<li>NEW 至今尚未启动的线程处于这种状态。</li>
<li>RUNNABLE 正在Java JVM中执行的线程处于这种状态</li>
<li>BLOCKED受阻塞并等待某一个监视器锁的线程处于这种状态。</li>
<li>WAITING 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</li>
<li>TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。</li>
<li>TERMINATED 已退出的线程处于这种状态。</li>
</ul>
<p>阻塞状态：具有CPU的执行资格，等待CPU空闲时执行。<br>休眠状态：放弃CPU的执行资格，CPU空闲也不执行。</p>
<p>通过<code>new Thread()</code>或者<code>new Thread子类</code>获得一个新建的线程。通过<code>start()</code>方法会使线程进入<code>RUNNABLE</code>运行状态。如果<strong>CPU被占</strong><code>则会进入BLOCKED</code>阻塞状态。由于多个线程之间会互相抢夺CPU的执行时间。因此线程可能会进入<code>BLOCKED-&gt;RUNNABLE-&gt;BLOCKED...</code>阻塞运行相互转换的过程。当<code>run()</code>方法执行完后或者执行<code>stop()</code>方法。线程就会死亡，进入<code>TERMINATED</code>死亡状态。</p>
<p>在<code>RUNNABLE</code>状态下使用<code>sleep(long)\wait(long)</code>都会让线程进入<code>TIMED_WAITING</code>(休眠状态)当计时器结束。则会根据CPU的情况进入<code>BLOCKED</code>或者<code>RUNNABLE</code>状态。</p>
<p>在<code>RUNNABLE</code>状态下使用<code>Object.wait()</code>会使线程进入<code>WAITING</code>(无限等待状态) 通过<code>Object.notify()</code>根据CPU被占用情况进入<code>RUNNABLE\BLOCKED</code>状态。</p>
<blockquote>
<p><code>TIMED_WAITING\WAITING</code>两种状态均为冻结状态。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">方法与构造方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 22:19:20" itemprop="dateModified" datetime="2020-04-30T22:19:20+08:00">2020-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="方法与构造方法"><a href="#方法与构造方法" class="headerlink" title="方法与构造方法"></a>方法与构造方法</h1><p>我们常用的System.out.println()，是什么呢？</p>
<ul>
<li>println()是一个方法。</li>
<li>System是系统类。</li>
<li>out是标准输出对象。</li>
</ul>
<p>这句话的意思就是调用系统类System中的标准输出对象out中的方法println().</p>
<h2 id="那什么是方法呢？"><a href="#那什么是方法呢？" class="headerlink" title="那什么是方法呢？"></a>那什么是方法呢？</h2><p>Java方法是语句的集合，它们在一起执行一个功能。就像C的函数一样。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h2 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h2><ul>
<li>使程序变得更简短而清晰。</li>
<li>有利于维护程序</li>
<li>可以提高程序开发的效率</li>
<li>提高了代码的重用性</li>
</ul>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<pre><code>修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值；
}</code></pre><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需要的操作，但没有返回值。这种情况下，returnValueType 是关键字void。</li>
<li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>参数类型：参数像一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数，参数是可选的，方法可以不包含任何参数。</li>
<li>方法体：方法体包含具体的语句，定义该方法的功能。<br><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1220955916.jpg" alt=""></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E6%8C%BA%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E6%8C%BA%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">挺重要的控制字符串</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-24 15:58:58" itemprop="dateModified" datetime="2020-05-24T15:58:58+08:00">2020-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>class practiceContorlString {
    public static void main(String[] args) {
        //--------------------------------------------------------------------
        //给出一句英文句子： &quot;let there be light&quot;
        //得到一个新的字符串，每个单词的首字母都转换为大写
        String str6 = &quot;let there be light&quot;;
        String []str7 = str6.split(&quot; &quot;);
        String str8=&quot;&quot;;
        String str9=&quot;&quot;;
        for(int i=0;i&lt;str7.length;i++){
            str8 = str7[i].substring(0,1).toUpperCase()+str7[i].substring(1);
            str8 = str8 + &quot; &quot;;
            str9+=str8;
        }
        System.out.println(str9);
        // --------------------------------------------------------------------
        //英文绕口令
        //peter piper picked a peck of pickled peppers
        //统计这段绕口令有多少个以p开头的单词
        String str = &quot;peter piper picked a peck of pickled peppers&quot;;
        String []str1 = str.split(&quot; &quot;);
        int count = 0;
        for (String temp : str1){
            if (temp.charAt(0)==&apos;p&apos;)
                count++;
        }
        System.out.println(&quot;p次数：&quot; + count);
        //--------------------------------------------------------------------
        //Nature has given us that two ears, two eyes, and but one tongue, to the end that we should hear and see more than we speak
        //把最后一个two单词首字母大写
        String str2 = &quot;Nature has given us that two ears, two eyes, and but one tongue,&quot; +
                      &quot; to the end that we should hear and see more than we speak&quot;;
        char []arr =  str2.toCharArray();
        int index = str2.lastIndexOf(&quot;two&quot;);
        for (int i = index; i &lt; index+1;i++){
            int c = arr[i]-32;
            char c1 = (char)c;
            arr[i] = c1;
        }
        String str10 = String.valueOf(arr);
        System.out.println(str10);


        //--------------------------------------------------------------------
        //把 legendary 最后一个字母变大写
        String str3 = &quot;legendary&quot;;
        String str4 = str3.substring(0,str3.length()-1) +
                      str3.substring(str3.length()-1).toUpperCase();
        System.out.println(str4);
        //--------------------------------------------------------------------
        //把 lengendary 改成间隔大写小写模式，即 LeNgEnDaRy
        String str5 = &quot;legendary&quot;;
        char[] cs = str5.toCharArray();
        for (int i = 0;i&lt;str5.length();i++){
            if (i%2 == 0)
                cs[i] = Character.toUpperCase(cs[i]);
        }
        String c = String.valueOf(cs);
        System.out.println(c);

        //--------------------------------------------------------------------
    }

}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E5%88%9D%E5%AD%A6JS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E5%88%9D%E5%AD%A6JS/" class="post-title-link" itemprop="url">初学JS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-22 11:46:42" itemprop="dateModified" datetime="2020-03-22T11:46:42+08:00">2020-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="刚开始学JavaScript"><a href="#刚开始学JavaScript" class="headerlink" title="刚开始学JavaScript"></a>刚开始学JavaScript</h1><hr>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>“是一种脚本语言，主要用于Web。它用于增强HTML页面，通常可以嵌入HTML代码中。JavaScript是一种解释型语言。因此，它不需要编译。”</p>
</blockquote>
<br/>
简单来说:"根据用户做的一些操作，来修改页面的样式，属性等，叫做js。"(个人理解

<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>ECMAScript 解释器是JS的核心</li>
<li>DOM:Document Object Model（文档对象模型） 操作HTML文档 在JS里面就是document这个用处</li>
<li>BOM：Browser Object Model (浏览器对象模型)</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>类型：typeof运算符</br><br>常见的变量类型有：number,string,boolean,undefined,object,funtion</br><br>类型转换:</br><br>parseInt()、paarseFloat()</br><br><code>==</code>：先转换类型后比较</br><br><code>===</code>:不转换类型直接比较</br><br>NaN：不是一个数字</p>
<h4 id="运算符-基本语句……"><a href="#运算符-基本语句……" class="headerlink" title="运算符 基本语句……"></a>运算符 基本语句……</h4><p>语句大致跟C语言的一样的，可以参照C语言的语句</p>
<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>一个十分类似python的字典的东西 例如python里面用到的<code>for i in ..</code>语句在JS里面也可以运用，所以JS和python基本语法也是很类似的。</p>
<blockquote>
<p>json其实与python字典用法差不多<br>在json里面<code>var a={time:&#39;4am&#39;,person:&#39;zwz&#39;}</code> python里面<code>a={&#39;color&#39;:&#39;green&#39;,&#39;point&#39;:5}</code>就是键值对</p>
</blockquote>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>学完很惊讶的发现，数组的应用与python的列表神似呀!</br></p>
<p>添加/删除元素的方法</br><br>添加:1.push(元素)，从尾部添加           2.unshift(元素)从头部添加</br><br>删除:1.pop()，从尾部弹出 2.shift()，从为头部弹出</p>
<p>拼接</br><br>concat(数组2) 例如:concat</p>
<pre><code>`var a=[1,2,3]`
`var b=[4,5,6]`
`alert(a.concat(b))`</code></pre><p>会输出[1,2,3,4,5,6]</p>
<p>再例如：join</p>
<pre><code>`var a=[1,2,3,4];`
`alert(arr.join(&apos;-&apos;));`</code></pre><p>会输出 1-2-3-4 join里面的东西是什么都行</p>
<p>排序sort</p>
<pre><code>`var arr[&apos;c&apos;,&apos;b&apos;,&apos;z&apos;,&apos;a&apos;]`
`arr.sort()`
`alert(arr)`</code></pre><p>会输出a,b,c,z</p>
<p>在比较数字的时候例如</p>
<pre><code>`var arr[111,333,442,5,6]`
`arr.sort(function(n1, n2){
    return n1 - n2; )}`</code></pre><p>需要这么做才可以排序数字数组</p>
<blockquote>
<p>sort只能识别字符串</p>
</blockquote>
<p>splice的用法</p>
<pre><code>`arr=[1,2,3,4,5,6]`&lt;/br&gt;
`arr.splice(2,3)`&lt;/br&gt;
`alert(arr)`&lt;/br&gt;</code></pre><p>会出现1，2，6,从arr[2]→arr[5]都被删除了.可见用法删除：splice(起点，长度)</br></p>
<pre><code>`arr=[1,2,3,4,5,6]`&lt;/br&gt;
`arr.splice(2,0,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)`&lt;/br&gt;
`alert(arr)`&lt;/br&gt;</code></pre><p>会出现1，2，’a’’b’’c’，3，4，5，6，从arr[2]后面增加’a’,’b’,’c’三个元素.<br>用法插入：splice(起点，长度，元素…)</p>
<hr>
<p><code>document.getElementById()</code><br>可以在任何浏览器下使用，不会出现兼容性问题.</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>函数能传参，而且想传几个传几个。例如<code>function varName(a,b,c,..)</code></br><br>举多个栗子</br><br>script部分</p>
<p><code>function setColor(color) {
    var oDiv = document.getElementById(&#39;div1&#39;);</code></br><br>    <code>oDiv.style.background = color;
        }</code></br><br>body部分</p>
<pre><code>`&lt;input type=&quot;button&quot; value=&quot;变绿&quot; onclick=&quot;setColor(&apos;green&apos;)&quot;&gt;`
`&lt;input type=&quot;button&quot; value=&quot;变黄&quot; onclick=&quot;setColor(&apos;yellow&apos;)&gt;`
`&lt;input type=&quot;button&quot; value=&quot;变黑&quot; onclick=&quot;setColor(&apos;balck&apos;)&quot;&gt;`</code></pre><blockquote>
<p>函数其实就是个占位符 在函数里有定不下来的东西就可以用函数传参</p>
</blockquote>
<p>第二种方法<br>    <code>function setStyle(name, value)</code><br>    <code>{ var oDiv = document.getElementById(&#39;div1&#39;);</code><br>    <code>oDiv.style[name]=value}</code></p>
<p>body部分</p>
<pre><code>`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;width&apos;,&apos;400px&apos;)&quot;`
`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;height&apos;,&apos;400px&apos;)&quot;`
`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;color&apos;,&apos;green&apos;)&quot;`</code></pre><blockquote>
<p><code>.</code>能做的事<code>[]</code>都能做，反之而不一定。当要修改的属性不固定的时候常用例如这里的一会变颜色一会变宽高可以用这种方式传参</p>
</blockquote>
<p>PS.修改样式的时候比如运用<code>.style.</code>修改的是行间的样式但是<code>className</code>是直接添加class属性。由于行间样式优先级大于引用样式因此，在同一标签下先改.style的样式再改class的样式后者是显示不出来的。</p>
<h3 id="提取行间事件"><a href="#提取行间事件" class="headerlink" title="提取行间事件"></a>提取行间事件</h3><p>1.为元素添加事件。以onclick事件为例子</p>
<pre><code>`function 名字(){...;}`
`oBtn.onclick=名字`</code></pre><p>或者</p>
<pre><code>`oBtn.onclick=function(){...;}`</code></pre><blockquote>
<p>这两段代码需要在body里且在input标签下方才能执行。若script放进head里面就会报错，原因是js是一行一行读的，在head里面则会给未知的oBtn加一个onclick从而报错。</p>
</blockquote>
<p>此时window.onload出现了</p>
<pre><code>`window.onload = function(）{
        var oBtn = document.getElementById(&apos;btn1&apos;)
        oBtn.onclick = function() {
            alert(&apos;a&apos;);
        }
    }</code></pre><blockquote>
<p>window.onload的作用是加载完整个网页再进行js代码</p>
</blockquote>
<h3 id="获取一组元素"><a href="#获取一组元素" class="headerlink" title="获取一组元素"></a>获取一组元素</h3><pre><code>`getElementsByTagName`</code></pre><p>如过我们要给一堆且相同的标签添加样式的话，可以用循环实现比如说给div添加样式<br>可以用以下代码实现 </p>
<pre><code>`for(var i=0&apos;i&lt;aDiv.length;i++)`</code></pre><p>运用 <strong>this</strong> 来表示当前发生的元素</p>
<hr>

<pre><code>`oDiv.innerHTML = oTxt.value;`</code></pre><p>oTxt.value的值赋予了oDiv.innerHTML中<br>把它嵌套在<code>oBtn.onclick = function() {}</code>里面就可以点击button把text里的值赋予div。</p>
<blockquote>
<p>由于里面有HTML所以可以在里面运用html代码，即可以输入<code>&lt;h2&gt;标题&lt;h2/&gt;</code>这类代码，并实现。</p>
</blockquote>
<p>在语句中’+ something +’,’++’可以实现字符串的拼接；</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ol>
<li>可以使用<code>setInterval(var,time)</code>来进行无限次的且时隔time ms的间隔弹窗 使用clearInterval来关闭</li>
<li>使用<code>setTimeout(var,time)</code>来进行一次时隔time ms的弹窗 使用clearTimeout来关闭</li>
</ol>
<blockquote>
<p>可以进行无缝滚动或者移入移出弹框 很方便</p>
</blockquote>
<h3 id="DOM基础"><a href="#DOM基础" class="headerlink" title="DOM基础"></a>DOM基础</h3><p>childNodes 可以查询父节点下面的子节点有多少个 （其中包括文本节点和元素节点）<br></br><br>nodeType 可以显示节点的类型比如说：1.代表元素节点 2.代表属性节点 3.嗲表文本节点….</br><br>parentNode 可以获取父节点.<br>offsetParent 根据样式的不同会有不一样的显示<br>firstElementChild 获取第一个元素子节点</br><br>lastElementChild 获取最后一个元素子节点</br></p>
<h4 id="DOM方式操作元素属性"><a href="#DOM方式操作元素属性" class="headerlink" title="DOM方式操作元素属性"></a>DOM方式操作元素属性</h4><ul>
<li>获取：getAttribute (名称)</li>
<li>设置: setAttribute (名称，值)</li>
<li>删除：removeAttribute (名称)<blockquote>
<p>很少用到DOM来操作元素</p>
</blockquote>
</li>
</ul>
<h4 id="创建、插入和删除元素"><a href="#创建、插入和删除元素" class="headerlink" title="创建、插入和删除元素"></a>创建、插入和删除元素</h4><ul>
<li>创建DOM元素<ul>
<li>createElement(标签名) 创建一个节点<blockquote>
<p>需要利用appendChild加入 ，基本格式为父级.appendChild(子节点) 例子：</br><code>var oLi=document.createElement(&#39;li&#39;)</code></br><br><code>oUl.appendChild(oLi)</code></p>
</blockquote>
</li>
<li>appendChild(节点) 追加一个节点例子：为ul插入li.</li>
</ul>
</li>
<li>插入元素<br>  -insertBefore(节点，原有节点) 在已有元素的前面插入<blockquote>
<p>要把元素添加在前面则可以用这条语句，首先先把需要添加元素的父级中把子集全部选定出来，在使用该语句。例如：<br>  </br><code>var oLi = document.createElement(&#39;li&#39;);</code></br><br>   <code>var aLi = oUl.getElementsByTagName(&#39;li&#39;)</code><br>  <code>oUl.insertBefore(oLi, aLi[0])</code></p>
</blockquote>
</li>
<li>删除DOM元素<ul>
<li>removeChild(节点) 删除一个节点</li>
</ul>
</li>
</ul>
<h3 id="表格应用"><a href="#表格应用" class="headerlink" title="表格应用"></a>表格应用</h3><ul>
<li><p>获取</p>
<ul>
<li><p>tBodies、tHead、tFoot、rows、cells 用法<br><code>oTab.getElementsByTagName(&#39;tbody&#39;)[0]</code><br><code>.getElementsByTagName(&#39;tr&#39;)[1]</code><br><code>.getElementsByTagName(&#39;td&#39;)[1].innerHTML</code></br></p>
<p>  这个用法等同于</p>
<p>  <code>oTab.tBodies[0].rows[1].cells[1].innerHTML</code></p>
</li>
</ul>
</li>
<li><p>隔行变色</p>
<ul>
<li><code>for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++)</code></br><br><code>if (i % 2)</code></br>`{<pre><code>    oTab.tBodies[0].rows[i].style.background = &apos;#CCC&apos;;
} `&lt;/br&gt;</code></pre><code>else</code> </br><code>{oTab.tBodies[0].rows[i].style.background = &#39;&#39;}</code></li>
</ul>
</li>
</ul>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><h4 id="运动框架"><a href="#运动框架" class="headerlink" title="运动框架"></a>运动框架</h4><ul>
<li>在运动开始的时候，关闭已有的定时器</li>
<li>把运动和暂停隔开(if,else)</li>
</ul>
<blockquote>
<p>不好写emmm，看代码吧 &lt;运动1&gt; JS源代码里面看</p>
</blockquote>
<h4 id="多物体运动框架"><a href="#多物体运动框架" class="headerlink" title="多物体运动框架"></a>多物体运动框架</h4><ul>
<li>定时器作为物体的属性</li>
<li>并且在写多个物体运动的时候，变量是不可以公用的，比如多个div淡入淡出就可以发现，会有异样详情看 JS代码里面的多物体淡入淡出。</li>
<li>属性与运动对象绑定：速度、其他属性值等（比如透明度）</li>
</ul>
<blockquote>
<p>如果写JS多物体运动框架可以参考JS网页里面“去掉offset,添加形参的运动框架” 消化消化知识点。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E6%B3%95/" class="post-title-link" itemprop="url">二叉树排序法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-07 20:55:58" itemprop="dateModified" datetime="2020-06-07T20:55:58+08:00">2020-06-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>package ArrayList;

import java.util.ArrayList;
import java.util.List;

public class Node {
    public Node leftNode;
    public Node rightNode;

    public Object value;

    public static void main(String[] args) {
        int []randoms = new int[]{67,7,30,73,10,0,78,81,10,74};
        Node roots = new Node();
        for (int number : randoms){
            roots.add(number);
        }
        System.out.println(roots.value());
    }
    //插入 数据
    public void add(Object v){
        //如果当前节点没有值，就把数据放在当前节点上
        if (null == value){
            value = v ;
        }
        //如果当前节点有值，就进行判断，新增的值与现在的值的大小关系
        else {
            if ((Integer) v &lt; (Integer)value ){
                if (null == leftNode){
                    leftNode = new Node();
                }
                leftNode.add(v);
            }else {
                if(null == rightNode){
                    rightNode = new Node();
                }
                rightNode.add(v);
            }
        }
    }
    //中序遍历所有的节点
    public List&lt;Object&gt; value(){
        List&lt;Object&gt; values = new ArrayList&lt;&gt;();

        //左节点的遍历结果
        if (null != leftNode){
            values.addAll(leftNode.value());
        }
        //当前节点
        values.add(value);

        //右节点的遍历结果
        if (rightNode != null){
            values.addAll(rightNode.value());
        }
        return values;
    }
}</code></pre><blockquote>
<p>中序遍历的意思就是：先遍历左子树 然后 读取根节点 然后读取 右子树<br><img src="https://i.loli.net/2020/06/07/DQHGquFdAsLM5Tv.jpg" alt="微信图片_20200607194407.jpg"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/sizeof%E7%9A%84%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/sizeof%E7%9A%84%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">sizeof的用法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-05 21:06:38" itemprop="dateModified" datetime="2020-04-05T21:06:38+08:00">2020-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sizeof的用法"><a href="#sizeof的用法" class="headerlink" title="sizeof的用法"></a>sizeof的用法</h1><p><img src="https://img-blog.csdn.net/201804291534473" alt=""><br><img src="https://img-blog.csdn.net/2018042915351990" alt=""><br><img src="https://img-blog.csdn.net/20180429153532932" alt=""></p>
<p>均转载，以便复习以及加上一些注解</p>
<p>相对应的数据类型的字节数<br><img src="https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/python/" class="post-title-link" itemprop="url">python</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-29 20:15:22" itemprop="dateModified" datetime="2020-03-29T20:15:22+08:00">2020-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><blockquote>
<p>以下var全部是自定义变量</p>
</blockquote>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>定义一个列表十分简单<code>var=[&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,.....]</code></br><br>修改列表里面的元素也很简单 <code>var[i]=&#39;...&#39;</code></br></p>
<h4 id="增减元素"><a href="#增减元素" class="headerlink" title="增减元素"></a>增减元素</h4><ol>
<li>给列表末尾增添元素 <code>var.append(&quot;...&quot;)</code></li>
<li>在任意位置添加 <code>var.insert(i,&#39;...&#39;)</code></li>
<li>使用del语句删除元素 <code>del var[i]</code></li>
<li>使用pop()删除末尾元素 <code>var.pop()</code></li>
<li>使用remove()删除元素 <code>remove(&#39;value&#39;)</code><blockquote>
<p>del和pop的区别:如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还额能继续使用它，就使用方法pop()。</p>
</blockquote>
</li>
</ol>
<h4 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h4><ol>
<li><p>使用sort()对列表进行 <strong>永久性</strong> 排序 <code>var.sort()</code> 倒序<code>var.sort(reverse=True)</code></p>
</li>
<li><p>使用sorted()对列表进行<strong>临时</strong>排序 <code>print(sorted(var))</code></p>
<blockquote>
<p>为什么sorted()和sort()的用法不同呢，原因是他们的作用时间不用，因为sort是永久排序的，因此可以单独.sort()之后再print，但sorted()只能直接print才能显示顺序排列.</p>
</blockquote>
</li>
<li><p>使用reverse()进行倒序列表 <code>var.reverse()</code></p>
</li>
<li><p>使用len()可以显示列表长度 <code>len(var)</code></p>
</li>
</ol>
<h4 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h4><ol>
<li><p>遍历列表 <code>for i in var：</code>再print(i)出来就好拉。</p>
<blockquote>
<p>别忘了可爱的冒号喔，，</p>
</blockquote>
</li>
<li><p>创建数字列表<code>var = list(range(1,6))</code>会输出[1,2,3,4,5].</p>
</li>
<li><p>range()还可以指定步长<code>var = list(range(2,11,2))</code> 会输出[2,4,6,8,10].</p>
</li>
<li><p>python的运算还很简单<code>min/max/sum(var)</code></p>
</li>
<li><p>切片<code>print(var[1,4])</code>会输出列表索引中的var[1,2,3]到第4为止，但不输出4. 还能遍历哟<code>for i in var[:3]:</code></p>
</li>
<li><p>复制列表<code>var1 = var2[:]</code>就这样copy了一份了</p>
</li>
</ol>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>意义：创建一系列不可修改的元素，元组可以满足这种需求。python讲不能修改的值称为不可变的，而不可变的列表称为元组</p>
<ol>
<li>定义元组 <code>var=(...,...)</code></li>
<li>由意义可知 不允许修改元组里面的元素</li>
<li>遍历元组跟列表一样</li>
</ol>
<blockquote>
<p>相比于列表，元组是更简单的数据结构，如果需要储存的一组值在程序的整个生命周期内都不变，可使用元组。</p>
</blockquote>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ol>
<li>在比较是否相等的时候要注意大小写<code>car=&#39;Audi&#39; car==&#39;audi&#39;</code>会输出false</li>
<li>…没啥好讲的- -<blockquote>
<p>在python里面的语法是”elif” 不是 “else if”</p>
</blockquote>
</li>
</ol>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典的基本表达式是<code>var = {&#39;键&#39;:值(字符串需要用&#39;&#39;来框住),...}</code> 打印键则会输出值来。 <code>print(var[&#39;键&#39;])</code>会输出 <code>值</code></p>
<ol>
<li>添加键-值对 <code>var[&#39;color&#39;:&#39;green&#39;]</code> <code>var[&#39;键&#39;]=值</code> 就可以为字典添加一对键值对</li>
<li>可以直接创建一个空字典 <code>var={}</code> </li>
<li>修改字典里面的值 <code>var[&#39;键&#39;]=值</code></li>
<li>山粗字典里面的键值对 <code>del var[&#39;键&#39;]</code><blockquote>
<p>删除的键值对就永远消失了</p>
</blockquote>
</li>
<li>遍历字典<code>for var1,var2 in var.items():</code>var1,var2都是两个变量 var是一个字典</li>
<li>遍历字典里面的所有键<code>for var1 in var.keys():</code>var1是变量 var是一个字典</li>
<li>按顺序的遍历字典里的所有键 <code>for var1 in sorted(var.keys()):</code> var同上</li>
<li>遍历字典里面的所有值 <code>for var1 in var.values():</code> …</li>
</ol>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ol>
<li><p>字典列表</br><br> <code>var1={...}</code></br><br> <code>var2={...}</code></br><br> <code>var3={...}</code></br><br> <code>vars=[var1, var2,var3]</code></p>
<blockquote>
<p>经常要在列表中包含大量的字典，而其中每个字典都包含特定对象的众多信息。在这个列表中，所有字典的结构都相同，因此你可以遍历这个列表，并以相同的方式处理其中的每个字典</p>
</blockquote>
</li>
<li><p>还能通过列表的索引去改存入列表中的字典 <code>for var in vars[0:3]</code>(改前三个)</p>
<blockquote>
<p>有时候，需要讲列表储存在字典中，而不是将字典存储在列表中。每当需要在字典中将一个键关联到多个值使，都可以在字典中嵌套一个列表。</p>
</blockquote>
</li>
<li><p>字典中存列表<code>var = {&#39;var1&#39;:... , var2=[... , ...] }</code><br>一个小栗子：</br><br> <code>favourite_language={</code></br><br> <code>&#39;jen&#39;:[&#39;python&#39;,&#39;java&#39;,]</code></br><br> <code>sarah:[&#39;C&#39;]</code>,<br> <code>zwz:[&#39;java&#39;] }</code><br><code>for name,languages in favourite_language.items():</code></br><br> <code>print(&quot;\n&quot;+name.title()+&quot;&#39;s favourite language are:&quot;)</code></br></p>
<pre><code>`for language in languages:`&lt;/br&gt;
    `print(&quot;\t&quot; + language.title())`</code></pre></li>
</ol>
<blockquote>
<p>这里先第一次用循环使langeguas得到了列表，第二次再通过循环使language得到了循环里面的字符串</p>
</blockquote>
<ol start="4">
<li>字典里面储存字典<code>var={ var1:{ ... : ... ,... : ... },var2:{ ... : ... ,... : ... } }</code><blockquote>
<p>一般不会字典里面嵌套字典会使代码看的比较复杂。注意！ 如果每个字典里面的键不同会使导出字典里面的值更麻烦。因此尽量少用字典嵌套字典。</p>
</blockquote>
</li>
</ol>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ol>
<li>input()函数让程序暂停运行，等用户输入一些文本<code>var = input(&quot;&quot;)</code></li>
<li>用int()来获取数值输入 如果用了input等待了用户输入的一个数字，得到的结果却是一个字符串因此我们要用<code>int(var)</code>来使得用户输出来的’数字’成为一个数字。</li>
<li>使用break退出循环 continue也可以退出循环 但是二者不同，break是退出整个循环执行吓一条语句而continue是退出本次循环，倘若循环没有结束还要继续执行循环。</li>
</ol>
<blockquote>
<p>如果进入死循环，则可以按Ctrl+C退出循环。</p>
</blockquote>
<ol start="4">
<li>还能删除包含特定值的列表元素如<code>var = [1,2,3,4,5,6]</code> <code>while 2 in var</code> <code>var.remove(1)</code> <code>print(var)</code> 会输出<code>[1,3,4,5,6]</code></li>
</ol>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><blockquote>
<p>千万要记得定义函数后面要加冒号啊 <code>：</code></p>
</blockquote>
<pre><code>`def var():` 使用def来定义一个函数。在后面可以直接调用函数，`var()`即可。</code></pre><h4 id="向函数传递信息"><a href="#向函数传递信息" class="headerlink" title="向函数传递信息"></a>向函数传递信息</h4><pre><code>`def var(man):`
`print(&quot;man+&apos;love Hxm&apos;&quot;)`
`var(&apos;zwz&apos;)`</code></pre><p>会输出 zwz love Hxm</p>
<blockquote>
<p>可以在函数定义def var()的括号内添加一个东西 在调用函数的时候就可以给那个东西任何值，如上</p>
</blockquote>
<h4 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h4><blockquote>
<p>在函数var()的定义中，变量man是一个形参——函数完成工作所需要的一项信息，在代码var(‘zwz’)中，值’zwz’是一个实参，实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在var(‘zwz’)中，实参’zwz’传递给了函数var()，这个值被储存在形参man里面。</p>
</blockquote>
<h4 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h4><ul>
<li>位置实参<ul>
<li><code>def var(man,girl):</code></br><br><code>print(&quot;man+&#39;love&#39;+ girl&quot;)</code></br><br><code>var(&#39;zwz&#39;,&#39;hxm&#39;)</code></br><br>会输出zwz love hxm<blockquote>
<p>所谓的位置实参就是对应位置一个形参对应一个实参，zwz会赋予man，hxm会赋予girl所以位置关系尤为重要，如果输入错了，那么可能会有很坏的后果wo~</p>
</blockquote>
</li>
</ul>
</li>
<li>关键字实参<ul>
<li>前面定义与上一样。在调用实参的时候比如<code>var(man=&#39;zwz&#39;,girl=&#39;hxm&#39;)</code>或者可以<code>var(girl=&#39;hxm&#39;,man=&#39;zwz&#39;)</code></li>
</ul>
</li>
<li>默认值<ul>
<li>就是在定义函数的时候给形参一个实参比如说<code>var(man,girl=&#39;hxm&#39;)</code>在最后调用函数的时候可以只给man一个实参即可</li>
</ul>
</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>-返回简单值</p>
<pre><code>-`def name(first,last):`
    `full_name=first+last`
    `return full_name`
`a = name(&apos;Edward&apos;,&apos;Erwin&apos;)`
`print(a)`
会输出Edward Erwin</code></pre><p>-让实参变得可选</p>
<pre><code>`def get_formatted_name(first_name,middle_name,last_name):`
    `if middle_name:`
        `full_name = first_name + &apos;&apos; + middle_name + &apos;&apos; +last_name`
    `else:`
        `full_name = first_name + &apos;&apos; + last_name`
    `return full.name.title()`
`name = get_formatted_name(&apos;zwz&apos;,&apos;edward&apos;,&apos;erwin&apos;)`
`print(name)`</code></pre><p>会输出 Zwz Edward Erwin</p>
<pre><code>`name = get_formatted_name(&apos;zwz&apos;,&apos;erwin&apos;)`
`print(name)`</code></pre><p>会输出Zwz Erwin</p>
<blockquote>
<p>在函数体中，我们检查是否提供中间名。Python将<strong>非空字符串</strong>读为True，因此如果函数调用中间的中间名，if middle_name将为True。这里判断你是否输入中间名而执行不同的语句。</p>
</blockquote>
<h4 id="返回字典"><a href="#返回字典" class="headerlink" title="返回字典"></a>返回字典</h4><pre><code>def name(first_name,last_name):
    full_name={&apos;first&apos;:first_name,&apos;last&apos;:last_name}
    return full_name
a = name(&apos;Edward&apos;,&apos;Erwin&apos;)
print(a)</code></pre><p>会输出</p>
<pre><code>{&apos;first&apos;:&apos;Edward&apos;,&apos;last&apos;:&apos;Erwin&apos;}</code></pre><h4 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h4><pre><code>def make_pizza(*toppings):      //注意形参中有 * 号
    print(toppings)

make_pizza(&apos;pepperoni&apos;)
make_pizza(&apos;mushrooms&apos;,&apos;green peppers&apos;,&apos;extra cheese&apos;)</code></pre><p>会输出</p>
<pre><code>(&apos;pepperoni&apos;)
(&apos;mushrooms&apos;,&apos;green peppers&apos;,&apos;extra cheese&apos;)</code></pre><blockquote>
<p>形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装在这个元组中。</p>
</blockquote>
<ul>
<li><p>使用任意数量的关键字实参</p>
<blockquote>
<p>有时候，需要接受任意数量的实参，但预先布置的传递给函数的是什么样的信息。此情况可以将函数编写成能够接受任意数量的键-值对</p>
</blockquote>
<p>  def build_profile(first,last,*<em>user_Info)    // *</em> 建立空字典</p>
<pre><code>profile={}
profile[&apos;first_name&apos;]=first                      ←←←
profile[&apos;last_name&apos;]=last                         ←←←
for key,value in user_Info.items():
    profile[key]=value
retuen profile</code></pre><p>  user_profile = bulid_profile(‘albert’,’einstein’,location=’princeton’,field=’physics’)<br>  print(user_profile)</p>
</li>
</ul>
<p>会输出</p>
<pre><code>&apos;first_name&apos;:&apos;albert&apos;
&apos;last_name&apos;:&apos;einstein&apos;
&apos;location&apos;:&apos;princeton&apos;
&apos;field&apos;:&apos;physics&apos;</code></pre><blockquote>
<p>在build_profile()的函数体内，我们创建了一个名为profile的空字典，用于储存用户简介。在←←←我们将名和姓加入到这个字典中。在循环中遍历字典中的键值对，并将每个键值对都加入字典profile中。</p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是表示一类事物共同具有的特征，比如狗狗来说一般都会打滚和坐下。因此我们可以创造一个类来储存他们的动作。就比如说：</p>
<pre><code>class Dog(): 
    def_init_(self,name,age):
        self.name = name
        self.age = age
    def sit(self):
        print(self.name + &quot;is sitting&quot;)
    def roll(self):
        print(self.name + &quot;is rolling&quot;)</code></pre><p>这样就创建了一个”狗狗”类，并且把两个狗狗通常都会的动作写进了里面。</p>
<blockquote>
<p>类中的函数叫方法，<code>_init_()</code>是一种特殊的方法，每当根据Dog()创建实例的时候就会调用它。</p>
</blockquote>
<blockquote>
<p>在<code>_init_</code>里面包含了三个形参：self，name,age.在方法的定义中，形参self必不可少，还必须位于其他形参的前面。因为调用这个函数的方法来创建Dog()实例的时候，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例可以访问类中的属性和方法。调用Dog()时只需要提供 name,age 即可self会自动传递。</p>
</blockquote>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><pre><code>my_dog=Dog(&apos;hhh&apos;,6)
print(&quot;my dog name:&quot;+my_dog.name)
print(&quot;my dog age:&quot;+str(my_dog.age))</code></pre><p>会输出</p>
<pre><code>my dog name hhh
my dog age 6</code></pre><blockquote>
<p>在这里我们用一个my_dog来储存我们提供的值储存在属性name和age。</p>
</blockquote>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><pre><code>my_dog.sit()
my_dog.roll_over()</code></pre><p>就会调用方法里面的语句，并把my_dog里面的参数赋予方法中</p>
<h4 id="给属性指定的默认值"><a href="#给属性指定的默认值" class="headerlink" title="给属性指定的默认值"></a>给属性指定的默认值</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-07 21:01:44" itemprop="dateModified" datetime="2021-02-07T21:01:44+08:00">2021-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL-从删库到跑路"><a href="#MySQL-从删库到跑路" class="headerlink" title="MySQL (从删库到跑路)"></a>MySQL (<s>从删库到跑路</s>)</h1><h2 id="为什么要学习数据库"><a href="#为什么要学习数据库" class="headerlink" title="为什么要学习数据库"></a>为什么要学习数据库</h2><ol>
<li>持久化数据</li>
<li>方便检索</li>
<li>存储大量数据</li>
<li>共享、安全</li>
<li>通过组合分析，获取的数   </li>
</ol>
<h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><ol>
<li>DB:database数据库，存储一些列有组织数据的容器</li>
<li>DBMS:database Management System 数据库管理系统，使用DBMS管理DB；</li>
<li>SQL:Structure Query Language 节后话查询语言，程序员用于和DBMS通信的语言</li>
</ol>
<h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><ol>
<li>数据先放着表中，表再放在库中</li>
<li>一个库可以有多张表，每张表都有自己唯一的标识名</li>
<li>一张表的设计，类似于Java中类的设计<blockquote>
<p>表中字段的设计，类似于属性的设计</p>
</blockquote>
</li>
</ol>
<p>orm：object relation mapping 对象关系映射</p>
<h2 id="初始化MySQL"><a href="#初始化MySQL" class="headerlink" title="初始化MySQL"></a>初始化MySQL</h2><h3 id="MySQL产品介绍"><a href="#MySQL产品介绍" class="headerlink" title="MySQL产品介绍"></a>MySQL产品介绍</h3><p>MySQL前身属于瑞典的一家AB，2008年被sun公司收购，2009年sun被Oracle公司收购</p>
<p>特点：</p>
<ol>
<li>体积小、安装比较方便</li>
<li>开源、免费</li>
<li>性能镐，稳定性好</li>
<li>兼容性好</li>
</ol>
<h3 id="MySQL产品的安装"><a href="#MySQL产品的安装" class="headerlink" title="MySQL产品的安装"></a>MySQL产品的安装</h3><p>基于C/S架构的DBMS，需要安装服务端和客户端；</p>
<h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>方式1：图形化的方式</br><br>右击–计算机–管理–MySQL服务</p>
<p>方式2：通过管理员身份运行dos</br><br>net start 服务名</br><br>net stop 服务名</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>方式1：mysql -h 主机名 -P端口号 -u用户名 -p密码</br><br>注意：</br><br>如果是本机，则-h主机名可以省略</br><br>如果端口号是3306，则-p端口号可以省略</br></p>
<p>方式2：通过图形化界面客户端</br><br>通过sqlyog，直接输入用户名、密码等链接进去即可</p>
<h3 id="MySQL-的常见命令和语法规范"><a href="#MySQL-的常见命令和语法规范" class="headerlink" title="MySQL 的常见命令和语法规范"></a>MySQL 的常见命令和语法规范</h3><ul>
<li><p>常用命令</p>
<ul>
<li><code>show databases</code> 显当前连接下所有数据库</li>
<li><code>show tables</code> 显示当前库中所有表</li>
<li><code>show tables from 库名</code> 显示指定库中所有表</li>
<li><code>show columns from 表名</code> 显示指定表所有列</li>
<li><code>use 库名</code> 打开/使用指定库名</li>
</ul>
</li>
<li><p>语法规范</p>
<ul>
<li>不区分大小写</li>
<li>每条命令结尾用粉好</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li><h1 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h1></li>
<li>– 单行注释</li>
<li>/**/ 多行注释</li>
</ul>
</li>
</ul>
<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><blockquote>
<p>DQL：Data Query Language 数据查询语言</p>
</blockquote>
<h2 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h2><p>/* </p>
<p>语法：<br>select：查询列表 from 表;</p>
<p>类似于：<code>System.out.println()</code>;</p>
<p>特点：</p>
<ol>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>查询的结果是一个虚拟的表格</li>
</ol>
<p>*/</p>
<p><code>USE myemployees</code>;</p>
<ul>
<li><p>查询表中的单个字</p>
<pre><code>SELECT last_name FROM employee;</code></pre></li>
<li><p>查询表中的多个字段</p>
<pre><code>SELECT last_name,salary,email FROM employees;</code></pre></li>
<li><p>查询表中的所有字段</p>
<pre><code>SELECT * FROM employees;</code></pre></li>
<li><p>查询常量值</p>
<pre><code>SELECT 100;

SELECT &apos;john&apos;</code></pre></li>
<li><p>查询表达式</p>
</li>
</ul>
<p>`SELECT 100*98;</p>
<ul>
<li><p>查询函数</p>
<pre><code>SELECT VERSION();</code></pre></li>
<li><p>起别名 F12：对齐格式</p>
</li>
</ul>
<p>/*</p>
<p>  1.便于理解</p>
<p>  2.如果要查询的字段有重名的情况，使用别名可以区分来</p>
<p>*/</p>
<ul>
<li><p>方法一：使用as</p>
<pre><code>SELECT 100%98 AS result;

SELECT last_name AS 姓,first_name AS 名 FROM employees;</code></pre></li>
<li><p>方法2：使用空格</p>
<pre><code>SELECT last_name 姓,first_name 名 FROM employees; </code></pre></li>
</ul>
<p><strong>案例：查询salary，显示结果为out put</strong></p>
<pre><code>SELECT salary AS &quot;out put&quot; FROM employees;</code></pre><p><strong>需求：查询first_name和last_name拼接成的全名，最终起别名为：姓 名</strong></p>
<pre><code>方法一：

`SELECT first_name+last_name AS &quot;姓 名&quot; FROM employees;`

方法二：

`SELECT CONCAT(first_name,last_name) AS &quot;姓 名&quot; FROM employees;`</code></pre><ul>
<li>去重  distinct的使用</li>
</ul>
<p><strong>需求：查询员工涉及到的部门</strong></p>
<pre><code>SELECT DISTINCT department_id FROM employees;</code></pre><p>9.查看表的结构</p>
<pre><code>DESC employees;
SHOW COLUMNS FROM employees;</code></pre><ul>
<li><p>ifnull(表达式1,表达式2)(如果前面的为null 后面要求是什么就显示什么)</p>
<pre><code>SELECT commission_pct,IFNULL(commission_pct,&apos;空&apos;) FROM employees;</code></pre></li>
</ul>
<p><strong><em>测试1-基本SQL-SELECT语句</em></strong></p>
<ol>
<li><p>下面的语句是否可以执行成功 （true）</br></p>
<pre><code>SELECT lastn_name ,job_id,salary AS sal FROM employees;</code></pre></li>
<li><p>下面的语句是否可以执行成功 （true）</br></p>
<pre><code>SELECT * FROM employees;</code></pre></li>
<li><p>找出下面语句中的错误 (false last_name，)</p>
</li>
<li><p>显示表 departments 的结构，并查询其中的全部数据</p>
<pre><code>DESC deparments;
SELECT * FROM departments;</code></pre></li>
<li><p>显示出表 employees 中的全部 job_id （不能重复)</p>
<pre><code>SELECT DISTINCT job_id FROM employees;</code></pre></li>
<li><p>显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT </br></p>
<pre><code>SELECT CONCAT(employee_id,&apos;,&apos;,`first_name`,&quot;,&quot;,`last_name`,&quot;,&quot;,`email`,&quot;,&quot;,`phone_number`,&quot;,&quot;,`job_id`,&quot;,&quot;,`salary`,&quot;,&quot;,IFNULL(commission_pct,&apos; &apos;),&quot;,&quot;,IFNULL(manager_id,&apos; &apos;),&quot;,&quot;,`department_id`,&quot;,&quot;,`hiredate`)
AS &quot;OUT_PUT&quot; FROM employees </code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Maven/" class="post-title-link" itemprop="url">Maven</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-09 20:56:02" itemprop="dateModified" datetime="2021-03-09T20:56:02+08:00">2021-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/Linux/" class="post-title-link" itemprop="url">Linux</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-15 08:57:32" itemprop="dateModified" datetime="2021-03-15T08:57:32+08:00">2021-03-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux开始"><a href="#Linux开始" class="headerlink" title="Linux开始"></a>Linux开始</h1><h2 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h2><p><img src="https://i.loli.net/2021/01/11/lgXmkc3vY5G18RD.png" alt="1610355820_1_.jpg"></p>
<h2 id="Linux学习方向"><a href="#Linux学习方向" class="headerlink" title="Linux学习方向"></a>Linux学习方向</h2><p><img src="https://i.loli.net/2021/01/11/gCRWndlkm1reijI.png" alt="1610356119_1_.jpg"></p>
<ol>
<li>Linux运维工程师</li>
<li>Linux嵌入式开发工程师</li>
<li>在Linux下做各种程序开发</li>
</ol>
<h2 id="Linux的应用领域"><a href="#Linux的应用领域" class="headerlink" title="Linux的应用领域"></a>Linux的应用领域</h2><ul>
<li><p>个人桌面应用领域</p>
<blockquote>
<p>此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺<br>点，一直被windows所压制，但近些年来随着ubuntu、fedora [fɪˈdɔ:rə] 等优秀桌面环境的兴<br>起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高。</p>
</blockquote>
</li>
<li><p>服务器应用领域</p>
<blockquote>
<p>linux在服务器领域的应用是最强的。<br>linux免费、稳定、高效等特点在这里得到了很好的体现，近些年来linux服务器市场得到了飞<br>速的提升，尤其在一些高端领域尤为广泛。</p>
</blockquote>
</li>
<li><p>嵌入式应用领域</p>
<blockquote>
<p>近些年来linux在嵌入式领域的应用得到了飞速的提高<br>linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小<br>可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高<br>主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件<br>等都是其应用领域。以后再物联网中应用会更加广泛。</p>
</blockquote>
</li>
</ul>
<h3 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h3><p><strong>第1阶段：</strong>linux环境下的基本操作命令，包括 文件操作命令(rm mkdir chmod, chown) 编辑工具使用（vi vim）linux用户管理(useradd userdel usermod)等</p>
<p><strong>第2阶段：</strong>linux的各种配置（环境变量配置，网络配置，服务配置）</p>
<p><strong>第3阶段：</strong>linux下如何搭建对应语言的开发环境（大数据，JavaEE, Python等）</p>
<p><strong>第4阶段：</strong>能编写shell脚本，对Linux服务器进行维护。</p>
<p><strong>第5阶段：</strong>能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。</p>
<p><strong>第6阶段：</strong>深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟<br>悉各个环节的部署和维护方法。</p>
<h1 id="Linux-入门"><a href="#Linux-入门" class="headerlink" title="Linux 入门"></a>Linux 入门</h1><h2 id="CentOS安装的步骤"><a href="#CentOS安装的步骤" class="headerlink" title="CentOS安装的步骤"></a>CentOS安装的步骤</h2><ol>
<li>创建虚拟机(空间)</br><br>   这里配置网络连接的时候有三个形式：<br><img src="https://i.loli.net/2021/01/14/G3kBZzwWHiECJF8.png" alt="1610369061_1_.jpg"></li>
</ol>
<h1 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li>Linux的文件系统采用层级式的树状目录结构，在此结构中最上层是根目录”/“，然后在此目录下在创建其他目录</li>
</ul>
<blockquote>
<p><strong>Linux下，一切皆为文件</strong><br><img src="https://i.loli.net/2021/01/15/NpRXaPYesfQB7Sr.png" alt="1610706297_1_.jpg"></p>
</blockquote>
<h2 id="具体的目录结构："><a href="#具体的目录结构：" class="headerlink" title="具体的目录结构："></a>具体的目录结构：</h2><ul>
<li>/bin(重点)<ul>
<li>是Binary的缩写，这个目录存放着最经常使用的命令</li>
</ul>
</li>
<li>/sbin<ul>
<li>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
</ul>
</li>
<li>/home(重点)<ul>
<li>存放普通用户的主目录，在Linux中每一个用户都有自己的目录，一般该目录名是以用户的账号命名的。</li>
</ul>
</li>
<li>/root(重点)<ul>
<li>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
</ul>
</li>
<li>/boot(重点)<ul>
<li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</li>
</ul>
</li>
<li>/proc<ul>
<li>是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</li>
</ul>
</li>
<li>/srv<ul>
<li>service缩写，该目录存放一些服务启动之后需要提取的数据</li>
</ul>
</li>
<li>/sys<ul>
<li>这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中出现的一个文件</li>
</ul>
</li>
<li>/tmp<ul>
<li>存放一些临时的文件</li>
</ul>
</li>
<li>/dev <ul>
<li>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</li>
</ul>
</li>
<li>/media(重点)<ul>
<li>Linux系统会自动识别一些设备，例如u盘、光驱等等，识别后Linux会把识别的设备挂载到这个目录下。</li>
</ul>
</li>
<li>/mnt(重点)<ul>
<li>系统提供的该目录是为了让用户临时挂载别的文件系统的，我们可以将外部存储挂载在/mnt上，然后进入该目录就可以查看里的内容。    </li>
</ul>
</li>
<li>/opt<ul>
<li>这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可以放在该目录下。默认为空</li>
</ul>
</li>
<li>/usr/local(重点)<ul>
<li>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</li>
</ul>
</li>
<li>/var(重点)<ul>
<li>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放栈这个目录下。包括各种日志文件。</li>
</ul>
</li>
<li>/selinux[security-enhanced linux]<ul>
<li>SELinux是一种安全子系统，它能控制程序只能访问特定文件。  </li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>Linux的目录中又且只有一个根目录 /</li>
<li>Linux的各个目录存放的内容是规划好的不要乱放文件。</li>
<li>Linux是以文件的形式管理我们的设备的，因此在Linux世界里一切皆为文件。</li>
<li>各个文件目录下存放什么内容，都要知道！</li>
<li>学完之后应该有一棵Linux的目录树。</li>
</ol>
<p>#Linux 实操</p>
<h2 id="为什么要远程登录Linux呢"><a href="#为什么要远程登录Linux呢" class="headerlink" title="为什么要远程登录Linux呢"></a>为什么要远程登录Linux呢</h2><p>说明：公司开发的时候，具体的情况是这样的</p>
<ol>
<li>Linux服务器是开发小组共享的。</li>
<li>正式上线的项目是运行在公网的</li>
<li>程序员需要远程登陆到centos进行项目开发和管理</li>
<li>远程登录的客户端又Xshell 5，XFtp5，其他工具大同小异</li>
</ol>
<h2 id="Linux-Xshell-5"><a href="#Linux-Xshell-5" class="headerlink" title="Linux-Xshell 5"></a>Linux-Xshell 5</h2><p>说明: Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完 美解决了中文乱码的问题， 是目前程序员首选的软件。</p>
<p>Xshell [1] 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。</p>
<p>Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好<br>的达到远程控制终端的目的。</p>
<p><img src="https://i.loli.net/2021/01/17/AG1jmi53Zc9lwWt.png" alt="1610715401(1).jpg"></p>
<h3 id="Vi-和-Vim"><a href="#Vi-和-Vim" class="headerlink" title="Vi 和 Vim"></a>Vi 和 Vim</h3><p>所有的Linux系统都会内建vi文本编辑器</p>
<p>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别 语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别 丰富，在程序员中被广泛使用。</p>
<h3 id="三种常见模式"><a href="#三种常见模式" class="headerlink" title="三种常见模式"></a>三种常见模式</h3><p><strong>正常模式:</strong><br>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用<br>『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，<br>也可以使用『复制、贴上』来处理你的文件数据。</p>
<p><strong>插入模式:</strong><br>按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可.</p>
<p><strong>命令行模式</strong><br>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的 动作则是在此模式中达成的！</p>
<p><strong>三种模式的转换图</strong><br><img src="https://i.loli.net/2021/01/17/5WlXG72fnLiMxDH.png" alt="1610858825(1).jpg"></p>
<h3 id="vi-以及-vim常用快捷键"><a href="#vi-以及-vim常用快捷键" class="headerlink" title="vi 以及 vim常用快捷键"></a>vi 以及 vim常用快捷键</h3><p><strong>练习</strong></br><br>1)拷贝当前行 yy , 拷贝当前行向下的5行 5yy，并粘贴。</br><br>2) 删除当前行 dd  , 删除当前行向下的5行 5dd</br><br>3) 在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]</br></p>
<p>4) 设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]</br><br>5) 编辑 /etc/profile 文件，使用快捷键到底文档的最末行”G”和最首行”gg”</br></p>
<blockquote>
<p>或者点三次”[[[“回到顶部   “]]]”回到底部</p>
</blockquote>
<p>6) 在一个文件中输入 “hello” ,然后又撤销这个动作 u</br><br>7) 编辑 /etc/profile 文件，并将光标移动到 20行 shift+g</br><br><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt=""></p>
<h3 id="开机、重启、用户登录注销"><a href="#开机、重启、用户登录注销" class="headerlink" title="开机、重启、用户登录注销"></a>开机、重启、用户登录注销</h3><p><strong>基本介绍</strong></p>
<ol>
<li>shutdown:<ul>
<li>shutdown -h now:表示立即关机</li>
<li>shutdown -h 1 :表示一分钟后还击</li>
<li>shutdown -r now：立即重启</li>
</ul>
</li>
<li>halt:<ul>
<li>直接使用，等效于关机</li>
</ul>
</li>
<li>reboot:<ul>
<li>就是重启系统</li>
</ul>
</li>
<li>sync:<ul>
<li>把内存的数据同步到磁盘</li>
</ul>
</li>
</ol>
<p><strong>注意细节</strong></p>
<blockquote>
<p>当我们关机或重启时候，都应该先执行一下sync指令，把内存数据写入磁盘，防止数据丢失</p>
</blockquote>
<h3 id="用户的登录与注销"><a href="#用户的登录与注销" class="headerlink" title="用户的登录与注销"></a><strong>用户的登录与注销</strong></h3><p><strong>基本介绍</strong></p>
<ol>
<li>logout<ul>
<li>直接退出当前的连接</li>
</ul>
</li>
</ol>
<p><strong>注意细节</strong></p>
<blockquote>
<p>logout注销指令在图形运行级别无效，在运行级别3下有效。</p>
</blockquote>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>Linux的用户需要至少属于一个组。</p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a><strong>添加用户</strong></h3><p>基本语法</p>
<p><code>useradd[选项] 用户名</code></p>
<p><strong>案例</strong></p>
<p>添加一个用户xm.<br><img src="https://i.loli.net/2021/01/17/GSyJmC4ok3geHRB.png" alt="1610883707_1_.jpg"></p>
<blockquote>
<p>会产生/home/xm  也就是说在根目录下的home目录会出现一个xm</p>
</blockquote>
<p><strong>细节说明</strong></p>
<ol>
<li>当创建用户成功后，会自动的创建和用户同名的家目录。</li>
<li>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录</li>
</ol>
<h3 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a><strong>指定/修改密码</strong></h3><p>基本语法</br><br>passwd 用户名</br><br><strong>应用案例</strong></br><br>1). 给xiaoming指定密码</p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><strong>删除用户</strong></h3><p>基本语法</br><br>userdel 用户名(删除用户)<br>userdel -r 用户名(把家目录一起删)</p>
<p>1）删除用户xiaoming，但是要保留家目录<br>2）删除用户以及用户主目录</p>
<blockquote>
<p>在实际开发中，一般不会把家目录删除，因为有可能有重要的数据</p>
</blockquote>
<p>###<strong>查询用户信息</strong><br>id 用户名</br></p>
<p><strong>应用实例</strong></br><br>查看root的信息</p>
<p><img src="https://i.loli.net/2021/01/19/xls7qgRSTOWEnhM.png" alt="1611036257_1_.png"></p>
<blockquote>
<p>uid-&gt;用户id号  gid-&gt;用户所在组的id号 组-&gt; 所在组的名称<br>用户不存在则会弹出无此用户</p>
</blockquote>
<p>###<strong>切换用户</strong></p>
<blockquote>
<p>如果用户的权限不够则可以通过切换用户来操作系统以获得权限。</p>
</blockquote>
<p><strong>语法</strong><br>su 切换用户名  </p>
<p>如果切换了用户但是想回到之前的用户</p>
<p>exit即可回到</p>
<blockquote>
<p>ps. 当一个用户从高权限用户到低权限用户时，不用输入密码</p>
</blockquote>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p><strong>介绍</strong></br><br>类似于角色，系统可以对有共性的多个用户进行统一的管理。</br><br><strong>新增组</strong></br></p>
<p>groupadd 组名</p>
<p><strong>删除组</strong></p>
<p>groupdel 组名</p>
<p><strong>增加用户时直接加上组</strong></p>
<p>useradd -g 用户组 用户名</p>
<p><a href="https://imgchr.com/i/s2OMYF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/19/s2OMYF.png" alt="s2OMYF.png"></a></p>
<p><strong>修改用户的组</strong></p>
<p>usermod -g 用户组 用户名</p>
<h3 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h3><p><strong>修改用户的组</strong></p>
<p><strong>/etc/passwd 文件</strong></br><br>用户(user)的配置文件，记录用户的各种信息</br></p>
<p>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p>
<p><strong>/etc/shadow 文件</strong></br><br>口令的配置文件</br></p>
<p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
<p><strong>/etc/group 文件</strong></br><br>组(group)的配置文件，记录Linux包含的组的信息</br></p>
<p>每行含义：组名：口令：组标识符：组内用户列表</p>
<blockquote>
<p>一般组内用户列表看不见。</br><br>ps.如果创建了组vim之后看不见，一直点enter，因为vim是不完全显示</p>
</blockquote>
<h1 id="Linux实操-实用指令"><a href="#Linux实操-实用指令" class="headerlink" title="Linux实操 实用指令"></a>Linux实操 实用指令</h1><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p><strong>基本介绍</strong></p>
<ol>
<li>0：关机 </li>
<li>1：单用户(找回丢失密码)</li>
<li>2：多用户无网络服务</li>
<li>3：多用户有网洛服务</li>
<li>4：待定</li>
<li>5：图形界面</li>
<li>6：重启</li>
</ol>
<p>常用的运行级别是 3和5，要修改默认的运行级别可改文件<br><code>/etc/inittab</code>的id:5:initdefault:这一行中的数字</p>
<p>命令：init[012356]</p>
<blockquote>
<p>OS7中用systemctl代替了/etc/init </p>
</blockquote>
<p><strong>运行级别的示意图</strong><br><a href="https://imgchr.com/i/s2Otw6" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/19/s2Otw6.png" alt="s2Otw6.png"></a></p>
<h3 id="切换到指定运行级别的指令"><a href="#切换到指定运行级别的指令" class="headerlink" title="切换到指定运行级别的指令"></a>切换到指定运行级别的指令</h3><p><code>systemctl get-default</code> 获取默认的运行级别<br><code>systemctl set-default TARGET.target</code> 设置默认的运行级别</p>
<p><a href="https://imgchr.com/i/s2OmwV" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/19/s2OmwV.md.png" alt="s2OmwV.md.png"></a></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>如何找回root密码，如果不小心忘记了root密码，如何找回。</p>
<p>思路：进入到单用户模式，然后修改root密码。因为单用户模式下，root模式不用密码</p>
<p>Centos7 进入单用户模式</p>
<p>当我们设置用户密码时，有可能会忘记，这时如何登陆呢，单用户模式就可以</p>
<p>首先我们进入开机界面，按e进行选择</p>
<p><img src="https://img-blog.csdnimg.cn/20181128175655385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>会进入以下界面，</p>
<p><img src="https://img-blog.csdnimg.cn/20200509153856534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>然后找到图中红线标注的该行，在行尾添加 init=/bin/sh 并将对应的ro权限改为rw权限。（这个原文并没有写，原文他的操作系统和我们的并不一样，但基本上都是标明了ro权限的）</p>
<p><img src="https://img-blog.csdnimg.cn/20200509154024138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>按住Ctrl+x执行</p>
<p>可以进入单用户模式</p>
<p><img src="https://img-blog.csdnimg.cn/20181128175655419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTYwMzI0,size_16,color_FFFFFF,t_70" alt=""></p>
<p>如图所示，我们还可以修改密码，默认修改root密码，也可以修改其他用户的密码passwd junjind</p>
<p>执行exec  /sbin/init 即可退出单用户模式</p>
<p><img src="https://img-blog.csdnimg.cn/20200509155218201.png" alt=""></p>
<blockquote>
<p>这个操作只能在Linux所在的那台电脑上操作，因此，你都有权限进入机房了，那肯定有权限改密码呀，因此不用担心别人随随便便改你密码</p>
</blockquote>
<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><p><strong>介绍</strong></p>
<p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p>
<p><strong>man 获得帮助信息</strong></p>
<ul>
<li>基本语法 <ul>
<li><code>man[命令或配置文件](功能描述，获得帮助信息)</code></li>
</ul>
</li>
</ul>
<p><strong>help 指令</strong></p>
<ul>
<li>基本语法<ul>
<li><code>help命令(功能描述，获得shell内置命令的帮助信息)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>说实话百度更有用</p>
</blockquote>
<h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><h3 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h3><ul>
<li>基本语法<ul>
<li>pwd (功能描述：显示当前工作目录的绝对路径)</li>
</ul>
</li>
</ul>
<h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><ul>
<li>基本语法<ul>
<li>ls[选项] [目录或是文件]</li>
</ul>
</li>
<li>常用选项<ul>
<li>-a:显示当前目录所有信息，包括隐藏的</li>
<li>-l:以列表的形式显示信息</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/sWjxwn" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/20/sWjxwn.png" alt="sWjxwn.png"></a></p>
<blockquote>
<p>ls -la 或者 ls -al 一样的</p>
</blockquote>
<h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h3><ul>
<li>基本语法<ul>
<li>cd [参数]（切换到指定目录）</li>
</ul>
</li>
<li>常用参数<ul>
<li>绝对路径和相对路径</li>
<li>cd ~或cd：回到自己的家目录</li>
<li>cd ..回到当前目录的上一级目录</li>
</ul>
</li>
</ul>
<h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h3><blockquote>
<p>mkdir指令用于创建目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>mkdir[选项] 要创建的目录</li>
</ul>
</li>
<li>常用选项<ul>
<li>-p：创建多级目录<blockquote>
<p>不带-p则只能创建一级目录</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h3><blockquote>
<p>rmdir 指令删除空目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>rmdir [选项] 要删除的空目录</li>
</ul>
</li>
</ul>
<p>注意细节：<br>    rmdir删除的是空目录，如果目录下有内容时无法删除的。</p>
<blockquote>
<p>ps如果需要删除非空目录，需要使用 rm -rf要删除的目录</p>
</blockquote>
<h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><blockquote>
<p>touch指令创建空文件</p>
</blockquote>
<ul>
<li>基本语法 <ul>
<li>touch 文件名称<blockquote>
<p>可以一次性创建多个文件，用空格隔开即可。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="cp指令-重要噢"><a href="#cp指令-重要噢" class="headerlink" title="cp指令[重要噢]"></a>cp指令[重要噢]</h3><blockquote>
<p>cp指令拷贝文件到指定目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>cp [选项] source dest</li>
</ul>
</li>
<li>常用选项<ul>
<li>-r：递归复制整个文件夹</li>
</ul>
</li>
</ul>
<p><img src="https://s3.ax1x.com/2021/01/20/sfQK4P.png" alt=""></p>
<blockquote>
<p>如果发现了目标目录下有此文件了可以通过<code>\cp -r</code> 强制覆盖</p>
</blockquote>
<h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><blockquote>
<p>rm指令移除文件或目录</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>rm [选项] 要删除的文件或目录</li>
</ul>
</li>
<li>常用选项<ul>
<li>-r:递归删除整个文件夹</li>
<li>-f:强制删除不提示 </li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/s43YE4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/21/s43YE4.png" alt="s43YE4.png"></a></p>
<h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><blockquote>
<p>mv移动文件与目录或重命名</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>mv oldNameFile newNameFile （重命名）</li>
<li>mv /temp/movefile /targetFolder（移动文件）</li>
</ul>
</li>
</ul>
<h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><blockquote>
<p>cat查看文件内容，是以只读的方式打开。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>cat [选项] 要查看的文件</li>
</ul>
</li>
<li>常用选项    <ul>
<li>-n:显示行号</li>
</ul>
</li>
</ul>
<p><strong>使用细节</strong><br>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 | more</p>
<p><code>cat ... | more</code> </p>
<h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h3><blockquote>
<p>more指令是一个基于vi编辑器的文本过滤器，他以全屏幕的方式按页显示文本文件的内容，more指令中内置了若干快捷键，详见操作说明。</p>
</blockquote>
<ul>
<li><p>基本语法</p>
<ul>
<li>more 要查看的文件</li>
</ul>
<p><a href="https://imgchr.com/i/s4N8Dx" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/21/s4N8Dx.png" alt="s4N8Dx.png"></a></p>
</li>
</ul>
<h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h3><blockquote>
<p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，<strong>并不是一次将整个文件加载之后再显示</strong>，而是根据显示的需要加载内容，<strong>对于显示大型文件具有较高的效率</strong></p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>less 要查看的文件</li>
</ul>
</li>
</ul>
<p>即懒加载。</p>
<h3 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和 &gt;&gt;指令"></a>&gt;指令和 &gt;&gt;指令</h3><blockquote>
<p>>输出重定向和 >> 追加</p>
<p>> 输出重定向：会将原来的文件的内容覆盖</p>
<p> >>追加：不会覆盖原来文件的内容，而是追加的文件的尾部。
</blockquote>
<ul>
<li>基本语法<ul>
<li>ls -l&gt;文件（列表的内容写入文件a.txt中(覆盖写)）</li>
<li>ls -al&gt;&gt;文件 (列表的内容追加到文件aa.txt的末尾)</li>
<li>cat 文件1 &gt; 文件2(将文件1的内容覆盖到文件2)</li>
<li>echo “内容”&gt;&gt;文件</li>
</ul>
</li>
</ul>
<h3 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h3><blockquote>
<p>echo输出内容到控制台。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>echo [选项] [输出内容]</li>
</ul>
</li>
<li>应用<ul>
<li>使用echo指令输出环境变量，输出当前的环境路径。<ul>
<li><code>echo $PATH</code></li>
</ul>
</li>
<li>使用echo输出hello,world!<ul>
<li><code>echo hello,world!</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h3><blockquote>
<p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>head 文件(查看文件的头10行内容)</li>
<li>head -n x 文件(查看文件头x行内容)</li>
</ul>
</li>
</ul>
<h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h3><blockquote>
<p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>tail 文件(查看后10行内容)</li>
<li>tail -n x 文件(查看后x行内容)</li>
<li>tail -f 文件(追踪该文档的所有更新)</li>
</ul>
</li>
</ul>
<h3 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h3><blockquote>
<p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p>
</blockquote>
<ul>
<li><p>基本语法 </p>
<ul>
<li>ln -s[源文件或目录] [软链接名]</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>在/home目录下创建一个软链接linkToRoot，连接到/root目录，并删除。</li>
</ul>
</li>
</ul>
<p><strong>创建</strong><br><a href="https://imgchr.com/i/sTo8je" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sTo8je.png" alt="sTo8je.png"></a></p>
<p><strong>删除</strong><br><a href="https://imgchr.com/i/sTod4P" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sTod4P.png" alt="sTod4P.png"></a></p>
<h3 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h3><blockquote>
<p>查看已经执行过历史命令，可以执行历史指令</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>history (查看了以前执行过的指令)</li>
<li>history 10 (查看后10个)</li>
</ul>
</li>
</ul>
<p>小技巧:用!加指令行数可以执行历史编号为那行的指令<br><a href="https://imgchr.com/i/sTT6xO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sTT6xO.png" alt="sTT6xO.png"></a></p>
<p>##时间日期类</p>
<h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h3><ul>
<li>基本语法<ul>
<li>date (显示当前时间)</li>
<li>date+%Y (显示当前年)</li>
<li>date+%m (显示当前月)</li>
<li>date+%d (显示当前日)</li>
<li>date -s 字符串时间 (设置日期)</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/sT70Og" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/sT70Og.png" alt="sT70Og.png"></a></p>
<blockquote>
<p>注意那个＋号，那是格式必须的，%Y与%m之间的间隔符随意写都可%Y %m和%Y–%m都可以运行的</p>
</blockquote>
<h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><blockquote>
<p>查看日历指令</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>cal [选项] (不加选线，显示本月日历)</li>
<li>cal 年份 (显示一整年的日历)</li>
</ul>
</li>
</ul>
<h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><blockquote>
<p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>find [搜索范围] [选项]</li>
</ul>
</li>
<li>选项说明<br><a href="https://imgchr.com/i/s72kYF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/s72kYF.png" alt="s72kYF.png"></a></li>
</ul>
<blockquote>
<p>查找linux系统下大于20m的文件(+n大于 -n小于 n等于) </br><br><code>find / -size +20M</code></br><br>M要大写噢！</p>
</blockquote>
<p><strong>例子找/root目录下的.txt文件</strong></p>
<p><a href="https://imgchr.com/i/s7hVN6" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/s7hVN6.png" alt="s7hVN6.png"></a></p>
<blockquote>
<p>ps在用通识符的时候要用转义字符。</br><br><code>\*</code> 或 <code>&quot;*&quot;</code> 或 <code>&#39;*&#39;</code></p>
</blockquote>
<h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h3><blockquote>
<p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件，locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>locate 搜索文件</li>
</ul>
</li>
<li>特别说明<blockquote>
<p>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。</p>
</blockquote>
</li>
</ul>
<p>###grep指令和管道符号 | </p>
<blockquote>
<p>grep过滤查找，管道符，”|”，标识将前一个命令的处理结果输出传递给后面的命令处理。</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>grep[选项] 查找内容 源文件</li>
</ul>
</li>
<li>常用的选项<ul>
<li>-n 显示匹配行及行号</li>
<li>-i 忽略字母大小写  </li>
</ul>
</li>
</ul>
<h2 id="压缩和解压缩类"><a href="#压缩和解压缩类" class="headerlink" title="压缩和解压缩类"></a>压缩和解压缩类</h2><h3 id="gzip-gunzip-指令"><a href="#gzip-gunzip-指令" class="headerlink" title="gzip / gunzip 指令"></a>gzip / gunzip 指令</h3><blockquote>
<p></br>gzip是压缩文件 gunzip是解压缩文件</p>
</blockquote>
<ul>
<li>gizp 文件(压缩文件)</li>
<li>gunizp 文件(解压缩文件)</li>
</ul>
<h3 id="zip-unzip-指令"><a href="#zip-unzip-指令" class="headerlink" title="zip/unzip 指令"></a>zip/unzip 指令</h3><blockquote>
<p>zip用于压缩文件，unzip用于解压文件，这个在项目的打包发布中很有用</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>zip [选项] XXX.zip 将要压缩的内容</li>
<li>unzip [选项] XXX.zip </li>
</ul>
</li>
<li>zip常用选项<ul>
<li>r：递归压缩，即压缩目录</li>
</ul>
</li>
<li>unzip的常用选项<ul>
<li>d&lt;目录&gt; :指定解压文件的存放目录    </li>
</ul>
</li>
</ul>
<h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><blockquote>
<p>tar 指令是打包指令，最后打包后的文件是.tar.gz的文件</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>tar [选项] XXX.tar.gz 打包的内容(功能描述：打包目录，压缩后的文件格式.tar.gz)</li>
</ul>
</li>
<li>选项说明<hr>
[![s7HRFs.png](https://s3.ax1x.com/2021/01/23/s7HRFs.png)](https://imgchr.com/i/s7HRFs)

</li>
</ul>
<p>在/root目录下打包aa.txt和a.txt 并保存<br><a href="https://imgchr.com/i/s7bFkd" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/23/s7bFkd.png" alt="s7bFkd.png"></a></p>
<blockquote>
<p>注意的点：打包是选项参数是 -zcvf<br></br>解包是 -zxvf</p>
</blockquote>
<p>##组管理和权限管理<br><strong>文件/目录所有者</strong></p>
<blockquote>
<p>一般为文件的创建者，谁创建了该文件，就自然的成为了该文件的所有者。</p>
</blockquote>
<h3 id="查看文件所有者"><a href="#查看文件所有者" class="headerlink" title="查看文件所有者"></a>查看文件所有者</h3><ul>
<li>指令：ls -ahl</li>
<li>实例：创建一个组police，再创建一个用户tom，将tom放在police组，然后使用tom来创建一个文件ok.txt,看看情况如何。</li>
</ul>
<p><a href="https://imgchr.com/i/sbdCnS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/24/sbdCnS.png" alt="sbdCnS.png"></a></p>
<p><a href="https://imgchr.com/i/sbdQ74" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/24/sbdQ74.png" alt="sbdQ74.png"></a></p>
<blockquote>
<p>先通过groupadd 加了一个police 再通过useradd加了一个tom用户 通过XShell登录tom用户创建了一个ok.txt文件。</p>
</blockquote>
<h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><ul>
<li>基本语法<ul>
<li>chown (change owner) 用户名 文件名</li>
<li>chown newowner:newgroup file 改变用户的所有者和所有组</li>
<li>-R 如果是目录则使其下所有子文件或目录递归生效</li>
</ul>
</li>
</ul>
<h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><ul>
<li>基本指令<ul>
<li>groupadd 组名</li>
</ul>
</li>
</ul>
<h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><ul>
<li>基本指令<ul>
<li>chgrp 组名 文件名</li>
</ul>
</li>
</ul>
<h2 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h2><p><a href="https://imgchr.com/i/sbscgs" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/24/sbscgs.png" alt="sbscgs.png"></a></p>
<ol>
<li>代表着文件的类型：-普通文件 d:目录 l:软链接 c:字符设备[键盘，鼠标] b:快文件，硬盘。</li>
<li>表示文件所有者的权限为rw</li>
<li>代表着文件所在组的用户的权限，r–只有读权限。</li>
<li>代表文件其他组的用户的权限，r–只有读权限。</li>
<li>接着后面的 <code>1</code>代表着如果是文件就代表着硬链接  如果是目录，代表着子目录的个数</li>
</ol>
<h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><p><strong>rwx作用到文件</strong></p>
<ol>
<li>[r]代表可读(read):可以读取，查看</li>
<li>[w]代表可写(write)：可以修改，但是不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写的权限，才能删除该文件</li>
<li>[x]代表可执行(execute)：可以被执行</li>
</ol>
<p><strong>rwx作用到目录</strong></p>
<ol>
<li>[r]代表可读(read):可以读取，ls查看目录内容</li>
<li>[w]代表可写(write):可以修改，目录内创建+删除+重命名目录</li>
<li>[x]代表可执行(execute):可以进入该目录</li>
</ol>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><ul>
<li>基本命令<ul>
<li>u:所有者 g:所有组 o:其他人 a:所有人(o u g的总和) </li>
<li>chmod u=rwx，g=rx,o=x 文件目录名</li>
<li>chmod o+w 文件目录名</li>
<li>chmod a-x 文件目录名</li>
</ul>
</li>
</ul>
<h3 id="最佳实践-警察和土匪游戏"><a href="#最佳实践-警察和土匪游戏" class="headerlink" title="最佳实践-警察和土匪游戏"></a>最佳实践-警察和土匪游戏</h3><p>police,bandit两个组</p>
<p>jack,jeery：警察<br>xh，xq:土匪</p>
<ol>
<li>创建组</li>
<li>创建用户</li>
<li>jack 创建一个文件，自己可以读写，本组人可以读写，其他人没有任何权限</li>
<li>jack修改该文件，让其他组人可以读，本组人可以读写</li>
<li>xh 投靠警察，看看是否可以读写</li>
</ol>
<h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><h3 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h3><blockquote>
<p>crotab进行定时任务的设置。</br><br>任务调度：是指系统在某个实践执行的特定的命令或程序。</br><br>任务调度分类:</br>1.系统工作，有些重要的工作必须周而复始地运行，如病毒扫描等。</br><br>2.个别用户工作，个别用户可能希望执行某些程序，比如对mysql数据库的备份</p>
</blockquote>
<ul>
<li><p>基本语法</p>
<ul>
<li>crontab [选项]</li>
</ul>
</li>
<li><p>常用选项<br><a href="https://imgchr.com/i/sOKie1" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOKie1.png" alt="sOKie1.png"></a></p>
</li>
<li><p>快速入门</p>
</li>
</ul>
<p>设置任务调度文件：/etc/crontab 设置个人任务调度。执行crontab –e命令。 接着输入任务到调度文件<br>如：*/1 * * * * ls –l  /etc/ &gt; /tmp/to.txt<br>意思说每小时的每分钟执行ls –l /etc/ &gt; /tmp/to.txt命令</p>
<p>##<strong>参数细节说明</strong></p>
<ul>
<li>5个占位符的说明</li>
</ul>
<p><a href="https://imgchr.com/i/sOKq6H" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOKq6H.png" alt="sOKq6H.png"></a></p>
<ul>
<li>特殊符号说明</li>
</ul>
<p><a href="https://imgchr.com/i/sOMC9S" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOMC9S.png" alt="sOMC9S.png"></a></p>
<ul>
<li>特定时间执行任务案例</li>
</ul>
<p><a href="https://imgchr.com/i/sOMnhT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOMnhT.png" alt="sOMnhT.png"></a></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol>
<li>案例1：每隔1分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中 <ul>
<li><ol>
<li><code>vim mytask1.sh</code>并在里面输入<code>date &gt;&gt; /home/mydate</code></li>
</ol>
</li>
<li><ol start="2">
<li>给sh文件执行权限<code>chmod 744 mytask1.sh</code></li>
</ol>
</li>
<li><ol start="3">
<li>使用crontab定时调用<code>crontab -e</code>进入定时进程接着<code>*/1 * * * * /home/mydate</code></li>
</ol>
</li>
<li><ol start="4">
<li>一分钟后即可</li>
</ol>
</li>
</ul>
</li>
<li>案例2：每隔1分钟， 将当前日期和日历都追加到 /home/mycal 文件中 <ul>
<li><ol>
<li><code>vim mytask2.sh</code>并在里面输入<code>date &gt;&gt; /tmp/mycal</code>和<code>cal &gt;&gt; /tmp/mycal</code></li>
</ol>
</li>
<li><ol start="2">
<li>给sh文件执行权限<code>chmod 744 mytask2.sh</code></li>
</ol>
</li>
<li><ol start="3">
<li>使用crontab定时调用<code>crontab -e</code>进入定时进程接着<code>*/1 * * * * /tmp/mycal</code></li>
</ol>
</li>
<li><ol start="4">
<li>一分钟后即可</li>
</ol>
</li>
</ul>
</li>
<li>案例3:    每天凌晨2:00 将mysql数据库 testdb ，备份到文件中。</li>
</ol>
<h2 id="Linux磁盘分区和挂载"><a href="#Linux磁盘分区和挂载" class="headerlink" title="Linux磁盘分区和挂载"></a>Linux磁盘分区和挂载</h2><h3 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h3><p><strong>1) mbr分区:</strong></p>
<ol>
<li>最多支持四个主分区 </li>
<li>系统只能安装在主分区 </li>
<li>扩展分区要占一个主分区</li>
<li>MBR最大只支持2TB，但拥有最好的兼容性</li>
</ol>
<p><strong>2) gtp分区:</strong></p>
<ol>
<li>支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区）</li>
<li>最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）</li>
<li>windows7 64位以后支持gtp</li>
</ol>
<h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a><strong>Linux分区</strong></h3><p><strong>原理介绍</strong></p>
<ol>
<li><p>Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独 立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</p>
</li>
<li><p>Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目 录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一 个目录下获得。</p>
</li>
</ol>
<p><strong>硬盘说明</strong></p>
<ol>
<li><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p>
</li>
<li><p>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属 盘）,“</del>”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就 是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为 第二个IDE硬盘上的第二个主分区或扩展分区。</p>
</li>
<li><p>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余 则和IDE硬盘的表示方法一样。</p>
</li>
</ol>
<p>###查看所有设备挂载情况</p>
<ul>
<li>基本命令<ul>
<li>lsblk 或者 lsblk -f</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/sONxfA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sONxfA.png" alt="sONxfA.png"></a></p>
<blockquote>
<p>详情如下</p>
</blockquote>
<p><a href="https://imgchr.com/i/sOUEkQ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/25/sOUEkQ.png" alt="sOUEkQ.png"></a></p>
<h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><blockquote>
<p>增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p>
</blockquote>
<ul>
<li><p>步骤</p>
<ul>
<li><ol>
<li>虚拟机添加硬盘</br><br>在VM点设置虚拟机添加磁盘然后下一步下一步即可</li>
</ol>
</li>
<li><ol start="2">
<li>分区 <code>fdisk/dev/sdb</code></li>
</ol>
</li>
</ul>
<p><a href="https://imgchr.com/i/sjxz80" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sjxz80.png" alt="sjxz80.png"></a></p>
</li>
</ul>
<p><a href="https://imgchr.com/i/sjzcR0" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sjzcR0.png" alt="sjzcR0.png"></a><br>    - 3. 格式化 <code>mkfs -t ext4 /dev/sdb1</code></p>
<p><a href="https://imgchr.com/i/svSaf1" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/svSaf1.png" alt="svSaf1.png"></a><br>    - 4. 挂载 先创建一个目录 <code>mount /dev/sdb1 /home/newdisk</code><br>    - 5. 设置可以自动挂载(永久挂载，当重启系统后，仍可以挂载到 /home/newdisk)</p>
<p><a href="https://imgchr.com/i/svCvct" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/svCvct.png" alt="svCvct.png"></a></p>
<p><a href="https://imgchr.com/i/svFJ0K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/svFJ0K.png" alt="svFJ0K.png"></a></p>
<h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><h3 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h3><ul>
<li>基本语法<ul>
<li>df -h</li>
</ul>
</li>
</ul>
<h3 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h3><ul>
<li>基本语法<ul>
<li>du -h /目录</li>
</ul>
</li>
</ul>
<p><strong>查询指定目录的磁盘占用情况，默认为当前目录</strong></p>
<ul>
<li>选项  <ul>
<li>-s 指定目录占用大小汇总</li>
<li>-h 带计量单位</li>
<li>-a 含文件</li>
<li>–max-depth=1 子目录深度</li>
<li>-c 列出明细的同时，增加汇总值</li>
</ul>
</li>
</ul>
<h3 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况-工作实用指令"></a>磁盘情况-工作实用指令</h3><ol>
<li><p>统计/home文件夹下文件的个数</p>
<ul>
<li><p><code>ls -l /home | grep &quot;^-&quot; | wc -l</code></p>
<blockquote>
<p><code>&quot;^-&quot;</code>代表筛选即把文件筛选出来 wc是统计</p>
</blockquote>
<p><a href="https://imgchr.com/i/sz0qgS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/27/sz0qgS.png" alt="sz0qgS.png"></a></p>
<blockquote>
<p>grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
</blockquote>
<p><a href="https://imgchr.com/i/szBM8K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/27/szBM8K.png" alt="szBM8K.png"></a></p>
</li>
</ul>
</li>
<li><p>统计/home 下目录的个数</p>
<ul>
<li><code>ls -l /home | grep &quot;^d&quot; | wc -l</code></li>
</ul>
</li>
<li><p>统计/home文件夹下的个数，包括文件夹的子目录的个数</p>
<ul>
<li><code>ls -lR /home | grep &quot;^-&quot; | wc -l</code></li>
</ul>
</li>
<li><p>统计/home文件夹下的个数，包括文件夹的子文件夹的个数</p>
<ul>
<li><code>ls -lR /home | grep &quot;^d&quot; | wc -l</code></li>
</ul>
</li>
<li><p>以树状显示我们的目录</p>
<ul>
<li>tree 目录<blockquote>
<p>如果tree无效则先安装 yum install tree</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="配置指定固定的ip"><a href="#配置指定固定的ip" class="headerlink" title="配置指定固定的ip"></a>配置指定固定的ip</h3><ul>
<li><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code><br><a href="https://imgchr.com/i/szcmUH" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/27/szcmUH.png" alt="szcmUH.png"></a></li>
</ul>
<p><strong>修改后要重启服务</strong></p>
<ul>
<li><code>service network restart</code></li>
</ul>
<h3 id="ifcfg-eth33文件说明"><a href="#ifcfg-eth33文件说明" class="headerlink" title="ifcfg-eth33文件说明"></a>ifcfg-eth33文件说明</h3><p>DEVICE=eth0 <strong>#接口名（设备,网卡）</strong></br><br>HWADDR=00:0C:2x:6x:0x:xx  <strong>#MAC地址</strong></br><br>TYPE=Ethernet    <strong>#网络类型</strong>（通常是Ethemet） UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44  <strong>#随机id</strong></br><br>ONBOOT=yes <strong>系统启动的时候网络接口是否有效（yes/no)</strong></br><br>BOOTPROTO=static <strong>IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</strong></br><br>IPADDR=192.168.184.130 <strong>IP地址</strong></br><br>GATEWAY=192.168.184.2 <strong>网关</strong> </br><br>DNS1=192.168.184.2 <strong>域名解析器</strong></br></p>
<h2 id="进程管理-重点"><a href="#进程管理-重点" class="headerlink" title="进程管理(重点)"></a>进程管理(重点)</h2><h3 id="进程的基本介绍"><a href="#进程的基本介绍" class="headerlink" title="进程的基本介绍"></a>进程的基本介绍</h3><ol>
<li>在Linux中，每个执行的<strong>程序(代码)</strong>都称为一个进程。每个进程都分配一个ID号</li>
<li>每一个进程都会对应一个父进程，而这个父进程可以复制多个子进程，例如www服务器</li>
<li>每个进程都可能以两种形式存在，<strong>前台和后台</strong>。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但是由于屏幕上无法看到的进程，通常使用后台方式执行。</li>
<li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束。</li>
</ol>
<h3 id="查看系统执行的进程"><a href="#查看系统执行的进程" class="headerlink" title="查看系统执行的进程"></a>查看系统执行的进程</h3><ul>
<li>基本语法<ul>
<li>ps -aux</li>
</ul>
</li>
</ul>
<p><strong>ps显示的信息选项：<br></strong></p>
<ol>
<li>PID : 进程识别号</li>
<li>TTY ： 终端机号</li>
<li>TIME ： 此进程所消耗的cpu时间</li>
<li>CMD : 正在执行的命令或进程名</li>
</ol>
<p><strong>2)    指令说明</strong></p>
<ul>
<li>System V展示风格</li>
<li>USER：用户名称</li>
<li>PID：进程号</li>
<li>%CPU：进程占用CPU的百分比</li>
<li>%MEM：进程占用物理内存的百分比</li>
<li>VSZ：进程占用的虚拟内存大小（单位：KB）</li>
<li>RSS：进程占用的物理内存大小（单位：KB）</li>
<li>TT：终端名称,缩写 .</li>
<li>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通<br>优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li>
<li>STARTED：进程的启动时间</li>
<li>TIME：CPU时间，即进程使用CPU的总时间</li>
<li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li>
</ul>
<h3 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h3><ul>
<li><p>基本语法</p>
<ul>
<li>kill [选项] 进程号(通过进程号杀死进程)</li>
<li>killall 进程名称 (通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢的时候有用)</li>
</ul>
</li>
<li><p>常用选项</p>
<ul>
<li>-9 表示强迫进程立即结束</li>
</ul>
</li>
<li><p>案例</p>
<ol>
<li>踢掉某个非法登录用户<br><a href="https://imgchr.com/i/yiTQ5d" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/29/yiTQ5d.png" alt="yiTQ5d.png"></a></li>
<li>终止远程登录服务sshd，在适当的时候再次启动<ul>
<li>ps -aux | grep sshd</li>
<li>kill PID(此PID是要结束的用户的ID)</li>
</ul>
</li>
<li>终止多个gedit编辑器<ul>
<li>killall gedit</li>
</ul>
</li>
<li>强制杀掉一个终端<ul>
<li>kill -9 UID(进程的UID)</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="服务-service-管理"><a href="#服务-service-管理" class="headerlink" title="服务(service)管理"></a>服务(service)管理</h2><blockquote>
<p>介绍：</br><br>service 本质就是进程但是我们运行在后台，通常都会监听某个端口，等待其他程序的请求，比如(mysql,sshd,防火墙等),因此我们又称为守护进程，是Linux中非常重要的知识点。</p>
</blockquote>
<h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><blockquote>
<p>通过chkconfig命令可以给每个服务的各个运行级别设置自启动/关闭</p>
</blockquote>
<ul>
<li>基本语法<ul>
<li>chkconfig –list|grep xxx（查看服务）</li>
<li>chkconfig 服务名 –list</li>
<li>chkconfig –level 5 用户名 on/off</li>
</ul>
</li>
</ul>
<blockquote>
<p>CentOS 6适用</p>
</blockquote>
<p>###systemctl list-unit-files</p>
<blockquote>
<p>是上面的指令，在CentOS 7中的实现</p>
</blockquote>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><blockquote>
<p>top与ps指令很相似，它们都用来显示正在执行的进程。Top和ps最大的不同之处，在于top在执行一段时间可以更新正在运行的进程。</p>
</blockquote>
<ul>
<li><p>基本语法</p>
<ul>
<li>top [选项]</li>
</ul>
</li>
<li><p>基本选项</p>
<ul>
<li>-d</li>
<li>-i</li>
<li>-p</li>
</ul>
</li>
<li><p>案例</p>
</li>
</ul>
<ol>
<li>输入top之后输入u，即可查找特定用户的进程状态</li>
<li>输入top之后输入k，再输入特定的ID号即可杀掉该指令</li>
</ol>
<blockquote>
<p>我安装了一个htop，所以使用htop更好</p>
</blockquote>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><ul>
<li><p>基本语法</p>
<ul>
<li>netstat[选项]</li>
</ul>
</li>
<li><p>选项说明</p>
<ul>
<li>-an 按一定顺序排序输出</li>
<li>-p 显示哪一个进程在调用</li>
</ul>
</li>
<li><p>应用案例</p>
<ul>
<li>查看服务名为sshd的服务的信息</li>
</ul>
</li>
</ul>
<h2 id="RPM与YUM包"><a href="#RPM与YUM包" class="headerlink" title="RPM与YUM包"></a>RPM与YUM包</h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><ul>
<li>介绍<blockquote>
<p>一种用于互联网下载包的打包及安装工具，它包含在<strong>某些Linux分发版</strong>中，他声称具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，着一文件格式名称虽然打上了ReaHat的标志，但是理念是通用的</p>
</blockquote>
</li>
</ul>
<p><strong>rpm包的管理</strong></br></p>
<p>rpm包的简单查询指令:查询已安装的rpm列表 rpm -qa|grep xx</p>
<ul>
<li>指令等<ul>
<li>rpm -q 软件名：查询软件包是否安装</li>
<li>rpm -qi 软件包名：查询软件包信息</li>
<li>rpm -ql 软件包名：查询软件包中的文件</li>
<li>rpm -qf 文件全路径名 查询文件所属的软件包</li>
<li>rpm -e 删除</li>
<li>rpm -ivg RPM包全路径名称<ul>
<li>参数说明<ul>
<li>i:install 安装</li>
<li>v:verbose 提示</li>
<li>h:hash 进度条</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="yum包"><a href="#yum包" class="headerlink" title="yum包"></a>yum包</h3><blockquote>
<p>Yum是一个Shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p>
</blockquote>
<p><strong>yum的基本指令</strong></br></p>
<ul>
<li><p>查询yum服务器是否有需要安装的软件</p>
<ul>
<li>yum list|grep xx 软件列表</li>
</ul>
</li>
<li><p>安装指定的yum包</p>
<ul>
<li>yum install xxx 下载安装  </li>
</ul>
</li>
<li><p>查询是否有 firefox的rpm包<br><a href="https://imgchr.com/i/yEHT58" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/31/yEHT58.md.png" alt="yEHT58.md.png"></a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
