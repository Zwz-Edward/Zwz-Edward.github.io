<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZWZ的博客嘻嘻">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">重载与重写的区别</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-15 20:40:42" itemprop="dateModified" datetime="2020-04-15T20:40:42+08:00">2020-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>– Time:2020.4.15.</p>
<h2 id="重载和重写傻傻分不清楚"><a href="#重载和重写傻傻分不清楚" class="headerlink" title="重载和重写傻傻分不清楚"></a>重载和重写傻傻分不清楚</h2><h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h3><p>重写就是子类对父类的允许访问的方法的实现过程进行重新编写，<strong>返回值和形参</strong>都不能改变。<strong>即外壳不变，核心重写</strong></br><br>重写的好处就在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。在原则中，重写意味着可以重写任何现有的方法。例如</p>
<pre><code>class Animal{
    public void move(){
        System.out.println(&quot;hh&quot;);
    }
}
class Dog extends Animal{
    public void move(){   //这里重写了父类的move()方法。
        System.out.println(&quot;hhh&quot;)
    }
}
public class [文件名]{
    public static void main(String[] args){
        Animal a = new Animal();//创建Anmial对象
        Animal b = new Dog();//创建Dog对象

        a.move();//调用Anmial方法
        b.move();//调用Dog中重写的方法
    }
}</code></pre><p>以上的结果会是</p>
<pre><code>hh    //(这是Anmial的方法)
hhh //(这是Dog类的方法)</code></pre><p>但是如果我们在子类Dog里面加一句且在在主函数中</p>
<pre><code>class Animal{
   public void move(){
      System.out.println(&quot;动物可以移动&quot;);
   }
}
class Dog extends Animal{
   public void move(){
      System.out.println(&quot;狗可以跑和走&quot;);
   }
   public void bark(){
      System.out.println(&quot;狗可以吠叫&quot;);//新增的方法
   }
}

public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象

      a.move();// 执行 Animal 类的方法
      b.move();//执行 Dog 类的方法
      b.bark();
   }
}</code></pre><p>结果就会报错，因为在Animal里面没有bark()方法</p>
<h4 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h4><ul>
<li>参数列表必须完全与被重写方法的相同。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为final的方法不能被重写。</li>
<li>声明为static的方法不能被重写，当可以再次被声明。比如</li>
</ul>
<pre><code>public static void Zwz(){
    方法体
}  //父类
public static void Zwz(){
    方法体
}  //子类再次声明static     </code></pre><ul>
<li>子类和父类在同一个包中，那么子类可以重写父类的所有方法，除了private和final的方法</li>
<li>子类与父类不在同一个包内，子类只能重写父类的声明为public和protected的非final方法</li>
<li>构造方法不能重写</li>
<li>如果不能继承一个方法，就不能重写这个方法</li>
</ul>
<h4 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h4><p>在子类中要调用父类的方法的时候就要用super关键字</p>
<pre><code>class Animal{
   public void move(){
      System.out.println(&quot;动物可以移动&quot;);
   }
}

class Dog extends Animal{
   public void move(){
      super.move(); // 应用super类的方法
      System.out.println(&quot;狗可以跑和走&quot;);
   }
}

public class TestDog{
   public static void main(String args[]){

      Animal b = new Dog(); // Dog 对象
      b.move(); //执行 Dog类的方法

   }
}</code></pre><blockquote>
<p>方法执行的都是Dog里面的语句</p>
</blockquote>
<pre><code>动物可以移动
狗可以跑和走</code></pre><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>重载是在一个类中，<strong>方法名字相同而参数不同</strong>返回类型可以相同或者不同。</br><br>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表。常用于构造器(构造方法)的重载。</p>
<h4 id="重载规则："><a href="#重载规则：" class="headerlink" title="重载规则："></a>重载规则：</h4><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常(不懂)</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区别标准</li>
</ul>
<p>例子</p>
<pre><code>public class Overloading {
    public int test(){
        System.out.println(&quot;test1&quot;);
        return 1;
    }

    //加入了参数与上面的不一样
    public void test(int a){
        System.out.println(&quot;test2&quot;);
    }   

    //以下两个参数类型顺序不同
    public String test(int a,String s){
        System.out.println(&quot;test3&quot;);
        return &quot;returntest3&quot;;
    }   

    public String test(String s,int a){
        System.out.println(&quot;test4&quot;);
        return &quot;returntest4&quot;;
    }   

    public static void main(String[] args){
        Overloading o = new Overloading();
        System.out.println(o.test());
        o.test(1);
        System.out.println(o.test(1,&quot;test3&quot;));
        System.out.println(o.test(&quot;test4&quot;,1));
    }
}</code></pre><p>会输出</p>
<pre><code>test1            //public int test()输出结果
1                //public int test()输出结果
test2            //public void test(int a)输出结果
test3            //public String test(int a,String s)输出结果
returntest3        //public String test(int a,String s)输出结果
test4            //public String test(String s,int a)输出结果
returntest4        //public String test(String s,int a)输出结果</code></pre><h3 id="重载和重写之间的区别"><a href="#重载和重写之间的区别" class="headerlink" title="重载和重写之间的区别"></a>重载和重写之间的区别</h3><table>
        <tr>
            <th>区别点</th>
            <th>重载方法</th>
            <th>重写方法</th>
        </tr>
        <tr>
            <th>参数</th>
            <th>列表必须修改</th>
            <th>一定不能修改</th>
        </tr>
        <tr>
            <th>返回类型</th>
            <th>可以修改</th>
            <th>一定不能修改</th>
        </tr>
        <tr>
            <th>异常</th>
            <th>可以修改</th>
            <th>可以减少或删除，一定不能抛出新的或者更广的异常</th>
        </tr>
        <tr>
            <th>访问</th>
            <th>可以修改</th>
            <th>一定不能做更严格的限制(可以降低限制)</th>
        </tr>
</table>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ol>
<li><p>方法重载是一个类中定义了多个方法名相同，而题目的参数的数量不同或数量相同而类型和次序不同，则成为方法的重载。</p>
</li>
<li><p>方法重写是在子类存在的方法与父类方法同名而且参数个数与类型一样，返回值也一样的方法，就叫做重写。</p>
</li>
<li><p>方法重载是一个类的多态性的表现，而方法重写是子类与父类的一种多态性表现。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png" alt=""><br><img src="https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png" alt=""></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E8%87%AA%E5%B7%B1%E6%91%B8%E7%B4%A2%E7%9A%84C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E8%87%AA%E5%B7%B1%E6%91%B8%E7%B4%A2%E7%9A%84C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">自己摸索的C语言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-28 21:42:04" itemprop="dateModified" datetime="2020-03-28T21:42:04+08:00">2020-03-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从零开始的C语言生活"><a href="#从零开始的C语言生活" class="headerlink" title="从零开始的C语言生活"></a>从零开始的C语言生活</h1><p><strong>苦逼大学生被迫学习C语言</strong></p>
<p>IDE当然是我们可爱微软的VS2010的啦(2019不会用）<br>这软件不同于Devc++,每个源文件只能有一个主函数。<br><br/><br><br/><br>必须要记住的头文件，以及引用的库，以及最后返回空。</p>
<ol>
<li><code>#include &lt;stdio.h&gt;</code></li>
<li><code>#inclde &lt;stdlib.h&gt;</code></li>
<li><code>system(&quot;pause&quot;);</code></li>
<li><code>return 0;</code><blockquote>
<p>system在”studlib.h”的库里面定义了，所以可以直接用，没有引用此库是用不了的wo~</p>
</blockquote>
</li>
</ol>
<p>一开始学的当然是<code>printf(&quot;Hello World!\n&quot;)；</code>没啥好说的。接下来就是学习了一些基本的运算符。简单背一背还是会用的</p>
<hr/>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数始终是我有点头疼的点。<br/></p>
<ol>
<li>全局定义一个函数<br/></li>
<li>主函数里面直接运用<br/></li>
<li>主函数后解释函数的功能（注意是否有实参，有则需要返回值。<br/></li>
</ol>
<p>一个小例子<br/></p>
<ol>
<li><code>int max (int x,int y,int z)</code> /* 函数声明 */</li>
<li><code>int main{return 0;}</code>    </li>
<li><code>int max (int x,int y,int z)</code> /* 再写max函数代表什么意思 */<blockquote>
<p>一个标准的引用实参例子 (大概~</p>
</blockquote>
<hr/>

</li>
</ol>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>其实学起来不难会用才叫难。</p>
</blockquote>
<p>指针：其值为另一个变量的地址。</br><br>指针变量：就是变量存储了一分数据的指针。</br><br>例如：现在假设有一个 char 类型的变量 c，它存储了字符 ‘K’（ASCII码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。</br><br><img src="http:c.biancheng.net/uploads/allimg/190114/1IG34354-0.png" alt=""></br><br></br><br>由于指针储存的内容是地址所以给指针赋值的时候需要用上取地址符&amp;，例如：<code>int *p=&amp;a;</code></br><br>在定义指针的时候必须带有<code>*</code>，但是再次给指针赋值的时候不带<code>*</code>，例如：<code>int *p; p=&amp;b;</code></br></p>
<blockquote>
<p>CPU读写数据必须要知道数据在内存中的地址，普通变量和指针变量不过是地址的助记符，虽然<em>p和a获得的数据一样,但是他们运行过程稍有不同，a一次就可以获取数据，</em>p需要两次。</p>
</blockquote>
<p>例如变量a、p地址为0X1000、0XF0A0，指向关系如下：</br><br><img src="http://c.biancheng.net/uploads/allimg/190114/1IG3MJ-2.jpg" alt=""></br></p>
<p>也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。</p>
<p>一个小小的案例:</p>
<pre><code>   #include &lt;stdio.h&gt;

int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */

   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */

   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );

   /* 在指针变量中存储的地址 */
   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );

   /* 使用指针访问值 */
   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );

   return 0;
}</code></pre><p>执行完会有</p>
<pre><code>Address of var variable: bffd8b3c
Address stored in ip variable: bffd8b3c
Value of *ip variable: 20</code></pre><p>很明显在 <code>ip</code>与<code>*ip</code>有所不同，<code>ip</code>取的是地址，<code>*ip</code>取的是值</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</br><br><img src="https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg" alt=""></p>
<p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：</p>
<pre><code>int main ()
{
       int  var;
       int  *ptr;
       int  **pptr;

       var = 3000;

       /* 获取 var 的地址 */
       ptr = &amp;var;

       /* 使用运算符 &amp; 获取 ptr 的地址 */
       pptr = &amp;ptr;

       /* 使用 pptr 获取值 */
       printf(&quot;Value of var = %d\n&quot;, var );
       printf(&quot;Value available at *ptr = %d\n&quot;, *ptr );
       printf(&quot;Value available at **pptr = %d\n&quot;, **pptr);

       return 0;
}</code></pre><p>会输出</p>
<pre><code>Value of var = 3000
Value available at *ptr = 3000
Value available at **pptr = 3000</code></pre><h3 id="传递指针给函数"><a href="#传递指针给函数" class="headerlink" title="传递指针给函数"></a>传递指针给函数</h3><p>例如：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void getSeconds(unsigned long *par);

int main ()
{
       unsigned long sec; /* 定义无符号long型 */


       getSeconds(&amp;sec);/* 把sec的地址赋给函数形参(即指针par) */

       /* 输出实际值 */
       printf(&quot;Number of seconds: %ld\n&quot;, sec);

       return 0;
}

void getSeconds(unsigned long *par)
{
       /* 获取当前的秒数 */
       *par = time( NULL );
       return;
}</code></pre><h2 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h2><p>结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>定义结构，必须用struct语句。struct语句定义了一个包含多个成员的新的数据类型<br>格式如下：</p>
<pre><code>struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;</code></pre><p>Tag 是结构体标签。</p>
<p>member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p>
<p>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</p>
<blockquote>
<p>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。</p>
</blockquote>
<p>初始化结构体变量：</p>
<pre><code>struct Books
{
       char  title[50];
       char  author[50];
       char  subject[100];
       int   book_id;
} book = {&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456}; //与上面相互对应

int main()
{
    printf(&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;, book.title, book.author, book.subject, book.book_id);
}</code></pre><p>会输出</p>
<pre><code>title : C 语言
author: RUNOOB
subject: 编程语言
book_id: 123456</code></pre><p>我们也可以不必在struct的末尾定义一个变量 例如：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};                                        //千万别忘记加逗号

int main()
{
    struct Books book1;                    //定义变量
    struct Books book2;
    strcpy (book1.title,&quot;I love Java&quot;); //&lt;string.h&gt;提供的为变量赋字符串的功能
    strcpy (book1.author,&quot;ZWZ&quot;);
    strcpy (book1.subject,&quot;JAVA&quot;);
    book1.book_id = 1000;

    printf(&quot;Title =%s\n&quot;,book1.title); //由于是字符串，要用%s
    printf(&quot;Author =%s\n&quot;,book1.author);
    printf(&quot;Subject =%s\n&quot;,book1.subject);
    printf(&quot;id =%d\n&quot;,book1.book_id);
    system(&quot;pause&quot;);
    return 0;
}</code></pre><p>也会输出</p>
<pre><code>Title =I love Java
Author =ZWZ
Subject =JAVA
id =1000</code></pre><p>还能作为函数体参数/指针</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
void Print(struct Books book); //book改为*book
int main()
{    
    struct Books book1;
    strcpy(book1.title,&quot;I Love Java&quot;);
    strcpy(book1.author,&quot;ZWZ&quot;);
    strcpy(book1.subject,&quot;Java&quot;);
    book1.book_id = 10;

    Print(book1);                //book1改为寻址&amp;book1

    system(&quot;pause&quot;);
    return 0;
}
void Print(struct Books book)
{
    printf (&quot;Title = %s\n&quot;,book.title); //book.title改为 book-&gt;title 如下类似
    printf (&quot;author = %s\n&quot;,book.author);
    printf (&quot;subject = %s\n&quot;,book.subject);
    printf (&quot;Id = %d\n&quot;,book.book_id); 
}</code></pre><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式</p>
<p>基本格式是：</p>
<pre><code>union union tap
{    
    标准的变量定义
    标准的变量定义
    ...
}[one or more union variables]</code></pre><p>在使用共同体时候应注意不能一次性给多个变量赋值例如：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Data
{
   int i;
   float f;
   char  str[20];
};

int main( )
{
   union Data data;        

   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, &quot;C Programming&quot;);

   printf( &quot;data.i : %d\n&quot;, data.i);
   printf( &quot;data.f : %f\n&quot;, data.f);
   printf( &quot;data.str : %s\n&quot;, data.str);

   return 0;
}</code></pre><p>会出现    </p>
<pre><code>data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming</code></pre><p>i和f的值均有损耗没事因为最后付给变量的值占用了内存位置，即str成员可以完好输出的原因。但是换种方法就可以输出完全例如：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Data
{
   int i;
   float f;
   char  str[20];
};

int main( )
{
   union Data data;        

   data.i = 10;
   printf( &quot;data.i : %d\n&quot;, data.i);

   data.f = 220.5;
   printf( &quot;data.f : %f\n&quot;, data.f);

   strcpy( data.str, &quot;C Programming&quot;);
   printf( &quot;data.str : %s\n&quot;, data.str);

   return 0;
}</code></pre><p>会输出</p>
<pre><code>data.i : 10
data.f : 220.500000
data.str : C Programming</code></pre><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>基本的定义语法是    </p>
<pre><code>struct /* 冒号后面表示可识别的2进制位数 */
{
  unsigned int widthValidated ： ;
  unsigned int heightValidated;
} status ： ;</code></pre><p>例子：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct
{
  unsigned int age : 3;
} Age;

int main( )
{
   Age.age = 4;
   printf( &quot;Sizeof( Age ) : %d\n&quot;, sizeof(Age) );
   printf( &quot;Age.age : %d\n&quot;, Age.age );

   Age.age = 7;
   printf( &quot;Age.age : %d\n&quot;, Age.age );

   Age.age = 8; // 二进制表示为 1000 有四位，超出
   printf( &quot;Age.age : %d\n&quot;, Age.age );

   return 0;
}</code></pre><p>会输出</p>
<pre><code>Sizeof( Age ) : 4
Age.age : 4
Age.age : 7
Age.age : 0</code></pre><blockquote>
<p>很明显，把10进制转化为二进制的时候超过了位域规定的位数，则会使数据直接损坏。</p>
</blockquote>
<h2 id="typedef-和-define-区别"><a href="#typedef-和-define-区别" class="headerlink" title="typedef 和 #define 区别"></a>typedef 和 #define 区别</h2><ol>
<li>typedef只可以为类型定义字符名称，#define不仅可以定义字符名称，还可以为数值定义名称 即<code>#define True one</code> 也是可以的</li>
<li>typedef 由编译器执行解释，#define语句由预编译器进行处理的。</li>
</ol>
<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><ol>
<li>int getchar(void)只会读取单一的字符。可以用循环的方法获取多个字符</li>
<li>int putchar(int c)一次只会输出一个单一字符，亦可用循环获取。</li>
<li>char * gets(char*s)函数是读取一行s到缓冲区，直到终止符或EOF；</li>
<li>int puts(const char*s)函数吧字符串s和一个尾随的换行符写入stdout中。</li>
</ol>
<pre><code>#include &lt;stdio.h&gt;

int main( )
{
   char str[100];

   printf( &quot;Enter a value :&quot;);
   gets( str );

   printf( &quot;\nYou entered: &quot;);
   puts( str );
   return 0;
}</code></pre><p>如果输入 i love hxm<br>会弹出 i love hxm</p>
<blockquote>
<p>如果改变为str[1]，再输入以上语句，虽然会输出出结果，但是会报错！我也不知道为啥报错还能输出出来= =</p>
</blockquote>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归指的是在函数的定义中使用函数自身的方法。一个简单的求阶乘的例子：</p>
<pre><code>#include &lt;stdio.h&gt;

double factorial(unsigned int i)
{
   if(i &lt;= 1)
   {
      return 1;
   }
   return i * factorial(i - 1);
}
int  main()
{
    int i = 15;
    printf(&quot;%d 的阶乘为 %f\n&quot;, i, factorial(i));
    return 0;
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-23 10:58:00" itemprop="dateModified" datetime="2020-07-23T10:58:00+08:00">2020-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><hr>
<ul>
<li>软件架构CS/BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
</ul>
<h2 id="P1-网络编程入门"><a href="#P1-网络编程入门" class="headerlink" title="P1 网络编程入门"></a>P1 网络编程入门</h2><h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><ul>
<li><strong>C/S结构</strong>：全称为Client/Server结构，是指客户端和服务器结构，常见的有QQ，迅雷等</li>
<li><strong>B/S结构</strong>：全称为Browser/Server结构，是指浏览器和服务器结构，常见浏览器有谷歌，火狐等。</li>
</ul>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><hr>
<ul>
<li><strong>网络通信协议</strong>：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机间才能进行通信，这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时，最终完成数据交换。</li>
<li><strong>TCP/IP协议：</strong>传输控制协议/因特网互联协议(transimission Control Protocol/Internet Protocol),是Internet最基本，最广泛的协议。定义了计算机如何连入Internet，以及数据如何在它们之间传输的标准。它内部包含一系列的用于处理数据通信的协议，并用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="https://i.loli.net/2020/07/22/Ad4bSoFKqreBt97.png" alt="1595417186_1_.jpg"></p>
<h3 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h3><p>通信的协议还是比较复杂的，<code>java.net</code>包中包含的类和接口，他们提供低层次的通信细节，我们可以直接使用这些类和接口，不需要考虑其他细节。</p>
<p><code>java.net</code>包中提供了两种常见的网络协议的支持：</p>
<ul>
<li>TCP:传输控制协议(Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之气那在发送端和接收端建立逻辑连接。然后传输数据。它提供了两台计算机之间可靠无差的数据传输。<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端和服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发送连接请求。等待服务器的确认</li>
<li>第二次握手，服务器端向客户端回送一个响应。通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器发送确认信息，确认连接。整个交互过程如下图。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/07/22/Rf1Ne3xukT2DJMc.png" alt="1595421452_1_.jpg"></p>
<p>完成三次握手，链接建立之后客户端和服务器就可以开始进行数据传输了。由于这种面向链接的特性。TCP协议以保证传输数据的安全，所以应用很广泛。比如下载文件、浏览网页等。</p>
<ul>
<li>UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。数据传输时。不需要建立连接。不管对象端服务是否启动，直接将数据、数据源和目的地都封装在一个数据包中，直接发送。每个数据包的大小都在64k以内。不可以靠协议。因为无连接。所以传输速度快。但容易丢失数据。日常中，例如视频会议、QQ聊天等。</li>
</ul>
<h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul>
<li>协议：计算机网络通信必须遵守的规则，已经介绍过了。如上<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4></li>
<li>IP地址：指<strong>互联网协议地址(Internet Protocol Address)</strong>，俗称IP。IP地址用来给一个网络中的计算设备做唯一的编号。如果我们把”个人电脑”比作一台电话的话，那么IP地址就相当于电话号码。<ul>
<li>其分类为<ul>
<li>IPv4：是一个32位的二进制数。通常被分为4个字节。表示成<code>a，b，c，d</code>的形式，例如<code>192.168.1.1</code>其中a、b、c、d都是0-255之间的十进制整数，那么最多可以表示42亿个</li>
<li>IPV6：由于互联网的蓬勃发展，IP地址的需求越来越大，但是网络地址有限，使得IP贼紧张。为了扩大地址空间，拟通过IPV6重新定义地址空间，采用128位地址长度，每16个字节一组，分为8组16进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>,号称可以位全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程(应用程序)的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号就可以唯一识别标识设备中的进程了。</strong></p>
<ul>
<li>端口号：用两个字节表示的整数，它的取值范围是0-65535。其中，0-1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另一个服务或应用所占用，会导致当前程序启动失败</li>
</ul>
<p><img src="https://i.loli.net/2020/07/20/wcYpmOKXdbTHWG9.png" alt="1595204966_1_.jpg"></p>
<blockquote>
<p>端口号就像门牌号一样我们可以通过IP来寻找另一台的电脑，端口号是逻辑端口，我们无法直接查看，可以利用一些软件看到或者是用cmd命令<code>findstr &quot;PID号&quot;</code>查看是什么应用使用了该端口。</p>
</blockquote>
<blockquote>
<p>常用的端口有80 网络端口，比如<code>www.baidu.com:80</code>才可以进入，如果是<code>www.baidu.com:79</code>则进入失败。</p>
</blockquote>
<blockquote>
<p>数据库 mysql：3306 oracle：1521</p>
</blockquote>
<blockquote>
<p>Tomcat服务器：8080</p>
</blockquote>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code>三元组合，就可以标识网络中的进程了。那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><p><img src="https://i.loli.net/2020/07/20/bnOMfmxyUuwC27H.png" alt="1595206041_1_.jpg"></p>
<h2 id="TCP文件上传案例"><a href="#TCP文件上传案例" class="headerlink" title="TCP文件上传案例"></a>TCP文件上传案例</h2><p><img src="https://i.loli.net/2020/07/21/1KPBMXrcLDOS5Tm.png" alt="1595330645_1_.jpg"></p>
<p><img src="https://i.loli.net/2020/07/22/YQZy4DaPgOX9Bjk.png" alt="1595406837_1_.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0&Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0&Lambda/" class="post-title-link" itemprop="url">线程池&Lambda</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-12 15:01:46" itemprop="dateModified" datetime="2020-07-12T15:01:46+08:00">2020-07-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程池与Lambda语法"><a href="#线程池与Lambda语法" class="headerlink" title="线程池与Lambda语法"></a>线程池与Lambda语法</h1><h2 id="1-1线程间通信"><a href="#1-1线程间通信" class="headerlink" title="1.1线程间通信"></a>1.1线程间通信</h2><p>概念：多个线程在处理同一个资源，但是处理的动作(线程的任务)却不相同.</p>
<p>比如线程A用于生产包子，线程B用来吃包子，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在了线程通信的问题。</p>
<p><strong>为什么要处理线程间通信</strong></p>
<p>多个线程并发执行时，在默认CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望其执行的有规律，那么多线程之间就要有一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源</strong></p>
<p>多个线程在处理同一资源，且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作，就是多个线程在操作同一份数据时，避免对同一共享变量的争夺，也就是我们需要通过一定的手段使各个线程能有效的利用资源，而这种手段即 – <strong>等待唤醒机制</strong></p>
<h2 id="1-2等待唤醒机制"><a href="#1-2等待唤醒机制" class="headerlink" title="1.2等待唤醒机制"></a>1.2等待唤醒机制</h2><h3 id="什么是等待唤醒机制"><a href="#什么是等待唤醒机制" class="headerlink" title="什么是等待唤醒机制"></a>什么是等待唤醒机制</h3><p>这个是多个线程之间一种协作的机制，谈到线程我们经常想到的是线程间的竞争(race),比如去争夺锁，但并不是故事的全部,线程间也会有协作机制。就好比公司里你和你的同事们。你们可能存在升职的竞争，但是更多是工作上的合作</p>
<p>在一个线程进行了一些规定后，就进入了<code>wait()</code>，等待其他线程执行完他们的指定代码过后，再将其唤醒<code>notify()</code>；在多个线程进行等待时，可以使用1notifyAll()`来唤醒所有的等待线程。</p>
<p><strong>wait\notify</strong>就是一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不在参与调度。进入wait set中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即WAITING.它还要等着别的线程执行一个特别的动作，也就是<strong>通知(notify)</strong>在这个对象上等待的线程从wait set中释放。重新进入了调度队列(ready queue)中。</li>
<li>notify:则选取所同志对象的wait set 中的一个线程释放，如：餐厅有空位置后，等待就餐醉酒的顾客会先入座。</li>
<li>notifyAll：释放所同志对象在wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立刻恢复执行状态，因为它当初在同步代码块里面，而它不具有锁，所以它需要再次获得锁才可以执行，成功后才能调用wait方法之后的地方回复执行。</p>
</blockquote>
<blockquote>
<p>总结：</p>
</blockquote>
<blockquote>
<ul>
<li>如果获得锁，则从WAITING状态变成RUNNABLE状态</li>
<li>如果没获得锁，则从WAITING状态变成BLOCKED状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong>  </p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用，因为：对应的锁对象可以notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="1-3生产者与消费者问题"><a href="#1-3生产者与消费者问题" class="headerlink" title="1.3生产者与消费者问题"></a>1.3生产者与消费者问题</h2><p>等待唤醒机制其实是经典的”生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<pre><code>包子铺线程生产包子，吃货线程消费包子。当包子没有时(状态为false)，吃货线程等待，包子铺线程生产包子(即包子状态为true)，
并通知吃货线程(解除吃货的等待状态)，因为已经包子，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁
的获取情况，如果吃货获取到锁，那么就执行吃包子动作，包子吃完(包子状态为false)，并通知包子铺进程(接触包子铺的等待状态)，
吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获得情况</code></pre><p><strong>代码如下</strong></p>
<p>包子资源类：</p>
<pre><code>/*
        资源类：包子类
        设置包子的属性
            皮
            馅
            包子的状态：有 true，没有 false
*/
    public class Baozi {
        //皮
        String pi;
        //馅
        String xian;
        //包子的状态：有 true，没有 false，设置初始值为false没有包子
        boolean flag = false;
    }

包子铺线程类：

/*
    生产者(包子铺类)：是一个线程类，可以继承Thread
    设置线程任务(run)：生产包子
    对包子的状态进行判断
    true：有包子
        包子铺调用wait方法进入等待状态
    false：没有包子
        包子铺生产包子
        增加一些趣味性：交替生产两种包子
            两种状态(i%2==0)
        包子铺生产好了包子
        修改包子的状态为true
        唤醒吃货线程，让吃货线程吃包子

    注意事项：
        包子铺线程喝包子线程关系--&gt;通信(互斥)
        必须同步技术保证两个线程只能有一个在执行
        锁对象必须保证唯一。可以使用包子对象为锁对象
        包子铺类和吃货类需要把包子对象作为参数传递进来
            1.需要在成员对象位置创建一个包子变量
            2.使用带参数构造方法，为这个包子变量赋值
*/
public class BaoZiPu extends Thread{
    //定义包子变量
    private Baozi bz;

    //2.使用带参数构造方法，为这个包子变量赋值
    public BaoZiPu(Baozi bz){
        this.bz = bz;
    }

    @Override
    public void run() {
        int count = 0;
        //让包子铺一直生产包子
        while (true){
        //必须同时同步技术保证两个线程只有一个执行
        synchronized (bz) {
            //对包子的状态进行判断
            if (bz.flag == true) {
                //包子铺调用wait方法进入等待状态
                try {
                    bz.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            //被唤醒之后执行，包子铺生产包子
            //增加一些趣味性：交替生产两种包子
            if (count % 2 == 0) {
                //生产薄皮三鲜馅包子
                bz.pi = &quot;薄皮&quot;;
                bz.xian = &quot;三鲜馅&quot;;
            } else {
                //生产冰皮牛肉大葱馅包子
                bz.pi = &quot;冰皮&quot;;
                bz.xian = &quot;牛肉大葱馅&quot;;
            }
            count++;
            System.out.println(&quot;包子铺正在生产：&quot; + bz.pi + bz.xian + &quot;的包子&quot;);
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //包子铺生产好了包子
            //修改包子的状态为true
            bz.flag = true;
            //唤醒吃货线程；让吃货线程吃包子
            bz.notify();
            System.out.println(&quot;包子铺正在生产：&quot; + bz.pi + bz.xian + &quot;的包子,吃货可以开吃了&quot;);
            }
        }
    }
}</code></pre><p>吃货类：</p>
<pre><code>/*
    消费者(吃货)类：是一个线程类，可以继承Thread
    设置线程任务(run):吃包子
    对包子状态进行判断
    false：没有包子
        吃货调用wait方法进入等待状态
    true：有包子
        吃货吃包子
        吃货吃完包子
        修改包子状态为false
        吃货唤醒包子铺线程，生产包子
*/
public class ChiHuo extends Thread{
    //1.需要在成员位置创建一个包子变量
    private Baozi bz;

    //2.使用带参数和构造方法，为这个包子变量赋值
    public ChiHuo(Baozi bz){
        this.bz = bz;
    }
    //设置线程任务(吃包子)
    @Override
    public void run() {
        while (true){
            //必须同时同步技术保证两个线程只有一个执行
            synchronized (bz){
                //对包子状态进行判断
                if (bz.flag==false){
                    //吃货调用wait等待状态
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //唤醒之后执行的代码，吃包子
                System.out.println(&quot;吃货正在吃&quot;+bz.pi+bz.xian+&quot;的包子&quot;);
                //吃货吃完包子
                //秀嘎包子的状态为false
                bz.flag = false;
                bz.notify();
                System.out.println(&quot;吃货已经吃完&quot;+bz.pi+bz.xian+&quot;的包子,包子铺赶紧做包子&quot;);
                System.out.println(&quot;----------------------------------------------&quot;);

            }
        }
    }
}</code></pre><p>测试类：</p>
<pre><code>public class TestBaoZi {
    public static void main(String[] args) {
        //创建包子对象
        Baozi bz = new Baozi();
        //创建包子铺线程，开启，生产包子；
        new BaoZiPu(bz).start();
        new ChiHuo(bz).start();
    }
}</code></pre><p>执行结果：</p>
<pre><code>包子铺正在生产：薄皮三鲜馅的包子
包子铺正在生产：薄皮三鲜馅的包子,吃货可以开吃了
吃货正在吃薄皮三鲜馅的包子
吃货已经吃完薄皮三鲜馅的包子,包子铺赶紧做包子
----------------------------------------------
包子铺正在生产：冰皮牛肉大葱馅的包子
包子铺正在生产：冰皮牛肉大葱馅的包子,吃货可以开吃了
吃货正在吃冰皮牛肉大葱馅的包子
吃货已经吃完冰皮牛肉大葱馅的包子,包子铺赶紧做包子
----------------------------------------------</code></pre><h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1线程池思想概述"><a href="#2-1线程池思想概述" class="headerlink" title="2.1线程池思想概述"></a>2.1线程池思想概述</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，频繁创建线程会导致系统资源被浪费，因为创建喝销毁线程都需要时间。</p>
<p>因此线程池就解决了这麻烦。</p>
<h2 id="2-2线程池的概念"><a href="#2-2线程池的概念" class="headerlink" title="2.2线程池的概念"></a>2.2线程池的概念</h2><ul>
<li>线程池：其实就说一个容纳多个线程的容器，其中线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池很多操作都是与优化资源相关，所以说多无益。</p>
<p><img src="https://i.loli.net/2020/07/10/UzQNyHI3hEdapFb.png" alt="1594382301.jpg"></p>
<h2 id="2-3线程池的使用"><a href="#2-3线程池的使用" class="headerlink" title="2.3线程池的使用"></a>2.3线程池的使用</h2><p>java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上来讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生产一些常用的线程池，官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池，也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象的方法如下：</p>
<ul>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li>
</ul>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不关闭)；</li>
</ol>
<p>Runnable实现类代码：</p>
<pre><code>//2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
    public class Runnbale implements Runnable{
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+&quot;创建了个新线程&quot;);
        }
    }</code></pre><p>线程池测试类：</p>
<pre><code>/*
    线程池：JDK1.5之后提供的
    java.util.concurrent.Executors:线程池的工厂类，用来生产线程池
    Executors类中的静态方法：
        static ExecutorService newFixedThreadPool(int nThreads)
        创建一个可重用固定线程数的线程池

        参数：
            int nThreads：创建线程池中包含的线程数量
        返回值：
            ExecutorService接口：返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口编程)

        java.util.concurrent.ExecutorService:线程池接口
            用来从线程池中获取线程，调用start方法，执行线程任务
                submit(Runnable task) 提交一个Runnable任务用于执行
            关闭/销毁线程池的方法
                void shutdown()

         线程池的使用步骤：
            1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
            2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
            3.调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。
            4.调用ExecutorService中的方法shutdown销毁线程池(不建议使用)

*/
public class TestThreadPool {
    public static void main(String[] args) {
        //1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        //3.调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。
        es.submit(new Runnbale());
        es.submit(new Runnbale());
        es.submit(new Runnbale());
        //4.调用ExecutorService中的方法shutdown销毁线程池(不建议使用)
        es.shutdown();
    }
}</code></pre><h2 id="Lambda表达式-λ"><a href="#Lambda表达式-λ" class="headerlink" title="Lambda表达式(λ)"></a>Lambda表达式(λ)</h2><h3 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h3><p>在数学里，<strong>函数</strong>就是由输入量和输出量的一套计算方案。相对而言，面向对象过分强调”必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong></p>
<p>面向对象思想：</p>
<p>做一件事情找一个能解决这个事情的对象，调用对象的方法，完成事情。</p>
<p>函数式编程思想：只要能获取到结果，谁去做，怎么做的都不重要，重视结果而不是过程。</p>
<h2 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h2><p>###传统写法<br>当你需要启动一个线程去完成任务时，通常通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。</p>
<pre><code>public class Demo01Runnable{
    public static void main(String[] args){
        //匿名内部类
        Runnable task = new Runnable(){
            @Override
            public void run(){
                //覆盖重写抽象方法
                System.out.println(&quot;多线程任务执行!&quot;)
            }
        };
        new Thread(task).start();//启动线程
    }
}</code></pre><p>本着”一切皆为对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类，可以分析出几点内容：</p>
<ul>
<li>Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心；</li>
<li>为了指定run的方法体，不得不需要Runnable接口的实现类；</li>
<li>为了省去一个RunnableImpl实现类的麻烦，不得不使用匿名内部类；</li>
<li>必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不重写一遍，且不能写错。</li>
<li>实际上，似乎只有方法体才是关键所在。</li>
</ul>
<h2 id="3-3编程思想转换"><a href="#3-3编程思想转换" class="headerlink" title="3.3编程思想转换"></a>3.3编程思想转换</h2><p><strong>做什么，而不是怎么去做</strong></p>
<p>我们真希望创建一个匿名内部类嘛？不是，我们为了创建这件事不得不创建了一个对象罢了。我们只是想把：<strong>将run方法体内的代码传递给Thread类</strong></p>
<h2 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类可以鞋厂简单的Lambda表达式达到等效：</p>
<pre><code>public class Demo02LambdaRunnable{
    public static void main(String[] args){
        new Thread(()-&gt;System.out.println(&quot;多线程任务执行！&quot;)).start();//启动线程
    }
}</code></pre><p>这段代码和刚才的执行效果是完全相同的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有”不得不创建接口对象”的束缚，不再有”抽象方法覆盖重写”的负担。</p>
<h2 id="3-5回顾匿名内部类"><a href="#3-5回顾匿名内部类" class="headerlink" title="3.5回顾匿名内部类"></a>3.5回顾匿名内部类</h2><p>Lambda是怎么样击败面向对象的？</p>
<pre><code>()-&gt;System.out.println(&quot;多线程任务执行！&quot;)\</code></pre><p>为了了解Lambda的语义，我们需要从传统的代码起步。</p>
<p><strong>使用实现类</strong></p>
<p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start()</code>方法，而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<pre><code>/*
    创建Runnable接口的实现类，重写run方法，设置线程任务
*/
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
    }
}</code></pre><p>创建该实现类的对象作为Thread类的构造参数：</p>
<pre><code>/*
    实现Runnable接口的方式实现多线程程序
*/
public class Demo01Runnable {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl r = new RunnableImpl();
        //创建Thread类对象，构造方法中传递Runnable接口的实现类
        Thread t = new Thread(r);
        t.start();
//---------------------------------------------------------------
        //简化代码，使用匿名内部类，实现多线程程序
        Runnable run = new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
            }
        };
        new Thread(run).start();
//---------------------------------------------------------------
        //继续简化代码
        new Thread(new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
            }
        }).start();
    }
}</code></pre><h3 id="匿名内部类的好处和弊端"><a href="#匿名内部类的好处和弊端" class="headerlink" title="匿名内部类的好处和弊端"></a>匿名内部类的好处和弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>，另一方面，匿名内部类的语法——<strong>实在太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，Runnable接口有一个run方法的定义：</p>
<ul>
<li>public abstract void run();</li>
</ul>
<p>即制定了一种做事情的方案(其实就是一个函数)：</p>
<ul>
<li><strong>无参数：</strong>不需要任何条件计科执行该方案。</li>
<li><strong>无返回值：</strong>该方案不产生任何结果。</li>
<li><strong>代码块(方法体)：</strong>该方案的具体执行步骤。</li>
</ul>
<p>同语义体现在<code>Lambda</code>语法中更简单：</p>
<pre><code>()-&gt;System.out.println(&quot;多线程执行！&quot;)</code></pre><ul>
<li>前面的小括号即<code>run</code>方法的参数(无)，代表不需要任何条件；</li>
<li>中间的一个剪头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6Lambda标准格式"><a href="#3-6Lambda标准格式" class="headerlink" title="3.6Lambda标准格式"></a>3.6Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由3个部分组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<pre><code>(参数类型 参数名称)-&gt;{代码语句}</code></pre><p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空，多个参数则用逗号隔开。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7练习：使用Lambda标准格式-无参无返回值"><a href="#3-7练习：使用Lambda标准格式-无参无返回值" class="headerlink" title="3.7练习：使用Lambda标准格式(无参无返回值)"></a>3.7练习：使用Lambda标准格式(无参无返回值)</h2><p><strong>题目</strong><br>给定一个厨子<code>cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数，无返回值。</p>
<pre><code>public interface Cook {
    //定义无参数无返回值的方法
    void makeFood();
}</code></pre><p>在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出”吃饭了！”字样：</p>
<pre><code>/*
    需求：
        给定一个厨子cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值.
        使用Lambda的标准格式调用invokeCook方法，打印输出&quot;吃饭啦！&quot;字样
*/
public class Practice {
    public static void main(String[] args) {
        //调用invokeCook方法，参数是Cook接口，传递Cook接口的匿名内部类对象
        invokeCook(new Cook() {
            @Override
            public void makeFood(){
                System.out.println(&quot;吃饭了&quot;);
            }
        });

        //使用Lambda表达式，简化匿名内部类的书写
        invokeCook(()-&gt;{
            System.out.println(&quot;吃饭了&quot;);
        });
    }
    //定义一个方法，参数传递Cook接口，方法内部调用Cook接口中的方法makeFood
    public static void invokeCook(Cook cook){
        cook.makeFood();
    }
}</code></pre><blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体</p>
</blockquote>
<h2 id="3-8Lambda的参数和返回值"><a href="#3-8Lambda的参数和返回值" class="headerlink" title="3.8Lambda的参数和返回值"></a>3.8Lambda的参数和返回值</h2><pre><code>/*
    Lambda表达式又参数有返回值的练习
    需求：
        使用数组存储多个Person对象
        对数组中的Person对象使用Arrays的sort方法进行升序排序
*/
public class Practice2 {
    public static void main(String[] args) {
        Person[] arr = {
                new Person(&quot;zwz&quot;,19),
                new Person(&quot;hxm&quot;,18),
                new Person(&quot;yhx&quot;,20)
        };
/*
        //对数组中的Person对象使用Arrays的sort方法进行升序(前面-后面)排序
        Arrays.sort(arr, new Comparator&lt;Person&gt;() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()-o2.getAge();
            }
        });
*/
        //使用Lambda表达式，简化匿名内部类
        Arrays.sort(arr,(Person o1, Person o2)-&gt;{
            return o1.getAge()-o2.getAge();
        });

        //遍历数组
        for (Person p : arr){
            System.out.println(p);
        }
    }
}</code></pre><p><strong>代码分析</strong></p>
<p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序， Arrays.sort 方法需要排序规则，即 Comparator 接口的实例，抽象方法 compare 是关键；</li>
<li>为了指定 compare 的方法体，不得不需要 Comparator 接口的实现类；</li>
<li>为了省去定义一个 ComparatorImpl 实现类的麻烦，不得不使用匿名内部类；</li>
<li>必须覆盖重写抽象 compare 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；</li>
<li>实际上，只有参数和方法体才是关</li>
</ul>
<h2 id="3-9练习：使用Lambda标准格式-有参有返回"><a href="#3-9练习：使用Lambda标准格式-有参有返回" class="headerlink" title="3.9练习：使用Lambda标准格式(有参有返回)"></a>3.9练习：使用Lambda标准格式(有参有返回)</h2><p><strong>题目</strong></p>
<p>给定一个计算机<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<pre><code>public interface Calculator{
    int calc(int a,int b);
}</code></pre><p>测试类中：</p>
<pre><code>/*
    Lambda表达式有参数有返回值的练习
    需求：
        给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值
        使用Lambda的标准格式调用invokeCalc方法，完成120+130的相加计算
*/
public class Practice3 {
    public static void main(String[] args) {
        //调用invokeCalc方法，方法的参数是一个接口，可以使用匿名内部类
        invokeCalc(10, 20, new Calculator() {
            @Override
            public int calc(int a, int b) {
                return a+b;
            }
        });

        //使用Lambda表达式
        invokeCalc(120,130,(int a,int b)-&gt;{
            return a+b;
        });
    }

    //定义一个方法，参数传递两个int类型整数
    //参数传递Calculator中的方法calc计算两个整数的和

    public static void invokeCalc(int a,int b,Calculator c){
        int sum = c.calc(a,b);
        System.out.println(sum);
    }
}</code></pre><blockquote>
<p>在Lambda表达式里面 小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数。大括号表示<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><p><strong>可推导即可省略</strong></p>
<p>Lambda强调的是”做什么”而不是”怎么做”,所以凡是可以根据上下文推导得知的信息，都可以省略，比如上述还可以用简便写法。</p>
<pre><code>public static void main(String[] aegs){
    invokeCalc(120,130,(a,b) -&gt; a+b);
}</code></pre><p><strong>省略规则</strong></p>
<p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参数，</strong>则小括号可以省略。</li>
<li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号，return关键字，及其语句分号。</li>
</ol>
<h3 id="3-11-Lambda的使用前提"><a href="#3-11-Lambda的使用前提" class="headerlink" title="3.11 Lambda的使用前提"></a>3.11 Lambda的使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong></br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong></br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>P.S 有且仅有一个抽象方法的接口，称为<strong>“函数式接口”</strong></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-07 12:12:36" itemprop="dateModified" datetime="2020-07-07T12:12:36+08:00">2020-07-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程-amp-同步"><a href="#线程-amp-同步" class="headerlink" title="线程&amp;同步"></a>线程&amp;同步</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><p>一开始我们写的程序都是只有一条线程在占用 CPU 即 main(主)线程。如：</p>
<pre><code>/*
    主线程：执行主(main)方法的线程

    单线程程序：java程序中中只有一个线程
    执行从main方法开始，从上到下依次执行

    JVM执行main方法，main方法会进入到栈内存
    JVM会找操作系统开辟一条main方法通向CPU的执行路径
    CPU就可以通过这个路径来执行main方法
    而该路径有个名字叫做main(主)线程

*/
public class TestThread {
    public static void main(String[] args) {
        Person s = new Person(&quot;曾炜圳&quot;);
        s.run();

        Person s1 = new Person(&quot;黄雪蔓&quot;);
        s1.run();
    }
}</code></pre><blockquote>
<p>Person里面有对应的set，get方法。以及相应的run方法和构造方法</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><hr>
<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>
<p><img src="http://m.qpic.cn/psc?/V1330WLB2ZBOB6/.GvYSzOiitXBn4c048fBdVfnLcQfAW*9TCoZEMW8qqkXq8J0wn5vM*raZqQDS*G4APLepQic9cYmq2KBe6pBQA!!/mnull&bo=BAP.AgAAAAARB8s!&rf=photolist&t=5" alt=""></p>
<p>当执行的线程任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>public Thread():分配一个新的线程对象。</li>
<li>public Thread(String name):分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target):分配一个带有指定目标新的线程对象。</li>
<li>public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li>public String getName():获得当前线程的名字</li>
<li>public void start():导致此线程开始执行，Java虚拟机调用此线程的run方法。</li>
<li>public void run():此线程要执行的任务在此处定义代码。</li>
<li>public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停(暂停停止执行)。</li>
<li>public static Thread currentThread():返回正在执行的线程对象的引用。</li>
</ul>
<blockquote>
<p>翻阅API文档可抑制创建线程方式就两种：一种是继承Thread类方式，一种是实现Runnable接口方式。接下来分析Runnable接口方式</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码，程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也与预期一样，就说线程安全的。</p>
<p>我们通过一个案例，演示线程的安全问题：</p>
<pre><code>/*
    实现卖票案例
*/
public class RunnableImplements02 implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        //先判断票是否存在
        while (true) {
            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                ticket--;
            }
        }
    }
}


public class TestThreadSafe {
    public static void main(String[] args) {
        //创建一个Runnable接口的实现类对象
        RunnableImplements02 r = new RunnableImplements02();
        //创建一个Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread t0 = new Thread(r);
        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);

        t1.start();
        t0.start();
        t2.start();
    }
}    </code></pre><p>会出现了</p>
<pre><code>Thread-0--&gt;正在卖第100张票
Thread-2--&gt;正在卖第100张票
Thread-1--&gt;正在卖第100张票
Thread-1--&gt;正在卖第97张票
Thread-2--&gt;正在卖第97张票
Thread-0--&gt;正在卖第97张票
...</code></pre><p>如下是图解：</p>
<hr>
<blockquote>
<p>多线程执行run方法遇到的问题</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/28/YsFigBZl2nDSpxu.png" alt="1593352976_1_.jpg"></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当我们使用多个线程访问同一资源的时候，而且多线程对资源有写的操作，就容易出现线程安全问题。</p>
<p>要解决上述问题并发访问同一个资源的安全性问题：也就是解决重复票与不存在票的问题，Java提供了同步机制(synchronized)来解决</p>
<p>为了保证每个线程都能正常执行原子操作Java引入了线程同步机制。那么怎么去使用呢？有三种方法完成同步操作。</p>
<ol>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制</li>
</ol>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li>同步代码块：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只是岁这个区块的资源实行互斥访问.</li>
</ul>
<p>格式:</p>
<pre><code>synchronized(同步锁){
    需要同步操作的代码
}</code></pre><p>同步锁：</p>
<p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。<br>    1. 锁对象可以是任意类型。<br>    2. 多个线程对象，需要同一把锁。</p>
<blockquote>
<p>注意：在任何时候，只允许一个线程拥有同步锁，谁拿到锁谁就可以进入代码块。其他的线程只能等着，即(BLOCKED)状态。</p>
</blockquote>
<pre><code>/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的一种方案：使用同步代码块
    格式
        synchronized(锁对象){
            可能会出现线程安全问题的代码(访问了共享数据的代码)
        }
    注意：
        1.通过代码块中的锁对象，可以使用任意的对象
        2.必须保证多个线程使用的锁对象是同一个
        3.锁对象作用：
            把同步代码块锁住，只让一个线程在同步代码块中执行
*/
public class RunnableImpl implements Runnable                                                           {
        //定义一个多个线程共享的票源
        private int ticket = 100;

        //创建一个锁对象
        Object obj = new Object();

        //设置线程任务：卖票
        @Override
        public void run() {
            //先判断票是否存在
            while (true) {
                //创建一个同步代码块
                synchronized (obj){
                    if (ticket &gt; 0) {
                        //提高安全问题出现的概率，让程序睡眠
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        //票存在,卖票 ticket--
                        System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                        ticket--;
                    }
                }
            }
        }
    }</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><p>从而就不会出现票为负或者同一票被多线程同时卖出了</p>
<blockquote>
<p>同步代码块运行的原理</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/29/JC3mKRZbAwdf9lV.png" alt="1593407072_1_.jpg"></p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul>
<li>同步方法:使用synchronized修饰的方法，就叫做同步方法。保证A线程执行该方法的时候，其他线程只能在方法外等着</li>
</ul>
<p>格式是：</p>
<pre><code>public synchronized void method(){
    可能会产生线程安全问题的代码
}</code></pre><blockquote>
<p>同步锁是谁？<br>对于非static方法，同步锁就是this。<br>对于static方法，我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<p>使用同步方法代码如下：</p>
<pre><code>/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的第二种方案：使用同步方法
    使用步骤:
        1.把访问了共享数据的代码抽取出来，放到一个方法中
        2.在方法上添加一个synchronize修饰符

    格式：定义方法的格式
    修饰符 synchronize 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码(访问了共享数据的代码)
    }
*/
public class RunnableImpl implements Runnable {
        //定义一个多个线程共享的票源
        private int ticket = 100;

        //创建一个锁对象
        Object obj = new Object();

        //设置线程任务：卖票
        @Override
        public void run () {
            System.out.println(&quot;this:&quot; + this);
            //先判断票是否存在
            while (true) {
                payTicket();
            }
        }


        /*
            定义一个同步方法
            同步方法也会把方法内部的代码锁住
            只让一个线程执行
            同步方法的锁对象是谁？
            就是实现类对象 new RunnableImpl()
            也就是this
        */
        public synchronized void payTicket(){
            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                //票存在,卖票 ticket--
                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                ticket--;
            }
        }
}</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        System.out.println(&quot;run：&quot; + run);
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。</p>
<p>Lock锁也叫做同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code>：加同步锁</li>
<li><code>public void unlock()</code>：释放锁</li>
</ul>
<p>使用方法如下：</p>
<pre><code>import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*
    卖票案例出现了线程安全问题
    卖出了不存在的票和重复的票

    解决线程安全问题的三种方案：使用lock锁
    java.util.concurrent.locks
    lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁对操作。
    Lock接口中的方法:
        void lock()获取锁
        void unlock()释放锁
    java.util.concurrent.locks.ReentrantLock implements Lock接口

    使用步骤：
        1.在成员位置创建一个ReentrantLock对象
        2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
        3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁

*/
public class RunnableImpl implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //1.在成员位置创建一个ReentrantLock对象
    Lock l = new ReentrantLock();

    //设置线程任务：卖票
    @Override
    public void run() {
        System.out.println(&quot;this:&quot; + this);
        //先判断票是否存在
        while (true) {
            //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
            l.lock();

            if (ticket &gt; 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                    //票存在,卖票 ticket--
                    System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);
                    ticket--;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
                    l.unlock();//无论程序是否异常都会把锁释放
                }
            }
        }
    }</code></pre><hr>
<pre><code>public class TestSynchronized {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        System.out.println(&quot;run：&quot; + run);
        //创建Thread对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法
        t0.start();
        t2.start();
        t1.start();
    }
}</code></pre><h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><blockquote>
<p>线程的状态</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/29/CAv8iy34BNsPajh.png" alt="1593433469_1_.jpg"></p>
<ul>
<li>NEW 至今尚未启动的线程处于这种状态。</li>
<li>RUNNABLE 正在Java JVM中执行的线程处于这种状态</li>
<li>BLOCKED受阻塞并等待某一个监视器锁的线程处于这种状态。</li>
<li>WAITING 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</li>
<li>TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。</li>
<li>TERMINATED 已退出的线程处于这种状态。</li>
</ul>
<p>阻塞状态：具有CPU的执行资格，等待CPU空闲时执行。<br>休眠状态：放弃CPU的执行资格，CPU空闲也不执行。</p>
<p>通过<code>new Thread()</code>或者<code>new Thread子类</code>获得一个新建的线程。通过<code>start()</code>方法会使线程进入<code>RUNNABLE</code>运行状态。如果<strong>CPU被占</strong><code>则会进入BLOCKED</code>阻塞状态。由于多个线程之间会互相抢夺CPU的执行时间。因此线程可能会进入<code>BLOCKED-&gt;RUNNABLE-&gt;BLOCKED...</code>阻塞运行相互转换的过程。当<code>run()</code>方法执行完后或者执行<code>stop()</code>方法。线程就会死亡，进入<code>TERMINATED</code>死亡状态。</p>
<p>在<code>RUNNABLE</code>状态下使用<code>sleep(long)\wait(long)</code>都会让线程进入<code>TIMED_WAITING</code>(休眠状态)当计时器结束。则会根据CPU的情况进入<code>BLOCKED</code>或者<code>RUNNABLE</code>状态。</p>
<p>在<code>RUNNABLE</code>状态下使用<code>Object.wait()</code>会使线程进入<code>WAITING</code>(无限等待状态) 通过<code>Object.notify()</code>根据CPU被占用情况进入<code>RUNNABLE\BLOCKED</code>状态。</p>
<blockquote>
<p><code>TIMED_WAITING\WAITING</code>两种状态均为冻结状态。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">方法与构造方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 22:19:20" itemprop="dateModified" datetime="2020-04-30T22:19:20+08:00">2020-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="方法与构造方法"><a href="#方法与构造方法" class="headerlink" title="方法与构造方法"></a>方法与构造方法</h1><p>我们常用的System.out.println()，是什么呢？</p>
<ul>
<li>println()是一个方法。</li>
<li>System是系统类。</li>
<li>out是标准输出对象。</li>
</ul>
<p>这句话的意思就是调用系统类System中的标准输出对象out中的方法println().</p>
<h2 id="那什么是方法呢？"><a href="#那什么是方法呢？" class="headerlink" title="那什么是方法呢？"></a>那什么是方法呢？</h2><p>Java方法是语句的集合，它们在一起执行一个功能。就像C的函数一样。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h2 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h2><ul>
<li>使程序变得更简短而清晰。</li>
<li>有利于维护程序</li>
<li>可以提高程序开发的效率</li>
<li>提高了代码的重用性</li>
</ul>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<pre><code>修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值；
}</code></pre><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需要的操作，但没有返回值。这种情况下，returnValueType 是关键字void。</li>
<li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>参数类型：参数像一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数，参数是可选的，方法可以不包含任何参数。</li>
<li>方法体：方法体包含具体的语句，定义该方法的功能。<br><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1220955916.jpg" alt=""></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E6%8C%BA%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E6%8C%BA%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">挺重要的控制字符串</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-24 15:58:58" itemprop="dateModified" datetime="2020-05-24T15:58:58+08:00">2020-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>class practiceContorlString {
    public static void main(String[] args) {
        //--------------------------------------------------------------------
        //给出一句英文句子： &quot;let there be light&quot;
        //得到一个新的字符串，每个单词的首字母都转换为大写
        String str6 = &quot;let there be light&quot;;
        String []str7 = str6.split(&quot; &quot;);
        String str8=&quot;&quot;;
        String str9=&quot;&quot;;
        for(int i=0;i&lt;str7.length;i++){
            str8 = str7[i].substring(0,1).toUpperCase()+str7[i].substring(1);
            str8 = str8 + &quot; &quot;;
            str9+=str8;
        }
        System.out.println(str9);
        // --------------------------------------------------------------------
        //英文绕口令
        //peter piper picked a peck of pickled peppers
        //统计这段绕口令有多少个以p开头的单词
        String str = &quot;peter piper picked a peck of pickled peppers&quot;;
        String []str1 = str.split(&quot; &quot;);
        int count = 0;
        for (String temp : str1){
            if (temp.charAt(0)==&apos;p&apos;)
                count++;
        }
        System.out.println(&quot;p次数：&quot; + count);
        //--------------------------------------------------------------------
        //Nature has given us that two ears, two eyes, and but one tongue, to the end that we should hear and see more than we speak
        //把最后一个two单词首字母大写
        String str2 = &quot;Nature has given us that two ears, two eyes, and but one tongue,&quot; +
                      &quot; to the end that we should hear and see more than we speak&quot;;
        char []arr =  str2.toCharArray();
        int index = str2.lastIndexOf(&quot;two&quot;);
        for (int i = index; i &lt; index+1;i++){
            int c = arr[i]-32;
            char c1 = (char)c;
            arr[i] = c1;
        }
        String str10 = String.valueOf(arr);
        System.out.println(str10);


        //--------------------------------------------------------------------
        //把 legendary 最后一个字母变大写
        String str3 = &quot;legendary&quot;;
        String str4 = str3.substring(0,str3.length()-1) +
                      str3.substring(str3.length()-1).toUpperCase();
        System.out.println(str4);
        //--------------------------------------------------------------------
        //把 lengendary 改成间隔大写小写模式，即 LeNgEnDaRy
        String str5 = &quot;legendary&quot;;
        char[] cs = str5.toCharArray();
        for (int i = 0;i&lt;str5.length();i++){
            if (i%2 == 0)
                cs[i] = Character.toUpperCase(cs[i]);
        }
        String c = String.valueOf(cs);
        System.out.println(c);

        //--------------------------------------------------------------------
    }

}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E5%88%9D%E5%AD%A6JS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E5%88%9D%E5%AD%A6JS/" class="post-title-link" itemprop="url">初学JS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-22 11:46:42" itemprop="dateModified" datetime="2020-03-22T11:46:42+08:00">2020-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="刚开始学JavaScript"><a href="#刚开始学JavaScript" class="headerlink" title="刚开始学JavaScript"></a>刚开始学JavaScript</h1><hr>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>“是一种脚本语言，主要用于Web。它用于增强HTML页面，通常可以嵌入HTML代码中。JavaScript是一种解释型语言。因此，它不需要编译。”</p>
</blockquote>
<br/>
简单来说:"根据用户做的一些操作，来修改页面的样式，属性等，叫做js。"(个人理解

<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>ECMAScript 解释器是JS的核心</li>
<li>DOM:Document Object Model（文档对象模型） 操作HTML文档 在JS里面就是document这个用处</li>
<li>BOM：Browser Object Model (浏览器对象模型)</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>类型：typeof运算符</br><br>常见的变量类型有：number,string,boolean,undefined,object,funtion</br><br>类型转换:</br><br>parseInt()、paarseFloat()</br><br><code>==</code>：先转换类型后比较</br><br><code>===</code>:不转换类型直接比较</br><br>NaN：不是一个数字</p>
<h4 id="运算符-基本语句……"><a href="#运算符-基本语句……" class="headerlink" title="运算符 基本语句……"></a>运算符 基本语句……</h4><p>语句大致跟C语言的一样的，可以参照C语言的语句</p>
<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>一个十分类似python的字典的东西 例如python里面用到的<code>for i in ..</code>语句在JS里面也可以运用，所以JS和python基本语法也是很类似的。</p>
<blockquote>
<p>json其实与python字典用法差不多<br>在json里面<code>var a={time:&#39;4am&#39;,person:&#39;zwz&#39;}</code> python里面<code>a={&#39;color&#39;:&#39;green&#39;,&#39;point&#39;:5}</code>就是键值对</p>
</blockquote>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>学完很惊讶的发现，数组的应用与python的列表神似呀!</br></p>
<p>添加/删除元素的方法</br><br>添加:1.push(元素)，从尾部添加           2.unshift(元素)从头部添加</br><br>删除:1.pop()，从尾部弹出 2.shift()，从为头部弹出</p>
<p>拼接</br><br>concat(数组2) 例如:concat</p>
<pre><code>`var a=[1,2,3]`
`var b=[4,5,6]`
`alert(a.concat(b))`</code></pre><p>会输出[1,2,3,4,5,6]</p>
<p>再例如：join</p>
<pre><code>`var a=[1,2,3,4];`
`alert(arr.join(&apos;-&apos;));`</code></pre><p>会输出 1-2-3-4 join里面的东西是什么都行</p>
<p>排序sort</p>
<pre><code>`var arr[&apos;c&apos;,&apos;b&apos;,&apos;z&apos;,&apos;a&apos;]`
`arr.sort()`
`alert(arr)`</code></pre><p>会输出a,b,c,z</p>
<p>在比较数字的时候例如</p>
<pre><code>`var arr[111,333,442,5,6]`
`arr.sort(function(n1, n2){
    return n1 - n2; )}`</code></pre><p>需要这么做才可以排序数字数组</p>
<blockquote>
<p>sort只能识别字符串</p>
</blockquote>
<p>splice的用法</p>
<pre><code>`arr=[1,2,3,4,5,6]`&lt;/br&gt;
`arr.splice(2,3)`&lt;/br&gt;
`alert(arr)`&lt;/br&gt;</code></pre><p>会出现1，2，6,从arr[2]→arr[5]都被删除了.可见用法删除：splice(起点，长度)</br></p>
<pre><code>`arr=[1,2,3,4,5,6]`&lt;/br&gt;
`arr.splice(2,0,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)`&lt;/br&gt;
`alert(arr)`&lt;/br&gt;</code></pre><p>会出现1，2，’a’’b’’c’，3，4，5，6，从arr[2]后面增加’a’,’b’,’c’三个元素.<br>用法插入：splice(起点，长度，元素…)</p>
<hr>
<p><code>document.getElementById()</code><br>可以在任何浏览器下使用，不会出现兼容性问题.</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>函数能传参，而且想传几个传几个。例如<code>function varName(a,b,c,..)</code></br><br>举多个栗子</br><br>script部分</p>
<p><code>function setColor(color) {
    var oDiv = document.getElementById(&#39;div1&#39;);</code></br><br>    <code>oDiv.style.background = color;
        }</code></br><br>body部分</p>
<pre><code>`&lt;input type=&quot;button&quot; value=&quot;变绿&quot; onclick=&quot;setColor(&apos;green&apos;)&quot;&gt;`
`&lt;input type=&quot;button&quot; value=&quot;变黄&quot; onclick=&quot;setColor(&apos;yellow&apos;)&gt;`
`&lt;input type=&quot;button&quot; value=&quot;变黑&quot; onclick=&quot;setColor(&apos;balck&apos;)&quot;&gt;`</code></pre><blockquote>
<p>函数其实就是个占位符 在函数里有定不下来的东西就可以用函数传参</p>
</blockquote>
<p>第二种方法<br>    <code>function setStyle(name, value)</code><br>    <code>{ var oDiv = document.getElementById(&#39;div1&#39;);</code><br>    <code>oDiv.style[name]=value}</code></p>
<p>body部分</p>
<pre><code>`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;width&apos;,&apos;400px&apos;)&quot;`
`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;height&apos;,&apos;400px&apos;)&quot;`
`&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setStyle(&apos;color&apos;,&apos;green&apos;)&quot;`</code></pre><blockquote>
<p><code>.</code>能做的事<code>[]</code>都能做，反之而不一定。当要修改的属性不固定的时候常用例如这里的一会变颜色一会变宽高可以用这种方式传参</p>
</blockquote>
<p>PS.修改样式的时候比如运用<code>.style.</code>修改的是行间的样式但是<code>className</code>是直接添加class属性。由于行间样式优先级大于引用样式因此，在同一标签下先改.style的样式再改class的样式后者是显示不出来的。</p>
<h3 id="提取行间事件"><a href="#提取行间事件" class="headerlink" title="提取行间事件"></a>提取行间事件</h3><p>1.为元素添加事件。以onclick事件为例子</p>
<pre><code>`function 名字(){...;}`
`oBtn.onclick=名字`</code></pre><p>或者</p>
<pre><code>`oBtn.onclick=function(){...;}`</code></pre><blockquote>
<p>这两段代码需要在body里且在input标签下方才能执行。若script放进head里面就会报错，原因是js是一行一行读的，在head里面则会给未知的oBtn加一个onclick从而报错。</p>
</blockquote>
<p>此时window.onload出现了</p>
<pre><code>`window.onload = function(）{
        var oBtn = document.getElementById(&apos;btn1&apos;)
        oBtn.onclick = function() {
            alert(&apos;a&apos;);
        }
    }</code></pre><blockquote>
<p>window.onload的作用是加载完整个网页再进行js代码</p>
</blockquote>
<h3 id="获取一组元素"><a href="#获取一组元素" class="headerlink" title="获取一组元素"></a>获取一组元素</h3><pre><code>`getElementsByTagName`</code></pre><p>如过我们要给一堆且相同的标签添加样式的话，可以用循环实现比如说给div添加样式<br>可以用以下代码实现 </p>
<pre><code>`for(var i=0&apos;i&lt;aDiv.length;i++)`</code></pre><p>运用 <strong>this</strong> 来表示当前发生的元素</p>
<hr>

<pre><code>`oDiv.innerHTML = oTxt.value;`</code></pre><p>oTxt.value的值赋予了oDiv.innerHTML中<br>把它嵌套在<code>oBtn.onclick = function() {}</code>里面就可以点击button把text里的值赋予div。</p>
<blockquote>
<p>由于里面有HTML所以可以在里面运用html代码，即可以输入<code>&lt;h2&gt;标题&lt;h2/&gt;</code>这类代码，并实现。</p>
</blockquote>
<p>在语句中’+ something +’,’++’可以实现字符串的拼接；</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ol>
<li>可以使用<code>setInterval(var,time)</code>来进行无限次的且时隔time ms的间隔弹窗 使用clearInterval来关闭</li>
<li>使用<code>setTimeout(var,time)</code>来进行一次时隔time ms的弹窗 使用clearTimeout来关闭</li>
</ol>
<blockquote>
<p>可以进行无缝滚动或者移入移出弹框 很方便</p>
</blockquote>
<h3 id="DOM基础"><a href="#DOM基础" class="headerlink" title="DOM基础"></a>DOM基础</h3><p>childNodes 可以查询父节点下面的子节点有多少个 （其中包括文本节点和元素节点）<br></br><br>nodeType 可以显示节点的类型比如说：1.代表元素节点 2.代表属性节点 3.嗲表文本节点….</br><br>parentNode 可以获取父节点.<br>offsetParent 根据样式的不同会有不一样的显示<br>firstElementChild 获取第一个元素子节点</br><br>lastElementChild 获取最后一个元素子节点</br></p>
<h4 id="DOM方式操作元素属性"><a href="#DOM方式操作元素属性" class="headerlink" title="DOM方式操作元素属性"></a>DOM方式操作元素属性</h4><ul>
<li>获取：getAttribute (名称)</li>
<li>设置: setAttribute (名称，值)</li>
<li>删除：removeAttribute (名称)<blockquote>
<p>很少用到DOM来操作元素</p>
</blockquote>
</li>
</ul>
<h4 id="创建、插入和删除元素"><a href="#创建、插入和删除元素" class="headerlink" title="创建、插入和删除元素"></a>创建、插入和删除元素</h4><ul>
<li>创建DOM元素<ul>
<li>createElement(标签名) 创建一个节点<blockquote>
<p>需要利用appendChild加入 ，基本格式为父级.appendChild(子节点) 例子：</br><code>var oLi=document.createElement(&#39;li&#39;)</code></br><br><code>oUl.appendChild(oLi)</code></p>
</blockquote>
</li>
<li>appendChild(节点) 追加一个节点例子：为ul插入li.</li>
</ul>
</li>
<li>插入元素<br>  -insertBefore(节点，原有节点) 在已有元素的前面插入<blockquote>
<p>要把元素添加在前面则可以用这条语句，首先先把需要添加元素的父级中把子集全部选定出来，在使用该语句。例如：<br>  </br><code>var oLi = document.createElement(&#39;li&#39;);</code></br><br>   <code>var aLi = oUl.getElementsByTagName(&#39;li&#39;)</code><br>  <code>oUl.insertBefore(oLi, aLi[0])</code></p>
</blockquote>
</li>
<li>删除DOM元素<ul>
<li>removeChild(节点) 删除一个节点</li>
</ul>
</li>
</ul>
<h3 id="表格应用"><a href="#表格应用" class="headerlink" title="表格应用"></a>表格应用</h3><ul>
<li><p>获取</p>
<ul>
<li><p>tBodies、tHead、tFoot、rows、cells 用法<br><code>oTab.getElementsByTagName(&#39;tbody&#39;)[0]</code><br><code>.getElementsByTagName(&#39;tr&#39;)[1]</code><br><code>.getElementsByTagName(&#39;td&#39;)[1].innerHTML</code></br></p>
<p>  这个用法等同于</p>
<p>  <code>oTab.tBodies[0].rows[1].cells[1].innerHTML</code></p>
</li>
</ul>
</li>
<li><p>隔行变色</p>
<ul>
<li><code>for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++)</code></br><br><code>if (i % 2)</code></br>`{<pre><code>    oTab.tBodies[0].rows[i].style.background = &apos;#CCC&apos;;
} `&lt;/br&gt;</code></pre><code>else</code> </br><code>{oTab.tBodies[0].rows[i].style.background = &#39;&#39;}</code></li>
</ul>
</li>
</ul>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><h4 id="运动框架"><a href="#运动框架" class="headerlink" title="运动框架"></a>运动框架</h4><ul>
<li>在运动开始的时候，关闭已有的定时器</li>
<li>把运动和暂停隔开(if,else)</li>
</ul>
<blockquote>
<p>不好写emmm，看代码吧 &lt;运动1&gt; JS源代码里面看</p>
</blockquote>
<h4 id="多物体运动框架"><a href="#多物体运动框架" class="headerlink" title="多物体运动框架"></a>多物体运动框架</h4><ul>
<li>定时器作为物体的属性</li>
<li>并且在写多个物体运动的时候，变量是不可以公用的，比如多个div淡入淡出就可以发现，会有异样详情看 JS代码里面的多物体淡入淡出。</li>
<li>属性与运动对象绑定：速度、其他属性值等（比如透明度）</li>
</ul>
<blockquote>
<p>如果写JS多物体运动框架可以参考JS网页里面“去掉offset,添加形参的运动框架” 消化消化知识点。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E6%B3%95/" class="post-title-link" itemprop="url">二叉树排序法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-07 20:55:58" itemprop="dateModified" datetime="2020-06-07T20:55:58+08:00">2020-06-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>package ArrayList;

import java.util.ArrayList;
import java.util.List;

public class Node {
    public Node leftNode;
    public Node rightNode;

    public Object value;

    public static void main(String[] args) {
        int []randoms = new int[]{67,7,30,73,10,0,78,81,10,74};
        Node roots = new Node();
        for (int number : randoms){
            roots.add(number);
        }
        System.out.println(roots.value());
    }
    //插入 数据
    public void add(Object v){
        //如果当前节点没有值，就把数据放在当前节点上
        if (null == value){
            value = v ;
        }
        //如果当前节点有值，就进行判断，新增的值与现在的值的大小关系
        else {
            if ((Integer) v &lt; (Integer)value ){
                if (null == leftNode){
                    leftNode = new Node();
                }
                leftNode.add(v);
            }else {
                if(null == rightNode){
                    rightNode = new Node();
                }
                rightNode.add(v);
            }
        }
    }
    //中序遍历所有的节点
    public List&lt;Object&gt; value(){
        List&lt;Object&gt; values = new ArrayList&lt;&gt;();

        //左节点的遍历结果
        if (null != leftNode){
            values.addAll(leftNode.value());
        }
        //当前节点
        values.add(value);

        //右节点的遍历结果
        if (rightNode != null){
            values.addAll(rightNode.value());
        }
        return values;
    }
}</code></pre><blockquote>
<p>中序遍历的意思就是：先遍历左子树 然后 读取根节点 然后读取 右子树<br><img src="https://i.loli.net/2020/06/07/DQHGquFdAsLM5Tv.jpg" alt="微信图片_20200607194407.jpg"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/sizeof%E7%9A%84%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/sizeof%E7%9A%84%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">sizeof的用法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-05 21:06:38" itemprop="dateModified" datetime="2020-04-05T21:06:38+08:00">2020-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sizeof的用法"><a href="#sizeof的用法" class="headerlink" title="sizeof的用法"></a>sizeof的用法</h1><p><img src="https://img-blog.csdn.net/201804291534473" alt=""><br><img src="https://img-blog.csdn.net/2018042915351990" alt=""><br><img src="https://img-blog.csdn.net/20180429153532932" alt=""></p>
<p>均转载，以便复习以及加上一些注解</p>
<p>相对应的数据类型的字节数<br><img src="https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
