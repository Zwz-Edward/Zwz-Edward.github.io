<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="File类、递归File概述 java.io.File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 构造方法 public File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 public File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的File实例">
<meta property="og:type" content="article">
<meta property="og:title" content="File&amp;递归">
<meta property="og:url" content="http://yoursite.com/2021/03/27/File&%E9%80%92%E5%BD%92/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:description" content="File类、递归File概述 java.io.File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 构造方法 public File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 public File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的File实例">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/07/15/SoduBbYEKMtrwqA.png">
<meta property="og:image" content="https://i.loli.net/2020/07/15/Y2GSzAmCjlcD71w.png">
<meta property="og:image" content="https://i.loli.net/2020/07/16/MPAh5sxQuVvwFU8.png">
<meta property="article:published_time" content="2021-03-27T04:30:13.910Z">
<meta property="article:modified_time" content="2020-07-16T10:52:36.000Z">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/07/15/SoduBbYEKMtrwqA.png">

<link rel="canonical" href="http://yoursite.com/2021/03/27/File&%E9%80%92%E5%BD%92/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>File&递归 | ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/File&%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          File&递归
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:13" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:13+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-16 18:52:36" itemprop="dateModified" datetime="2020-07-16T18:52:36+08:00">2020-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="File类、递归"><a href="#File类、递归" class="headerlink" title="File类、递归"></a>File类、递归</h1><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><code>java.io.File</code>类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public File(String pathname)</code>：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的File实例。</li>
<li><code>public File(String parent, String child)</code>：从<strong>父路径名字符串和子路径名字符串</strong>创建新的File实例。</li>
</ul>
<p>举例子：</p>
<pre><code>/*
    路径：
        绝对路径：完整的路径
            以盘符(C:  D: ...)开始的路径
                c:\\1.txt
        相对路径：是一个简化的路径
            相对指的是相对于当前项目的根目录
            如果使用当前项目的根目录，路径可以简化书写

        注意：
            1.路径是不区分大小写
            2.路径中的文件名称分隔符windows用反斜杠，反斜杠是转义字符。两个反斜杠代表一个反斜杠
*/
public class Demo02FilePath {
    public static void main(String[] args) {
        /*
            File类的构造方法
        */
        show01();
        show02(&quot;c:\\&quot;,&quot;a.txt&quot;);//c:\a.txt
        show02(&quot;d:\\&quot;,&quot;a.txt&quot;);//d:\a.txt
        show03();
    }
    /*
        File(File parent, String child)根据parent抽象路径名和chile路径名字符串创建一个新File实例
        参数：把路径分为两部部分
            File parent:父路径
            String child：子路径
        好处：
            父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径可以变化
            父路径是File类型，可以使用File的方法对路径进行一些操作，再使用路径创建对象
    */
    private static void show03() {
        File parent = new File(&quot;c:\\&quot;);
        File file1 = new File(parent,&quot;hhh&quot;);
        System.out.println(file1);
    }

    /*
        File(String parent,String child) 根据parent 路径名字字符串和 child 路径名字符串创建一个新 File 实例
        参数：把路径分成了两部分
        String parent：父路径
        String child：子路径
        好处：
            父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径可以变化
    */
    private static void show02(String parent,String child) {
        File file = new File(parent,child);
        System.out.println(file);//c:\a.txt
    }

    /*
        File(String pathname)通过将给定路径名字符串转换为抽象路径名来创建一个新File实例
        参数：
            String pathname：字符串的路径名称
            路径名称可以是以文件皆为，也可以是以文件夹结尾
            路径可以是相对路径，也可以是绝对路径
            路径可以存在，也可以是不存在
            创建File对象，只是把字符串路径封装成File对象，不考虑路径的真假情况
    */
    private static void show01() {
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        System.out.println(f1);//重写了Object类的toString方法

        File f2 = new File(&quot;b.txt&quot;);
        System.out.println(f2);
    }
}</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul>
<li><code>public String getAbsolutePath()</code>; 返回此File的绝对路径名字符串</li>
<li><code>public String getPath()</code>; 将此File转换为路径名字符串</li>
<li><code>public String getName()</code>; 返回由此File表示的文件或目录的名称。</li>
<li><code>public long length()</code> ;返回由此File表示的文件的长度</li>
</ul>
<p>演示</p>
<pre><code>public class Demo03FileMethods {
    public static void main(String[] args) {
        show01();
        show02();
        show03();
        show04();
    }
    /*
        public long length() ;返回由此File表示的文件的长度
        获取的是构造方法指定的文件的大小，以字节为单位
        注意：
            文件夹是没有大小概念的，不能获取文件夹的大小
            如果构造方法中给出的路径不存在，那么length方法返回0;
    */
    private static void show04() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\1.jpg&quot;);
        long length = f1.length();
        System.out.println(length);
    }

    /*
        public String getName(); 返回由此File表示的文件或目录的名称。
        获取的就是构造方法传递路径结尾的部分(文件/文件夹)
    */
    private static void show03() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        File f2 = new File(&quot;C:\\java练习\\File&quot;);
        System.out.println(f1.getName());
        System.out.println(f2.getName());
    }

    /*
         public String getPath(); 将此File转换为路径名字符串
         获取构造方法中的路径
    */
    private static void show02() {
        System.out.println(&quot;-----------------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        File f2 = new File(&quot;a.txt&quot;);
        System.out.println(f1.getPath());
        System.out.println(f2.getPath());

        System.out.println(f1); //默认调用toString方法，toString方法调用getPath()方法
    }

    /*
        public String getAbsolutePath(); 返回此File的绝对路径名字符串.
        获取构造方法中传递的路径
        无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径
    */
    private static void show01() {
        File f1 = new File(&quot;C:\\java练习\\File\\a.txt&quot;);
        String absolutePath1 = f1.getAbsolutePath();
        System.out.println(absolutePath1);

        File f2 = new File(&quot;a.txt&quot;);
        System.out.println(f2.getAbsolutePath());
    }
}</code></pre><p>输出结果</p>
<pre><code>C:\java练习\File\a.txt
C:\java练习\File\a.txt
-----------------------
C:\java练习\File\a.txt
a.txt
C:\java练习\File\a.txt
-----------------------
a.txt
File
-----------------------
3149546</code></pre><blockquote>
<p>API中说明:length(),表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便携的路径，开发常用。</li>
</ul>
<hr>
<pre><code>public class FilePath{
    public static void main(String[] args){
        //D盘下的bbb.java文件
        File f = new File(&quot;D:\\bbb.java&quot;);
        System.out.println(f.getAbsolutePath());

        //项目下的bbb.java文件
        File f2 = new File(&quot;bbb.java&quot;);
        System.out.println(f.getAbsolutePath());
    }
}

输出结果：
D:\bbb.java
D:\C:\java练习\File\bbb.java</code></pre><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li>public boolean exists():此File类表示的文件或目录是否实际存在。</li>
<li>public boolean isDirectory():此File表示的是否为目录。</li>
<li>public boolean isFile():此File表示的是否为文件。</li>
</ul>
<p>方法演示。</p>
<pre><code>public class Demo04FileExists {
    public static void main(String[] args) {
        show01();
        show02();
    }
    /*
        public boolean isDirectory() : 此File表示的是否为目录
            用于判断构造方法中给定的路径是否以文件夹结尾
                是：true
                否：false
        public boolean isFile():此File表示的是否为文件。
            用于判断构造方法中给定的路径是否以文件结尾
                是：true
                否：false
        注意：
            电脑的硬盘中只有文件或者文件夹，两个方法是互斥的
            这两个方法使用前提，路径必须存在，否则都返回false
    */
    private static void show02() {
        System.out.println(&quot;-------------show02----------------&quot;);
        File f1 = new File(&quot;C:\\java练习\\File\\src\\Demo01\\File&quot;);
        System.out.println(f1.isDirectory());
        System.out.println(f1.isFile());
    }

    /*
        public boolean exists():此File类表示的文件或目录是否实际存在。
        用于判断构造方法中的路径是否存在
            存在:true
            不存在：false
    */
    private static void show01() {
        System.out.println(&quot;-------------show01----------------&quot;);
        File f1 = new File(&quot;C:\\&quot;);
        System.out.println(f1.exists());

        File f2 = new File(&quot;f:\\&quot;);
        System.out.println(f2.exists());

        File f3 = new File(&quot;a.txt&quot;);
        System.out.println(f3.exists());
    }
}</code></pre><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li>public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时候，创建一个新的空文件。</li>
<li>public boolean delete():删除由此File表示的文件或目录。</li>
<li>public boolean mkdir():创建由此File表示的目录。</li>
<li>public boolean mkdirs():创建由此File表示的目录，包括任何必须但不存在的父目录。</li>
</ul>
<p>方法演示</p>
<pre><code>public class Demo05FileCreateAndDelete {
    public static void main(String[] args) throws IOException{
        show01();
        show02();
        show03();
    }
    /*
         public boolean delete():删除由此File表示的文件或目录。
         此方法，可以删除构造方法路径中给出的文件/文件夹
         返回值：布尔值
            true：文件/文件夹删除成功 返回true
            false：文件夹中有内容，不会删除 返回false；构造方法中路径不存在false
         注意：
            delete方法是直接在硬盘删除文件和文件夹，不走回收站，删除须谨慎

    */
    private static void show03() {
        System.out.println(&quot;-------------show03-------------&quot;);
        File f2 = new File(&quot;C:\\java练习\\File\\11\\22\\33\\4.txt&quot;);
        boolean b1 = f2.delete();
        System.out.println(b1);
    }

    /*
        public boolean mkdir():创建单级文件夹
        public boolean mkdirs():既可以创建单级也可以创建多级
        返回值:布尔值
            true：文件夹不存在，创建文件夹，返回true
            false：文件夹不存在，不会创建，返回false；构造方法中给出的路径不存在返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常
    */
    private static void show02() {
        System.out.println(&quot;-------------show02-------------&quot;);
        File f1 = new File(&quot;aaa.txt&quot;);
        boolean b1 = f1.mkdir();
        System.out.println(b1);

        File f2 = new File(&quot;11\\22\\33\\4.txt&quot;);
        boolean b2 = f2.mkdirs();
        System.out.println(b2);
    }

    /*
        public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时候，创建一个新的空文件。
        创建文件的路径和名称在构造方法中给出(构造方法的参数)
        返回值:布尔值
            true：文件不存在，创建文件，返回true
            false：文件存在，不会创建，返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常

        public boolean createNewFile() throws IOException
        该方法会抛出异常
    */
    private static void show01() throws IOException {
        System.out.println(&quot;-------------show01-------------&quot;);
        File f1 = new File(&quot;1.txt&quot;);
        boolean b1 = f1.createNewFile();
        System.out.println(b1);
    }
}</code></pre><blockquote>
<p>API中说明:delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><ul>
<li>public String[] List():返回一个String数组，表示该File目录中的所有子文件或目录</li>
<li>public File[] listFiles():返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
<p>方法</p>
<pre><code>/*
注意：
    List方法和listFiles方法遍历的是构造方法中给出的目录
    如果构造方法中给出的目录的路径不存在，会抛出空指针异常
    如果构造方法中给出的路径不是一个目录，也会抛出空指针异常
*/
public class Demo06FileList {
    public static void main(String[] args) {
        Show01();
        Show02();
    }
    /*
        - public File[] listFiles():返回一个File数组，表示该File目录中的所有的子文件或目录。
        遍历构造方法中给出的目录，会获得目录中所有文件/文件夹的名称,把文件/文件夹封装成File对象，多个File对象存储到File数组中
    */
    private static void Show02() {
        File file = new File(&quot;C:\\java练习\\File&quot;);
        File[] files = file.listFiles();
        for (File f : files){
            System.out.println(f);
        }
    }

    /*
        - public String[] List():返回一个String数组，表示该File目录中的所有子文件或目录
        遍历构造方法中给出的目录，会获得目录中所有文件/文件夹的名称，把多个名称存储到一个字符串String类型的数组

    */
    private static void Show01() {
        File file = new File(&quot;C:\\java练习\\File&quot;);
        String[] list = file.list();
        for (String s : list){
            System.out.println(s);
        }

    }
}</code></pre><blockquote>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历哦。</p>
</blockquote>
<p>#递归</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>递归：方法自己调用自己</p>
<ul>
<li><p>递归分类：</p>
<pre><code>- 直接递归成为方法自己调用自己
- 间接递归可以A方法屌用B方法，B方法调用C方法，C方法调用A方法</code></pre></li>
<li><p>注意事项：</p>
<pre><code>- 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</code></pre><ul>
<li>递归虽然有限制条件，但是递归次数不能太多，不然也会发撒哼栈内存溢出</li>
<li>构造方法禁止递归！</li>
</ul>
</li>
<li><p>递归的使用前提：当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归</p>
<pre><code>public class Recursive {
    public static void main(String[] args) {
    a(1);
}

private static void a(int i) {
    System.out.println(i);
    if (i==20000){
        return;
    }
    a(++i);
}</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>运行该代码会使栈空间爆满，以至于抛出栈溢出异常</p>
</blockquote>
<h2 id="递归累加求和"><a href="#递归累加求和" class="headerlink" title="递归累加求和"></a>递归累加求和</h2><pre><code>/*
    练习：
        使用递归计算1-n之间的和
*/
public class Demo02Recursive {
    public static void main(String[] args) {
        int s =sum(3);
        System.out.println(s);
    }
    /*
        定义一个方法，使用递归计算1-n之间的和
        1+2+3+...+n
        n + (n-1) + (n-2)+...+1
        已知：
            最大值：n
            最小值：1
        使用递归必须明确：
            1，递归的结束条件
                获取到1的时候结束
            2.递归的目的
                获取下一个被加的数字(n-1)
    */
    private static int sum(int n) {

        if (n==1){
            return 1;
        }
        //获取下一个被加的数字(n-1)
        return n+sum(n-1);
    }
}</code></pre><p><img src="https://i.loli.net/2020/07/15/SoduBbYEKMtrwqA.png" alt="1594785660_1_.jpg"></p>
<blockquote>
<p>该图是计算1加到3的算法 </p>
<p>一开始调用方法入栈，然后递归继续入栈，接着当条件符合的时候弹栈输出结果，即，sum(3-1)是2 sum(2-1)是1</p>
</blockquote>
<h2 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h2><pre><code>/*
    练习：
        使用递归计算阶乘
        n的阶乘：n! = n*(n-1)*(n-2)*...*3*2*1
        5的阶乘：5! = 5*(5-1)*(5-2)*...*(5-4)
*/
public class Demo03Recursive {
    public static void main(String[] args) {
        int a = fact(-10);
        System.out.println(a);
    }
    /*
        定义方法使用递归计算阶乘
        5的阶乘：5! = 5*(5-1)*(5-2)*...*(5-4)
    */
    private static int fact(int n) {
        if (n == 1){
            return 1;
        }
        else if (n &lt; 0){
            System.out.println(&quot;fail&quot;);
            return -1;
        }
        else
            return n*fact(n-1);
    }
}</code></pre><h2 id="打印多级目录"><a href="#打印多级目录" class="headerlink" title="打印多级目录"></a>打印多级目录</h2><pre><code>/*
    练习：
        递归打印多级目录
    需求：
        遍历c:\\java练习文件夹，及其子文件夹
*/
public class Demo04Recursive {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历

    */
    public static void getAllFile(File dir){
        System.out.println(dir);
        File[] files = dir.listFiles();
        for (File f : files){
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()){
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            }else
                //f是一个文件，直接打印
                System.out.println(f);
        }
    }
}    </code></pre><p><img src="https://i.loli.net/2020/07/15/Y2GSzAmCjlcD71w.png" alt="1594791605_1_.jpg"></p>
<blockquote>
<p>图与代码不太相符，原理一样</p>
</blockquote>
<p>#综合案例</p>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><pre><code>/*
    练习：
        递归打印多级目录
    需求：
        遍历c:\\java练习文件夹，及其子文件夹
        只要.java结尾的文件
*/
public class Demo05Recursive {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历

    */
    public static void getAllFile(File dir){
        //System.out.println(dir);
        File[] files = dir.listFiles();
        for (File f : files){
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()){
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            }else{
                /*
                //f是一个文件，直接打印
                *//*
                    只要.java结尾的文件
                    1.把File对象f转换为字符串对象
                *//*
                //String name = f.getName();//转换为字符串
                //String path = f.getPath();
                String string = f.toString();

                //把字符串，转换为小写
                s = string.toLowerCase();

                //  2.调用String类中的方法endWith判断字符串是否是以.java结尾
                boolean b = string.endsWith(&quot;.java&quot;);

                //  3.如果是以.java结尾的文件，则输出就行
                if (b == true){
                System.out.println(f);
                */
                if (f.getName().toLowerCase().endsWith(&quot;.java&quot;)){
                    System.out.println(f);
                }
            }
        }
    }
}</code></pre><blockquote>
<p><code>/**/</code>在这里面的代码是最原始，正常人的思想，后面简版是改进后的</p>
</blockquote>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code>作为参数，接口中只有一个方法。</p>
<p><code>boolean accept(File pathname)</code>：测试pathname是否应该包含当前File目录中，符合返回true，过滤掉则返回false，保留规则：</p>
<ol>
<li>要么是.java文件。</li>
<li>要么是目录用于继续遍历。</li>
</ol>
<p>通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印</p>
<p><img src="https://i.loli.net/2020/07/16/MPAh5sxQuVvwFU8.png" alt="1594872854_1_.jpg"></p>
<p>实现代码</p>
<pre><code>public class Demo02Filter {
    public static void main(String[] args) {
        File f = new File(&quot;c:\\java练习&quot;);
        getAllFile(f);
    }

    public static void getAllFile(File dir) {
        //传递过滤器对象 使用匿名内部类 FileFilter方法
        /*File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File pathname) {
                //过滤规则，pathname是文件夹，或是.java结尾的文件返回true
                return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(&quot;.java&quot;);
            }
        });*/

        /*File [] files = dir.listFiles(new FilenameFilter() {
            //传递过滤器对象 使用匿名内部类 FileFilter方法 FilenameFilter方法
            @Override
            public boolean accept(File dir, String name) {
                return new File(dir,name).isDirectory() || name.toLowerCase().endsWith(&quot;.java&quot;);
            }
        });*/

        //传递过滤器对象 使用匿名内部类 FileFilter方法 Lambda表达式
        File [] files = dir.listFiles((dir1, name) -&gt; new File(dir1,name).isDirectory() || name.toLowerCase().endsWith(&quot;.java&quot;));

        for (File f : files) {
            //对遍历得到的File对象f进行判断，判断是否为文件夹
            if (f.isDirectory()) {
                //f是文件夹，则继续遍历这个文件夹
                //我们发现gatAllFile方法就是传递文件夹，遍历文件的方法
                //所以直接调用getAllFile方法即可，自己调用自己
                getAllFile(f);
            } else {
                if (f.getName().toLowerCase().endsWith(&quot;.java&quot;)) {
                    System.out.println(f);
                }
            }
        }
    }
}</code></pre><blockquote>
<p>ps：IDEA里面写了匿名内部类的方法可以变成Lambda表达式不用自己写hhh</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/27/C%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E6%B3%95/" rel="prev" title="C语言冒泡法">
      <i class="fa fa-chevron-left"></i> C语言冒泡法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/27/Git/" rel="next" title="Git">
      Git <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#File类、递归"><span class="nav-number">1.</span> <span class="nav-text">File类、递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#File"><span class="nav-number">1.1.</span> <span class="nav-text">File</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">1.1.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法"><span class="nav-number">1.1.3.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取功能的方法"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">获取功能的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绝对路径和相对路径"><span class="nav-number">1.1.4.</span> <span class="nav-text">绝对路径和相对路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断功能的方法"><span class="nav-number">1.1.5.</span> <span class="nav-text">判断功能的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建删除功能的方法"><span class="nav-number">1.1.6.</span> <span class="nav-text">创建删除功能的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录遍历"><span class="nav-number">1.1.7.</span> <span class="nav-text">目录遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">1.2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归累加求和"><span class="nav-number">1.3.</span> <span class="nav-text">递归累加求和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归求阶乘"><span class="nav-number">1.4.</span> <span class="nav-text">递归求阶乘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印多级目录"><span class="nav-number">1.5.</span> <span class="nav-text">打印多级目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件搜索"><span class="nav-number">1.6.</span> <span class="nav-text">文件搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤器"><span class="nav-number">1.7.</span> <span class="nav-text">过滤器</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
