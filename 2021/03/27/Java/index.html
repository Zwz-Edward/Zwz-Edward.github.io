<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Java (从入门到入土)Java 的固定的书写格式：public static void main(String[] args){...} 基础知识 Java虚拟机的内存可以分为三个区域，栈stack、堆heap、方法区method area。  栈：栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等） JVM为每个线程创建了一个栈，用于存放该线程执行">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://yoursite.com/2021/03/27/Java/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:description" content="Java (从入门到入土)Java 的固定的书写格式：public static void main(String[] args){...} 基础知识 Java虚拟机的内存可以分为三个区域，栈stack、堆heap、方法区method area。  栈：栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等） JVM为每个线程创建了一个栈，用于存放该线程执行">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495596432165735.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495611382530451.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495611400819053.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272017528669.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273524104532.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273755315926.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495613220648265.png">
<meta property="og:image" content="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495617463792119.png">
<meta property="article:published_time" content="2021-03-27T04:30:14.250Z">
<meta property="article:modified_time" content="2020-06-17T06:58:56.000Z">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif">

<link rel="canonical" href="http://yoursite.com/2021/03/27/Java/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java | ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:14" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:14+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-17 14:58:56" itemprop="dateModified" datetime="2020-06-17T14:58:56+08:00">2020-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-从入门到入土"><a href="#Java-从入门到入土" class="headerlink" title="Java (从入门到入土)"></a>Java (从入门到入土)</h1><p>Java 的固定的书写格式：<code>public static void main(String[] args){...}</code></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>Java虚拟机的内存可以分为三个区域，栈stack、堆heap、方法区method area。<ul>
<li><ol>
<li>栈：栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）</li>
<li>JVM为每个线程创建了一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）</li>
<li>栈属于线程私有，不能实现线程间的共享</li>
<li>栈的储存特性是：先进后出，后进先出</li>
<li>栈是由系统自动分配，速度快！栈是一个连续的内存空间。 </li>
</ol>
<ul>
<li><ol>
<li>堆用于存储创建好的对象和数组（数组也是对象）</li>
<li>JVM只有一个堆，被所有线程共享</li>
<li>堆是一个不连续的内存空间，分配灵活，速度慢。</li>
</ol>
</li>
<li>1.方法区（又叫静态区）特点：JVM只有一个方法区，被所有线程共享！<ol start="2">
<li>方法区实际也是堆，只是用于存储类、常量相关的信息！</li>
<li>用于存放程序中永远是不变的唯一的内容。(类信息[class对象]、静态变量、字符串常量等)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是一种常见解决问题的方法，即把问题逐渐简单化。递归的基本思想就是”自己低矮哦用自己”，一个使用递归技术的方法将会直接或间接的调用自己 .</p>
<ul>
<li>递归体</br><br>例如：输出在a里面调用自己的时候<br>没有递归体和递归头则会陷入死循环</li>
</ul>
<p><code>static int count = 0;</code></p>
<pre><code>static void a() {
    System.out.println(&quot;a&quot;);
    count++;
    if (count &lt; 10) {
        a();
    } else {
        return;
    }</code></pre><blockquote>
<p>if-else 语句可以完美结果问题.</p>
</blockquote>
<p>但是递归体耗时耗力很影响内存，因此能不用递归的地方就不用递归，能用递归一般能用迭代来完成。</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Java作为一种面向对象语言支持</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<ol>
<li>对象：对象是类的一个实例，比如一条狗(python也是拿狗做例子- -)它有状态：颜色、名字、品种；有行为：摇尾巴、吃、叫等。</li>
</ol>
<p>很简单的例子，比如你是个男的，你想要女朋友女朋友就是一个类（class），你可以选很多人比如：石原里美，新垣结衣等等这些就是对象（object）</p>
<p>相比于软件，软件也有状态和行为。软件的对象的状态就是属性，行为通过方法体现。同样的，方法操作对象内部状态的改变，对象的互相调用也是通过方法来完成的。</p>
<ol start="2">
<li>类：类是一个模板，它描述一类对象的行为和状态 看例子：</li>
</ol>
<pre><code>public class Dog{
  String breed;
  int age;
  String color;
  void barking(){
  }

  void hungry(){
  }

  void sleeping(){
  }
}</code></pre><p>一个类可以包含以下类型变量：</p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>
</ul>
<p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。例子：</p>
<pre><code>Public class Puppy{
public Puppy(){
}

public Puppy(String name){
    // 这个构造器仅有一个参数：name
    }
}    </code></pre><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。</p>
<ol>
<li>声明：声明一个对象，包括对象名称和类型。</li>
<li>实例化：使用关键字new来创建一个对象。</li>
<li>初始化：使用new创建对象时，调用构造方法对象</li>
</ol>
<pre><code>public class Puppy{
       public Puppy(String name){
      //这个构造器仅有一个参数：name
      System.out.println(&quot;小狗的名字是 : &quot; + name ); 
   }
   public static void main(String[] args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( &quot;tommy&quot; );
   }
}</code></pre><h4 id="源代码的声明规则："><a href="#源代码的声明规则：" class="headerlink" title="源代码的声明规则："></a>源代码的声明规则：</h4><ol>
<li>一个源代码只能有一个Public类但可以有多个非Public类</li>
<li>源文件名应该与Public类名保持一致。</li>
<li>类如果在一个包内，package语句应该位于首行。</li>
<li>import语句位于package和Public类之间。</li>
<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ol>
<h5 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h5><p>包主要用于对类和接口分类。</p>
<h5 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h5><p>在Java中，如果给出一个完整的限定名，包括包名和类名，则Java编译器就可以很容易的定位源代码或类。</p>
<pre><code>import java.io.*; //从java.io中导入 .* 所有的类</code></pre><h3 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h3><ol>
<li>byte 数据类型是8位，有符号，以二进制补码来表示的整数Min值为-128 Max值为127</li>
<li>short 数据类型16位有符号二进制补码表示的整数 Min：-32768 Max:32767</li>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数 Min：-2^31 Max:2^31-1</li>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数 Min:-2^63 Max:2^63-1 </li>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数</li>
<li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数</li>
<li>boolean 数据类型表示一位的信息 只有True和False两个值</li>
<li>char 类型是一个单一的 16 位 Unicode 字符</li>
</ol>
<h4 id="Java常量"><a href="#Java常量" class="headerlink" title="Java常量"></a>Java常量</h4><p>Java常量用final声明 <code>final double PI = 3.1415926</code></p>
<h3 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h3><ul>
<li>类变量:独立于方法之外的变量，用static修饰</li>
<li>实例变量:独立于方法之外的变量，不过没用static修饰</li>
<li>局部变量:类的方法中的变量</li>
</ul>
<pre><code>public class Variable{
    static int allClicks=0;    // 类变量

    String str=&quot;hello world&quot;;  // 实例变量

    public void method(){

        int i =0;  // 局部变量

    }
}</code></pre><h3 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h3><p>主要分为两类</p>
<ol>
<li>访问修饰符</li>
<li>非访问修饰符<br>修饰符用来定义类、方法或变量，通常放在语句的最前端。例如</li>
</ol>
<pre><code>public class ClassName {
       // ...
}
private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;
public static void main(String[] arguments) {
   // 方法体
}</code></pre><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li>default(默认，啥都不写)：同一包内可见，不使用任何修饰符。</li>
<li>private：在同一类内可见。使用对象：变量、方法。注意：不能修饰类(外部类)</li>
<li>public：对所有类可见，使用对象：类、接口、变量、方法</li>
<li>protect：对同一包内的类和所有子类可见。使用对象：变量、方法。注意不能修饰类（外部类）</li>
</ul>
<p><strong>private</strong></br><br>私有访问修饰符是最严格的访问级别，所有被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为<br>private。</br><br>声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。</br><br>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据例子：</p>
<pre><code>public class Logger{
    private String format;
    public String getFormat(){
        return format;
    }
    public void setFormat(String format){
        this.format=format;
    }
}</code></pre><p>实例中Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类可以访问private定义的变量，我们构造了两个public的方法来获取<code>getFormat()</code>和设置format<code>setFormat(String)</code>的值.</p>
<p><strong>public</strong></br><br>被声明为public的类，方法，构造方法和接口可以被其他类访问。其中类的所有公有方法和变量都能被子类继承。</p>
<p><strong>protected</strong></br><br>protected需要从以下两个点来分析说明：</p>
<ul>
<li>子类和基类在同一包内:被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li>子类与基类不在同一个包内：那么子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li>
</ul>
<blockquote>
<p>在面向对象设计中，被定义为包含所有实体共性的class类型，被称为“基类”。</p>
</blockquote>
<p>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类(内部类除外).</br><br>接口及接口的成员变量和成员方法不能声明为 protected。<br><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif" alt=""></p>
<blockquote>
<p>以我的理解，应该是包内所有类可访问，但包外的子类继承之后才能用。</p>
</blockquote>
<h4 id="需要注意的继承规则"><a href="#需要注意的继承规则" class="headerlink" title="需要注意的继承规则"></a>需要注意的继承规则</h4><ul>
<li>父类中声明为public的方法在子类中也必须要是public</li>
<li>父类中声明为protected的方法在子类中要么声明为protected要么声明为private。</li>
<li>父类中声明为private的方法，不能被继承。</li>
</ul>
<h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><ol>
<li>static修饰符，用来修饰类方法和类变量</li>
<li>final 修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li>
<li>abstract修饰符，用来创建抽象类和抽象方法。</li>
<li>synchronized和volatile修饰符，主要用于线程的编程。</li>
</ol>
<h3 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h3><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><pre><code>`String greeting = &quot;zwz&quot;;`</code></pre><p>在遇到字符串常量时，这里的值是”zwz”，编译器会使用该值创建一个String对象。与其他对象一样，可以使用关键字的构造方法来创建String对象。例如</p>
<pre><code>public class StringDemo{
   public static void main(String args[]){
      char[] helloArray = { &apos;r&apos;, &apos;u&apos;, &apos;n&apos;, &apos;o&apos;, &apos;o&apos;, &apos;b&apos;};
      String helloString = new String(helloArray);  
      System.out.println( helloString );
   }
}</code></pre><p>编译结果是 <code>runoob</code></p>
<blockquote>
<p>注意String类是用final修饰的，所以不可以修改，一旦创建了String对象，那他的值就无法改变了</p>
</blockquote>
<h4 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h4><p>如果想对值进行修改，那么需要用这俩类。</p>
<p>与String类不同的是，StringBuffer 和 StringBuilder类的对象能够被多次修改，并且不产生新的未被使用的对象。</p>
<p>StringBuilder与StringBuffer之间最大的区别就说前者不是线程安全的(不能同步访问)<br>但是前者的速度比后者大，所以多数情况用前者类。但是在要求线程安全的情况下，必须使用后者类。小栗子：</p>
<pre><code>public class Test{
  public static void main(String args[]){
    StringBuffer sBuffer = new StringBuffer(&quot;菜鸟教程官网：&quot;);
    sBuffer.append(&quot;www&quot;);
    sBuffer.append(&quot;.runoob&quot;);
    sBuffer.append(&quot;.com&quot;);
    System.out.println(sBuffer);  
  }
}</code></pre><h5 id="常用的用法-和python很像"><a href="#常用的用法-和python很像" class="headerlink" title="常用的用法(和python很像)"></a>常用的用法(和python很像)</h5><table>
        <tr>
            <th>1</th>
            <th>public StringBuffer append(String s)
    将指定的字符串追加到此字符序列。</th>
        </tr>
        <tr>
            <th>2</th>
            <th>public StringBuffer reverse()
     将此字符序列用其反转形式取代。</th>
        </tr>
        <tr>
            <th>3</th>
            <th>public delete(int start, int end)
移除此序列的子字符串中的字符。</th>
        </tr>
        <tr>
            <th>4</th>
            <th>ublic insert(int offset, int i)
将 int 参数的字符串表示形式插入此序列中。</th> 
        </tr>
        <tr>
            <th>5</th>
            <th>replace(int start, int end, String str)
使用给定 String 中的字符替换此序列的子字符串中的字符。</th>
        </tr>
</table>

<h3 id="Java-时间日期"><a href="#Java-时间日期" class="headerlink" title="Java 时间日期"></a>Java 时间日期</h3><p>Java.util 包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象。</p>
<pre><code>`Date()`</code></pre><p>第二个构造函数接收一个参数，参数是从1970年1月1日起的毫秒数。</p>
<pre><code>`Date(long millisec)`</code></pre><h4 id="获取当前的日期和时间"><a href="#获取当前的日期和时间" class="headerlink" title="获取当前的日期和时间"></a>获取当前的日期和时间</h4><p>使用Date对象的toString()方法来打印当前日期和时间</p>
<pre><code>import java.util.Date;
public static void main(String arg[]){
    //初始化Date 对象
    Date date = new Date();

    //使用toString()显示日期时间
    System.out.println(date.toString());
}    </code></pre><p>结果会显示(当前的日期)：<code>Thu Apr 30 10:23:01 CST 2020</code></p>
<h4 id="比较日期"><a href="#比较日期" class="headerlink" title="比较日期"></a>比较日期</h4><p>Java使用以下2种方法来比较两个日期：</p>
<ul>
<li>使用getTime()方法获取两个日期(1970.1.1到现在的毫秒数)，然后比较这两个值。</li>
<li>使用方法before(),after(),equals()。比如new Date(99,2,12).before(new Date(99,2,18))返回True;</li>
</ul>
<h4 id="使用SimpleDateFormat格式化日期"><a href="#使用SimpleDateFormat格式化日期" class="headerlink" title="使用SimpleDateFormat格式化日期"></a>使用SimpleDateFormat格式化日期</h4><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期格式来运行。例如</p>
<pre><code>import  java.util.*;
import java.text.*;

public class DateDemo {
   public static void main(String args[]) {

      Date dNow = new Date( );
      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);

      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));
   }
}</code></pre><p>会输出<code>2020-04-30 05:17:50</code><br>其中<code>SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</code>这条语句确立了转换格式，其中yyyy是完整的公元年，MM是月份，dd是日期，HH：mm:ss是小时、分钟、秒。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。<br>多态就是同一个接口，使用不同的实例而执行不同操作。</p>
<h4 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h4><ol>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
<h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ol>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ol>
<h3 id="Java正则表达式-对不起暂时看不懂"><a href="#Java正则表达式-对不起暂时看不懂" class="headerlink" title="Java正则表达式(对不起暂时看不懂)"></a>Java正则表达式(对不起暂时看不懂)</h3><ol>
<li>正则表达式定义了字符串的模式。</li>
<li>正则表达式可以用来搜索、编辑或处理文本。</li>
<li>正则表达式并不仅限某一种语言，但是在每一种语言中有细微的差别。</li>
</ol>
<h3 id="Java方法与构造方法-见另一博客-方法与构造方法"><a href="#Java方法与构造方法-见另一博客-方法与构造方法" class="headerlink" title="Java方法与构造方法(见另一博客-方法与构造方法)"></a>Java方法与构造方法(见另一博客-方法与构造方法)</h3><h3 id="数组的拷贝，扩容和删除"><a href="#数组的拷贝，扩容和删除" class="headerlink" title="数组的拷贝，扩容和删除"></a>数组的拷贝，扩容和删除</h3><pre><code>public class TestArrayCopy {
    public static void main(String[] args) {
     String[] str = {&quot;阿里&quot;,&quot;京东&quot;,&quot;尚学堂&quot;,&quot;百度&quot;,&quot;亚马逊&quot;};

     removeElement(str,1);

     str = extendRange(str);

    }

    public static void testBasicCopy(){
        String[] s1 = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;,&quot;ee&quot;};
        String[] s2 = new String[10];
        System.arraycopy(s1,2,s2,6,3);
        for (int i = 0 ;i&lt;s2.length;i++) {
            System.out.println(i+&quot;-- &quot;+s2[i]);
        }
    }

    //测试从数组中删除某个元素（本质上还是数组的拷贝）
    public static void testBasicCopy2(){
        String[] s1 = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;,&quot;ee&quot;};
        //String[] s2 = new String[5];

        System.arraycopy(s1,3,s1,3-1,s1.length-3);


        s1[s1.length-1] = null;
        for (int i = 0 ;i&lt;s1.length;i++) {
            System.out.println(i + &quot;-- &quot; + s1[i]);
        }
    }

    //测试删除数组中指定索引位置的元素，并返回
    public static String[] removeElement(String[] s,int index){


        System.arraycopy(s,index+1,s,index,s.length-index-1);


        s[s.length-1] = null;
        for (int i = 0 ;i&lt;s.length;i++) {
            System.out.println(i + &quot;-- &quot; + s[i]);

        }
        return s;
    }

    //数组的扩容(本质是：先定义一个更大的数组，然后讲原数组内容原封不动拷贝到新数组里)
    public static String[] extendRange(String[] s1){
    //String[] s1 = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;};

    String[] s2 = new  String[s1.length+10];

    System.arraycopy(s1,0,s2,0,s1.length);
    for (String temp:s2){
        System.out.println(temp);
    }
        return s2;
    }

}</code></pre><p>作用为删除的会输出：</br><br>0– 阿里 1–尚学堂 2– 百度 3–亚马逊 4– null (删除了京东)</p>
<p>作用为扩容的会输出：</br><br>阿里 尚学堂 百度 亚马逊 null null null null null null null null null null null</p>
<p>由于先调用了remove所以京东不见了。</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>对于包装类来说，这些类的用途主要包含两种：</p>
<ol>
<li>作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。</li>
<li>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化!)。</li>
</ol>
<p>例子：</p>
<pre><code>/*
Integer类的使用。其他包装类用法类似，课下自己学
*/
public class TestWrappedClass {
    public static void main(String[] args) {
        //基本数据类型转换成包装类对象
        Integer b = Integer.valueOf(30);
        Integer a = new Integer(3);

        //把包装类对象转成基本数据类型
        int c = b.intValue();
        double d = b.intValue();

        //把字符串转换成包装类对象
        Integer e = new Integer(&quot;999&quot;);
        Integer f = Integer.parseInt(&quot;9999988&quot;);

        //把包装类对象转换成字符串
        String str = f.toString();

        //常见的常量
        System.out.println(&quot;int类型最大的整数：&quot;+Integer.MAX_VALUE);
    }
}</code></pre><p>会输出Int型Max值：2147483647</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>在JDK1.5以后提供了自动装箱和拆箱什么意思呢？之前<code>Interge i =100</code>这段代码是错误的，但是现在是对的；</p>
<pre><code>Integer i = 100;//这就是自动装箱
相当于编译器自动执行了一下代码
Integer i = Integer.valueOf(100).</code></pre><p>自动拆箱：</p>
<pre><code>Integer i = 100;
int j = i;//自动拆箱
//相当于编译器自动为您作以下的语法编译：
int j = i.intValue();</code></pre><p>但是要注意空指针异常问题例如：</p>
<pre><code>public class Test1 {
    public static void main(String[] args) {
        Integer i = null;
        int j = i;
    }
}</code></pre><p>这里会报空指针错；因为null表示i没有指向任何对象的实体，但作为对象名称是合法的。</p>
<h4 id="包装类缓存问题"><a href="#包装类缓存问题" class="headerlink" title="包装类缓存问题"></a>包装类缓存问题</h4><p>整型、char型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。<br>比如：</p>
<pre><code>public class Test3 {
    public static void main(String[] args) {
        Integer in1 = -128;
        Integer in2 = -128;
        System.out.println(in1 == in2);//true 因为123在缓存范围内
        System.out.println(in1.equals(in2));//true
        Integer in3 = 1234;
        Integer in4 = 1234;
        System.out.println(in3 == in4);//false 因为1234不在缓存范围内
        System.out.println(in3.equals(in4));//true
    }
}</code></pre><p>结果是:</br><br>true</br><br>true</br><br>false</br><br>true</br></p>
<p>运行的效果图为<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495596432165735.png" alt=""></p>
<blockquote>
<p>意思就是当年应用在缓存区内的数字可以直接调用缓存区中的对象，所以  123==123(在缓存中调用的是同一个对象)为True 但是in3 1234== in4 1234 是不同的对象所以为False 因此以后比较大小的时候用<code>equals</code>比较同一个对象是不是一个则用<code>==</code></p>
</blockquote>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h4><p>以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中储存，如</p>
<pre><code>import java.io.File;
import java.io.IOException;
import java.util.Date;
/*
测试File类
*/
public class TestFile {
    public static void main(String[] args) throws IOException {
        File f = new File(&quot;d:/a.txt&quot;); //绝对路径：在d盘目录下创建a.txt
        System.out.println(f);
        f.renameTo(new File(&quot;d:/b.txt&quot;));// 改名字

        System.out.println(System.getProperty(&quot;user.dir&quot;));

        File f2 = new File(&quot;gg.txt&quot;);  // 相对路径：默认放到user.dir目录下(即这里是面向对象目录下)
        f2.createNewFile();
    }
}</code></pre><p>在此，user.dir就是本项目的目录，如我在面向对象目录中创建了个 gg.txt 文件.而我又在D盘根下创建了一个a.txt改名为了b.txt。</p>
<p><strong>通过File对象可以访问文件的属性：</strong></p>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495611382530451.png" alt=""></p>
<h4 id="测试File类访问属性的基本用法"><a href="#测试File类访问属性的基本用法" class="headerlink" title="测试File类访问属性的基本用法"></a>测试File类访问属性的基本用法</h4><pre><code>System.out.println(f2.exists());
System.out.println(f2.isDirectory());
System.out.println(f2.isFile());
System.out.println(new Date(f2.lastModified()));
System.out.println(f2.getName());
System.out.println(f2.getPath());</code></pre><p>结果</p>
<pre><code>true
false
true
Tue May 05 21:18:22 CST 2020
gg.txt
gg.txt</code></pre><p><strong>通过File对象创建空文件或目录(在该对象所指的文件或目录不存在的情况下)</strong><br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495611400819053.png" alt=""></p>
<h4 id="使用mkdir创建目录"><a href="#使用mkdir创建目录" class="headerlink" title="使用mkdir创建目录"></a>使用mkdir创建目录</h4><pre><code>import java.io.File;
public class TestFile3 {
    public static void main(String[] args) throws Exception {
        File f = new File(&quot;d:/c.txt&quot;);
        f.createNewFile(); // 会在d盘下面生成c.txt文件
        f.delete(); // 将该文件或目录从硬盘上删除
        File f2 = new File(&quot;d:/电影/华语/大陆&quot;);
        boolean flag = f2.mkdir(); //目录结构中有一个不存在，则不会创建整个目录树
        System.out.println(flag);//创建失败
        boolean flag1 = f3.mkdirs();//目录结构中有一个不存在也没关系；创建整个目录树
        System.out.println(flag1);//创建成功
    }
}</code></pre><p>结果</p>
<pre><code>false
true</code></pre><h4 id="递归遍历目录结构和树状展现"><a href="#递归遍历目录结构和树状展现" class="headerlink" title="递归遍历目录结构和树状展现"></a>递归遍历目录结构和树状展现</h4><pre><code>import java.io.File;

public class PrintFileTree {
    public static void main(String[] args) {
        File f = new File(&quot;E:\\Desktop&quot;);

        printFile(f,0);
    }


    static void printFile(File file,int level){

        //输出层数
        for(int i = 0;i&lt;level;i++){
            System.out.println(&quot;-&quot;);
        }

        System.out.println(file.getName());
        if (file.isDirectory()){
            File[] files = file.listFiles();

            for (File temp:files){
            printFile(temp,level+1);
            }    //强化for语句
        }
    }
}</code></pre><p>会输出</p>
<pre><code>Desktop
-
720P_4000K_178868721.mp4
-
Kaede cosplay.mp4</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code>/*
测试枚举*/
public class TestEnum {
    public static void main(String[] args) {
        System.out.println(Season.SPRING);

        Season a = Season.AUTUMN;

        switch (a){
            case SPRING:
                System.out.println(&quot;春天来啦，播种的季节&quot;);
                break;
            case SUMMER:
                System.out.println(&quot;夏天来了游泳的季节&quot;);
                break;
            case AUTUMN:
                System.out.println(&quot;秋天来了收获的季节&quot;);
                break;
            case WINTER:
                System.out.println(&quot;冬天来了冬眠的季节&quot;);
                break;
        }

   }
}

enum Season{
    SPRING,SUMMER,AUTUMN,WINTER
}
enum Weak{
    星期一,星期二,星期三,星期四,星期五,星期六,星期天
}</code></pre><p>挺简单的= =</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>引子：</strong>在工作中，可能会遇到很多异常的情况比如：写某个模块，用户输入的不符合你的要求，你的程序要打开某个文件，这个文件不存在或者格式不对，你要读取数据库的数，数据为空，程序运行的时候内存或硬盘满了等等…</p>
<p>这些问题我们称之为异常，英文名为Exception，就是意料之外的意思。</p>
<p>异常机制本质就是当程序出现错误，程序安全退出的机制。</p>
<p>Java是采用面向对象的方式来处理异常的。处理过程：</p>
<ol>
<li>抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。</li>
<li>捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</li>
</ol>
<p>比如：</p>
<pre><code>public static void main(String[] args){
    int i=1/0; //除数为0
    System.out.println(i);
}</code></pre><p>运行结果会是</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero;</code></pre><p>Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。</p>
<p>Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：</p>
<ol>
<li>RuntimeException 运行时异常</li>
<li>CheckedException 已检查异常</li>
</ol>
<h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>JDK 中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。</p>
<p>Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。Java异常类的层次结构如图6-2所示。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495272017528669.png" alt=""></p>
<h4 id="RuntimeException运行时异常"><a href="#RuntimeException运行时异常" class="headerlink" title="RuntimeException运行时异常"></a>RuntimeException运行时异常</h4><pre><code>    public class TestException {
    public static void main(String[] args) {
        int a = 0;
        int b = 1;
        if (a!=0) {
            System.out.println(b / a);
        }

        String str = null;
        if (str != null) {
            str.length();
        }

        Animal d = new Dog();
        if (d instanceof Cat) {
            Cat c = (Cat) d;
        }
    }
}
class Animal{

}
class Dog extends Animal{

}
class Cat extends Animal{

}</code></pre><p>里面有 <code>/0</code>异常 有空指针异常，还有类型转换异常</p>
<blockquote>
<p>if里面都是解决异常的方法。</p>
</blockquote>
<h4 id="CheackedException"><a href="#CheackedException" class="headerlink" title="CheackedException"></a>CheackedException</h4><p>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273524104532.png" alt=""></p>
<h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>捕获异常是通过3个关键词来实现的：try–catch–finally。用try执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可以又多条；finally语句最多只有一条，根据自己的需要可有可无)<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273755315926.png" alt=""></p>
<p><strong>1.try:</strong></br><br>try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码，代码中可以产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常作相应的处理。</p>
<blockquote>
<p>一个try语句必须带有至少一个catch语句块或finally语句块。</p>
</blockquote>
<p><strong>ps.</strong>异常处理的代码执行结束后不会回到try语句去执行未执行的代码。</p>
<p><strong>2.catch:</strong></br><br>n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p>n-常用方法，这些方法均继承自Throwable类 。</p>
<p>u-toString ()方法，显示异常的类名和产生异常的原因</p>
<p>u-getMessage()方法，只显示产生异常的原因，但不显示类名。</p>
<p>u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。</p>
<p>n-catch捕获异常时的捕获顺序：</p>
<p>u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。</p>
<p><strong>3.finally:</strong></br><br>n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。</p>
<p>n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。</p>
<p>综合以上的三点可得：</p>
<pre><code>try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}</code></pre><p>try-catch-finally语句块的执行过程： 程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行。如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句执行完之后程序会继续执行finally语句块，finally语句块是可选的    ，如果有，无论是否发生异常都会执行finally语句。</p>
<p>pss.</p>
<ol>
<li>即使try和catch里面有return，也会执行finally语句。执行完再return退出。</li>
<li>finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到System.exit(0)；结束程序运行。</li>
</ol>
<p>实例：</p>
<pre><code>/*
使用try catch来处理异常
*/
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class TestExpection02 {
    public static void main(String[] args) {
        readMyFile();
    }

    public static void readMyFile(){
        FileReader reader = null;
        try
        {
            reader = new FileReader(&quot;d:/c.txt&quot;);
            char c1 = (char)reader.read();
            System.out.println(c1);

        } catch(FileNotFoundException e)  //子类异常在父类异常前面
        {
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        }finally {
            try{
                if (reader != null){
                    reader.close();
                }
            }catch (IOException e){
                e.printStackTrace();
            }
        }
    }
}</code></pre><p>结果是：</p>
<pre><code>java.io.FileNotFoundException: d:\c.txt (系统找不到指定的文件。)
at java.io.FileInputStream.open0(Native Method)
at java.io.FileInputStream.open(FileInputStream.java:195)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)
at java.io.FileReader.&lt;init&gt;(FileReader.java:58)
at cn.sxt.test.TestExpection02.readMyFile(TestExpection02.java:17)
at cn.sxt.test.TestExpection02.main(TestExpection02.java:10)</code></pre><h4 id="异常处理方法2：throws"><a href="#异常处理方法2：throws" class="headerlink" title="异常处理方法2：throws"></a>异常处理方法2：throws</h4><p>当CheckedException产生时，不一定立刻处理它，可以把异常throws(扔出去)出去.在某些情况下不需要处理法伤的异常，而是向上传递给调用它的方法处理。</p>
<p>如果一个方法中产生某种异常但是并不确定如何处理这种异常，则应该根据异常规范在方法的部首声明该方法可能抛出的异常例子(我不太会)</p>
<pre><code>import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test9 {
    public static void main(String[] args) {
        try {
            readFile(&quot;joke.txt&quot;);
        } catch (FileNotFoundException e) {
            System.out.println(&quot;所需文件不存在！&quot;);
        } catch (IOException e) {
            System.out.println(&quot;文件读写错误！&quot;);
        }
    }  
    public static void readFile(String fileName) throws FileNotFoundException,          
    IOException {
        FileReader in = new FileReader(fileName);
        int tem = 0;
        try {
            tem = in.read();
            while (tem != -1) {
                System.out.print((char) tem);
                tem = in.read();
            }
        } finally {
            in.close();
        }
    }
}</code></pre><p>注意：方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不可超过父类的声明范围。</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ol>
<li><p>我们在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类。即自定义异常类。</p>
</li>
<li><p>自定义异常类只需要从Exception类或它的子类派生一个子类即可。</p>
</li>
<li><p>自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理；若干不想处理,可以让自定义异常类继承运行时异常RuntimeExcepion类。</p>
</li>
<li><p>习惯上，自定义异常类应该包含2个构造器：默认的构造器，另一个是带有详细信息的构造器。</p>
<pre><code>public class TestException03 {
public static void main(String[] args) {
    Person p = new Person();
    p.setAge(-10);
    }
}    

class Person{
private int age;

public int getAge() {
    return age;
}

public void setAge(int age) {
    if(age&lt;0){
        throw new IllegalAgeException(&quot;年龄不可以为负数&quot;);
        }
    this.age = age;
    }
}
class IllegalAgeException extends RuntimeException{
public IllegalAgeException(){

}
public IllegalAgeException(String msg){
    super(msg);//引用父类的方法
    }
}</code></pre><p>输出结果</p>
<p> Exception in thread “main” cn.sxt.test.IllegalAgeException: 年龄不可以为负数<br> at cn.sxt.test.Person.setAge(TestException03.java:18)<br> at cn.sxt.test.TestException03.main(TestException03.java:6)</p>
<h4 id="学会百度！"><a href="#学会百度！" class="headerlink" title="学会百度！"></a>学会百度！</h4><p>众所周知，百度是万能的。一般我们遇到的异常别人都遇到过，cv过去就好了。</p>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li><p>Error与Exception都继承自Throwable类</p>
</li>
<li><p>Error类层次描述了Java运行时系统内部错误和资源耗尽错误。</p>
</li>
<li><p>Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。</p>
</li>
<li><p>常见的异常类型</p>
</li>
</ol>
<ul>
<li><p>ArithmeticException </p>
<blockquote>
<p>算术异常</p>
</blockquote>
</li>
<li><p>NullPointerException</p>
<blockquote>
<p>空指针异常</p>
</blockquote>
</li>
<li><p>ClassCastException</p>
<blockquote>
<p>类型转换异常</p>
</blockquote>
</li>
<li><p>ArrayIndexOutOfBoundsException</p>
<blockquote>
<p>数组下标异常</p>
</blockquote>
</li>
<li><p>NumberFormatException</p>
<blockquote>
<p>数字格式化异常</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li><p>方法重写中声明异常原则：子类声明的异常范围不能超过父类声明的范围</p>
</li>
<li><p>异常处理的三种方式</p>
</li>
</ol>
<ul>
<li><p>捕获异常:try-catch-finally</p>
</li>
<li><p>声明异常:throws</p>
</li>
</ul>
<ol start="7">
<li>自定义异常类只需从Exception类或者它的子类派生一个子类即可。</li>
</ol>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>开发和学习中时刻需要和数据打交道，如何组织这些数据是我们编程中重要的内容。我们一般通过”容器”来容纳和管理数据，那什么是”容器”呢？ 生活中能容纳东西的，程序中也有类似功能，就是用来容纳和管理数据的。</p>
<p>数组也是一种容易。但是相对于容器来说不方便。</br><br><strong>数组的劣势：</strong>不灵活。需要事先定义容量，不能随着需求的变化而扩容。比如:我们在一个用户管理系统中，要把今天注册的所有用户取出来，这样用户有多少我们事先是不知道的。所以在这里不能使用数组。<br><strong>数组的优势：</strong>是一种简单的线性序列，可以快速访问数组元素，效率高。如果从效果和类型检查角度讲。数组是最好的。</p>
<p>基于我们对数组的不满意因此引出了容器，也叫集合(Collection)，一下是容器的接口层次结构图：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495613220648265.png" alt=""><br>要学容器我们先学泛型。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li>添加</li>
</ol>
<ul>
<li>add 有两种用法<br>第一种是直接add对象，把对象加在最后面</li>
<li>第二种是在指定位置加对象</li>
</ul>
<ol start="2">
<li>判断是否存在</li>
</ol>
<ul>
<li>通过方法contains 判断一个对象是否在容器中。判断标准： 是否是同一个对象，而不是name是否相同</li>
</ul>
<ol start="3">
<li>获得指定位置的对象</li>
</ol>
<ul>
<li>通过get获取指定位置的对象，如果输入的下标越界，一样会报错</li>
</ul>
<ol start="4">
<li>获取对象所处的位置</li>
</ol>
<ul>
<li>indexOf用于判断一个对象在ArrayList中所处的位置。与contains一样，判断标准是对象是否相同，而非对象的name值是否相等</li>
</ul>
<ol start="5">
<li>删除元素</li>
</ol>
<ul>
<li>remove用于把对象从ArrayList中删除<br>remove可以根据下标删除ArrayList的元素<br>。也可以根据对象删除</li>
</ul>
<ol start="6">
<li>替换</li>
</ol>
<ul>
<li>set用于替换指定位置的元素</li>
</ul>
<ol start="7">
<li>获取大小</li>
</ol>
<ul>
<li>size 用于获取ArrayList的大小</li>
</ul>
<ol start="8">
<li>转换为数组</li>
</ol>
<ul>
<li>toArray可以把一个ArrayList对象转换为数组。<br>需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组</li>
</ul>
<ol start="9">
<li>把另一个容器的对象都加进来</li>
</ol>
<ul>
<li>addAll 把另一个容器所有对象都加进来</li>
</ul>
<ol start="10">
<li>清空一个容器</li>
</ol>
<ul>
<li>clear 清空一个ArrayList</li>
</ul>
<pre><code>package ArrayList;

import Basic.Hero;
import com.sun.scenario.effect.impl.sw.java.JSWBlend_SRC_OUTPeer;

import java.util.ArrayList;

public class practiceCommonMethods {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();

        //初始化5个对象
        for(int i = 0;i &lt; 5;i++){
            heros.add(new Hero(&quot;hero &quot; + i));
        }
        Hero spe = new Hero(&quot;special hero&quot;);
        heros.add(spe);

        System.out.println(heros + &quot; &quot;);

        //判断一个对象是否在容器里面
        //判断标准：是否是同一个对象，而不是name是否相同；
        System.out.print(&quot;虽然一个新的对象名字叫hero 1，但是contains的返回是：&quot;);
        System.out.println(heros.contains(new Hero(&quot;hero 1&quot;)));
        System.out.print(&quot;然而对于spe，contains的返回是：&quot;);
        System.out.println(heros.contains(spe));

        //通过get获取指定索引的元素
        System.out.println(heros.get(5));
        //越界会报错
        //System.out.println(heros.get(8));
        System.out.println(&quot;special hero的位置是&quot;+heros.indexOf(spe));
        System.out.println(heros.size());

        //remove用于把对象从ArrayList中删除
        //remover可以根据下标删除ArrayList的元素
        //remove下标为2的对象
        heros.remove(2);
        System.out.print(heros+&quot; &quot;);

        //set用于替换指定位置的元素
        //把下标为4的元素替换成hero 5；
        System.out.println();
        heros.set(4,new Hero(&quot;hero 5&quot;));
        System.out.print(heros + &quot; &quot;);
        System.out.println();

        //用toArray的方法把ArrayList变成Array，并增强for循环输出
        Hero []hs = (Hero[]) heros.toArray(new Hero []{});
        for (Hero temp : hs)
            System.out.print(temp + &quot; &quot;);

        //清空ArrayList里面的所有元素
        System.out.println();
        heros.clear();
        System.out.print(heros);
    }
}</code></pre><p>会输出</p>
<pre><code>[hero 0, hero 1, hero 2, hero 3, hero 4, special hero] 
虽然一个新的对象名字叫hero 1，但是contains的返回是：false
然而对于spe，contains的返回是：true
special hero
special hero的位置是5
6
[hero 0, hero 1, hero 3, hero 4, special hero] 
[hero 0, hero 1, hero 3, hero 4, hero 5] 
[]</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><pre><code>package ArrayList;

import Basic.Hero;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/*
集合框架的遍历
*/

public class practiceErgodic {
    public static void main(String[] args) {
        List&lt;Hero&gt; heros = new ArrayList&lt;&gt;();

        //放5个Hero进入容器
        for (int i = 0; i &lt; 5; i++) {
            heros.add(new Hero(&quot;hero name&quot; + i));
        }

        //第一种遍历for循环
        System.out.println(&quot;------------for 循环---------------&quot;);
        for (int i = 0; i &lt; heros.size(); i++) {
            Hero h = heros.get(i);
            System.out.println(h);
        }

        //◀第二种迭代器遍历
        System.out.println(&quot;---------- while的iterator遍历 ---------------&quot;);
        Iterator&lt;Hero&gt; it = heros.iterator();
        //从最开始的位置判断&quot;下一个&quot;位置是否有数据
        //如果有就通过next取出来，并把指针向下移动
        //知道&quot;下一个&quot;位置没有数据了
        /*(1) 使用方法iterator()要求容器返回一个Iterator。
        第一次调用Iterator的next()方法时，它返回序列的第一个元素。
        注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
　　      (2) 使用next()获得序列中的下一个元素。
　　      (3) 使用hasNext()检查序列中是否还有元素。
　　      (4) 使用remove()将迭代器新返回的元素删除。*/
        while (it.hasNext()) {
            Hero h1 = it.next();
            System.out.println(h1);
        }
        System.out.println(&quot;---------- for的iterator遍历 --------------&quot;);
        for (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext(); ) {
            Hero hero = iterator.next();
            System.out.println(hero);
        }
        //增强for循环遍历
        System.out.println(&quot;---------- 增强for循环遍历 --------------&quot;);
        for (Hero h2 : heros) {
            System.out.println(h2);
        }

        //练习输出非八倍数的元素
        System.out.println(&quot;练习--------------------------------------------------&quot;);
        List&lt;Hero&gt; heros1 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 100; i++) {
            if (i%8 != 0 )
                heros1.add(new Hero(&quot;hero&quot; + i));
        }
        for(Hero h3 : heros1){
            System.out.print(h3 + &quot; &quot;);
        }
    }
}</code></pre><p>会输出</p>
<pre><code>    ------------for 循环---------------
hero name0
hero name1
hero name2
hero name3
hero name4
---------- while的iterator遍历 ---------------
hero name0
hero name1
hero name2
hero name3
hero name4
---------- for的iterator遍历 --------------
hero name0
hero name1
hero name2
hero name3
hero name4
---------- 增强for循环遍历 --------------
hero name0
hero name1
hero name2
hero name3
hero name4
练习--------------------------------------------------
hero1 hero2 hero3 hero4 hero5 hero6 hero7 hero9 hero10 hero11 hero12 hero13 hero14 hero15 hero17 hero18 hero19 hero20 hero21 hero22 hero23 hero25 hero26 hero27 hero28 hero29 hero30 hero31 hero33 hero34 hero35 hero36 hero37 hero38 hero39 hero41 hero42 hero43 hero44 hero45 hero46 hero47 hero49 hero50 hero51 hero52 hero53 hero54 hero55 hero57 hero58 hero59 hero60 hero61 hero62 hero63 hero65 hero66 hero67 hero68 hero69 hero70 hero71 hero73 hero74 hero75 hero76 hero77 hero78 hero79 hero81 hero82 hero83 hero84 hero85 hero86 hero87 hero89 hero90 hero91 hero92 hero93 hero94 hero95 hero97 hero98 hero99 </code></pre><h4 id="集合框架LinkedList"><a href="#集合框架LinkedList" class="headerlink" title="集合框架LinkedList"></a>集合框架LinkedList</h4><p>序列分先进先出FIFO,先进后出FILO</br><br>FIFO在Java中又叫Queue 队列</br><br>FILO在Java中又叫Stack 栈</br><br>测试LinkedList的特有的方法</p>
<pre><code>package ArrayList;

import Basic.Hero;

import java.util.LinkedList;

/*
与ArrayList一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。

除了实现了List接口外，LinkedList还实现了双向链表结构Deque，可以很方便的在头尾插入删除数据
什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，
每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，
不用关心除此之外的其他佛珠在哪里。
*/
public class practiceLinkedList {
    public static void main(String[] args) {
        //LinkedList是一个双向链表结构的list
        LinkedList&lt;Hero&gt; ll = new LinkedList&lt;&gt;();

        //所以可以很方便的在头部和尾部插入数据
        //在遭遇过i有插入新的英雄
        ll.addLast(new Hero(&quot;hero1&quot;));
        ll.addLast(new Hero(&quot;hero2&quot;));
        ll.addLast(new Hero(&quot;hero3&quot;));
        System.out.println(ll);

        //在最前面插入新的英雄
        ll.addFirst(new Hero(&quot;heroX&quot;));
        System.out.println(&quot;添加完元素后的List：&quot;+ll);

        //查看最前面的英雄
        System.out.println(&quot;查看最前的元素：&quot;+ll.getFirst());
        //查看最后面的英雄
        System.out.println(&quot;查看最后的元素：&quot;+ll.getLast());

        //查看不会导致英雄被删除
        System.out.println(&quot;查看后的List：&quot;+ll);

        //取出最前面的英雄
        System.out.println(&quot;取出最头的元素：&quot;+ll.removeFirst());

        //取出最后的英雄
        System.out.println(&quot;取出最后的元素：&quot;+ll.removeLast());

        //取出会导致英雄被删除
        System.out.println(&quot;取出元素之后的List：&quot; + ll);
    }
}</code></pre><p>会输出</p>
<pre><code>[hero1, hero2, hero3]
添加完元素后的List：[heroX, hero1, hero2, hero3]
查看最前的元素：heroX
查看最后的元素：hero3
查看后的List：[heroX, hero1, hero2, hero3]
取出最头的元素：heroX
取出最后的元素：hero3
取出元素之后的List：[hero1, hero2]</code></pre><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue是FIFO的</p>
<pre><code>package ArrayList;

import Basic.Hero;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class practiceQueue {
    public static void main(String[] args) {
        //和ArrayList一样，LinkedList也实现了List接口
        List ll = new LinkedList&lt;Hero&gt;();

        //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口
        //Queue代表FIFO先进先出的队列
        Queue&lt;Hero&gt; q = new LinkedList&lt;&gt;();
        System.out.print(&quot;初始化队列：\t&quot;);
        q.offer(new Hero(&quot;hero 1&quot;));
        q.offer(new Hero(&quot;hero 2&quot;));
        q.offer(new Hero(&quot;hero 3&quot;));
        q.offer(new Hero(&quot;hero 4&quot;));
        System.out.println(q);

        System.out.println(&quot;把第一个元素poll()出来：\t&quot;);
        //取出第一个Hero，FIFO先进先出
        System.out.println(q.poll());

        System.out.println(&quot;取出第一个元素后的队列：\t&quot;);
        System.out.println(q);

        //把第一个拿出来看看，单不取出来
        System.out.println(&quot;查看peek()第一个元素：\t&quot; + q.peek());
        System.out.println(q);
    }
}</code></pre><p>会输出</p>
<pre><code>初始化队列：    [hero 1, hero 2, hero 3, hero 4]
把第一个元素poll()出来：    
hero 1
取出第一个元素后的队列：    
[hero 2, hero 3, hero 4]
查看peek()第一个元素：    hero 2
[hero 2, hero 3, hero 4]</code></pre><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。</br></p>
<p>如何选用ArrayList、LinkedList、Vector?</p>
<ol>
<li>需要线程安全时，用Vector。</li>
<li>不存在线程安全问题时，并且查找较多用ArrayList(一般使用它)。</li>
<li>不存在线程安全问题时，增加或删除元素较多用LinkedList。</li>
<li><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3>Map的储存方式是以键(key)-值(value)对的方式储存的,储存的”键值对”通过键来标识，所以”键对象”不能重复</li>
</ol>
<p>Map接口实现类有HashMap、TreeMap、HashTable、Properties等<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495617463792119.png" alt=""></p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap采用哈希算法实现，是Map接口最常用的实现类。由于底层采用了Hash表储存数据，我们要求键不能重复，如果发生重复，新的键值会替换旧的键值对。HashMap在查找、删除、修改方面都有非常高的效率。</p>
<pre><code>package ArrayList;

import Basic.Hero;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class practiceHashMap {
    public static void main(String[] args) {
        HashMap&lt;String, String&gt; dictionary = new HashMap&lt;&gt;();
        dictionary.put(&quot;adc&quot;,&quot;物理英雄&quot;);
        dictionary.put(&quot;apc&quot;,&quot;法术英雄&quot;);
        dictionary.put(&quot;t&quot;,&quot;坦克&quot;);

        System.out.println(dictionary.get(&quot;t&quot;));

        HashMap&lt;String,Hero&gt; heroHashMap = new HashMap&lt;&gt;();

        heroHashMap.put(&quot;gareen&quot;,new Hero(&quot;gareen1&quot;));
        System.out.println(heroHashMap);

        //key为gareen已经有value了，再以gareen作为key放入数据，会导致原英雄被覆盖
        //不会增加新的元素到Map里
        heroHashMap.put(&quot;gareen&quot;,new Hero(&quot;gareen2&quot;));
        System.out.println(heroHashMap);

        //清空map
        heroHashMap.clear();
        Hero hero = new Hero(&quot;gareen&quot;);

        //同一个对象可以作为值插入到map中，只要对应的key不一样
        heroHashMap.put(&quot;gareen1&quot;,hero);
        heroHashMap.put(&quot;gareen2&quot;,hero);
        System.out.println(heroHashMap.values());
    }
}</code></pre><p>会输出</p>
<pre><code>坦克
{gareen=gareen1}
{gareen=gareen2}
{gareen2=gareen, gareen1=gareen}</code></pre><blockquote>
<p>一个获取键值的好方法</p>
</blockquote>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class TestMap {
    public static void main(String[] args) {
        Employee e1 = new Employee(1001,&quot;zwz&quot;,50000);
        Employee e2 = new Employee(1002,&quot;hxm&quot;,40000);
        Employee e3 = new Employee(1003,&quot;haha&quot;,5000);
        Employee e4 = new Employee(1004,&quot;xixi&quot;,6000);
        //WEmployee e5 = new Employee(1001,&quot;6&quot;,6000);

        Map&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;();
        map.put(1001,e1);
        map.put(1002,e2);
        map.put(1003,e3);
        map.put(1004,e4);
        //map.put(1001,e5);

        Employee emp = map.get(1001);

        System.out.println(emp.getSalary());
        //System.out.println(map);
    }
}

//雇员信息
class Employee{
    private int id;
    private  String name;
    private double salary;

    @Override
    public String toString() {
        return &quot;id= &quot; + id + &quot;name= &quot; + name + &quot;薪水= &quot;+salary;
    }

    public Employee(int id, String name, double salary) {
        super();
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}</code></pre><blockquote>
<p>不妨把class Employee 看成一个结构体。Map定义的泛型是&lt;Interge，Employee&gt; 用对象把Employee信息包起来然后放进了HashMap的value里面。等于保存了多个信息。再用get方法即可看到雇员的信息了。</p>
</blockquote>
<h4 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h4><ol>
<li>HashMap：线程不安全，效率高。允许key或value为null；</li>
<li>HashTable：线程安全，效率低，不允许key或value为null；</li>
</ol>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class practiceCollections {
    public static void main(String[] args) {
        //初始化集合numbers
        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; 10; i++) {
            numbers.add(i);
        }
        System.out.println(&quot;集合中的所有元素&quot;);
        System.out.println(numbers);

        Collections.reverse(numbers);

        System.out.println(&quot;反转集合中的所有元素&quot;);
        System.out.println(numbers);

        Collections.shuffle(numbers);
        System.out.println(&quot;混淆List数据中的顺序&quot;);
        System.out.println(numbers);

        Collections.sort(numbers);
        System.out.println(&quot;顺序排列集合中的元素&quot;);
        System.out.println(numbers);

        Collections.swap(numbers,0,5);
        System.out.println(&quot;交换第一个和第六个数子厚的集合&quot;);
        System.out.println(numbers);

        Collections.rotate(numbers,8);
        System.out.println(&quot;向右滚动8个集合&quot;);
        System.out.println(numbers);

        // ---------------------------------------------------
        /*首先初始化一个List,长度是10，值是0-9。
            然后不断的shuffle，直到前3位出现
            3 1 4
            shuffle 1000,000 次，统计出现的概率*/
        List&lt;Integer&gt; number2 = new ArrayList&lt;&gt;();
        int count = 0 ;
        for (int i = 0;i &lt; 10;i++){
            number2.add(i);
        }
        for (int i = 0;i &lt; 1000000; i++){
            Collections.shuffle(number2);
            if (number2.get(0)==3 &amp;&amp; number2.get(1)==1 &amp;&amp; number2.get(2)==4) {
                count++;
            }
        }
        System.out.println(count);
    }
}</code></pre><p>会输出</p>
<pre><code>集合中的所有元素
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
反转集合中的所有元素
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
混淆List数据中的顺序
[6, 1, 9, 2, 7, 0, 5, 8, 4, 3]
顺序排列集合中的元素
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
交换第一个和第六个数子厚的集合
[5, 1, 2, 3, 4, 0, 6, 7, 8, 9]
向右滚动8个集合
[2, 3, 4, 0, 6, 7, 8, 9, 5, 1]
1312    </code></pre><h3 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h3><p><strong>泛型：</strong>它可以帮助我们建立类型安全的集合，遍历时不用强制类型转换，提高了可读性以及安全性。</br><br>泛型本质就是：”数据类型的参数化”。我们可以把”泛型”理解为数据类型的一个占位符(形参)，即高数编译器，在调用泛型时必须传入实际类型。</p>
<blockquote>
<p>说白了就是避免转型</p>
</blockquote>
<h2 id="I-O看我的另一篇吧"><a href="#I-O看我的另一篇吧" class="headerlink" title="I/O看我的另一篇吧"></a>I/O看我的另一篇吧</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/27/IO%E6%B5%81/" rel="prev" title="IO流">
      <i class="fa fa-chevron-left"></i> IO流
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/27/Junit/" rel="next" title="Junit">
      Junit <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-从入门到入土"><span class="nav-number">1.</span> <span class="nav-text">Java (从入门到入土)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识"><span class="nav-number">1.0.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">1.0.2.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象"><span class="nav-number">1.0.3.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建对象"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源代码的声明规则："><span class="nav-number">1.0.3.3.</span> <span class="nav-text">源代码的声明规则：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java包"><span class="nav-number">1.0.3.3.1.</span> <span class="nav-text">Java包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#import语句"><span class="nav-number">1.0.3.3.2.</span> <span class="nav-text">import语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java基本数据类型"><span class="nav-number">1.0.4.</span> <span class="nav-text">Java基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java常量"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">Java常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java变量类型"><span class="nav-number">1.0.5.</span> <span class="nav-text">Java变量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java修饰符"><span class="nav-number">1.0.6.</span> <span class="nav-text">Java修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问控制修饰符"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">访问控制修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#需要注意的继承规则"><span class="nav-number">1.0.6.2.</span> <span class="nav-text">需要注意的继承规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非访问修饰符"><span class="nav-number">1.0.6.3.</span> <span class="nav-text">非访问修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-String-类"><span class="nav-number">1.0.7.</span> <span class="nav-text">Java String 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建字符串"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">创建字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer-amp-StringBuilder"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">StringBuffer &amp; StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用的用法-和python很像"><span class="nav-number">1.0.7.2.1.</span> <span class="nav-text">常用的用法(和python很像)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-时间日期"><span class="nav-number">1.0.8.</span> <span class="nav-text">Java 时间日期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取当前的日期和时间"><span class="nav-number">1.0.8.1.</span> <span class="nav-text">获取当前的日期和时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较日期"><span class="nav-number">1.0.8.2.</span> <span class="nav-text">比较日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用SimpleDateFormat格式化日期"><span class="nav-number">1.0.8.3.</span> <span class="nav-text">使用SimpleDateFormat格式化日期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">1.0.9.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多态的优点"><span class="nav-number">1.0.9.1.</span> <span class="nav-text">多态的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态存在的三个必要条件"><span class="nav-number">1.0.9.2.</span> <span class="nav-text">多态存在的三个必要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java正则表达式-对不起暂时看不懂"><span class="nav-number">1.0.10.</span> <span class="nav-text">Java正则表达式(对不起暂时看不懂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java方法与构造方法-见另一博客-方法与构造方法"><span class="nav-number">1.0.11.</span> <span class="nav-text">Java方法与构造方法(见另一博客-方法与构造方法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的拷贝，扩容和删除"><span class="nav-number">1.0.12.</span> <span class="nav-text">数组的拷贝，扩容和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类"><span class="nav-number">1.0.13.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动装箱与拆箱"><span class="nav-number">1.0.14.</span> <span class="nav-text">自动装箱与拆箱</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#包装类缓存问题"><span class="nav-number">1.0.14.1.</span> <span class="nav-text">包装类缓存问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File类"><span class="nav-number">1.0.15.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的创建"><span class="nav-number">1.0.15.1.</span> <span class="nav-text">文件的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试File类访问属性的基本用法"><span class="nav-number">1.0.15.2.</span> <span class="nav-text">测试File类访问属性的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用mkdir创建目录"><span class="nav-number">1.0.15.3.</span> <span class="nav-text">使用mkdir创建目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归遍历目录结构和树状展现"><span class="nav-number">1.0.15.4.</span> <span class="nav-text">递归遍历目录结构和树状展现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举"><span class="nav-number">1.0.16.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">1.0.17.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常分类"><span class="nav-number">1.0.17.1.</span> <span class="nav-text">异常分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RuntimeException运行时异常"><span class="nav-number">1.0.17.2.</span> <span class="nav-text">RuntimeException运行时异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CheackedException"><span class="nav-number">1.0.17.3.</span> <span class="nav-text">CheackedException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常的捕获"><span class="nav-number">1.0.17.4.</span> <span class="nav-text">异常的捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常处理方法2：throws"><span class="nav-number">1.0.17.5.</span> <span class="nav-text">异常处理方法2：throws</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义异常"><span class="nav-number">1.0.17.6.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#学会百度！"><span class="nav-number">1.0.17.7.</span> <span class="nav-text">学会百度！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.0.17.8.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器"><span class="nav-number">1.0.18.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">1.0.18.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历"><span class="nav-number">1.0.18.2.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合框架LinkedList"><span class="nav-number">1.0.18.3.</span> <span class="nav-text">集合框架LinkedList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue"><span class="nav-number">1.0.18.4.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector"><span class="nav-number">1.0.18.5.</span> <span class="nav-text">Vector</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map接口"><span class="nav-number">1.0.19.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">1.0.19.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap与HashTable的区别"><span class="nav-number">1.0.19.2.</span> <span class="nav-text">HashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collections"><span class="nav-number">1.0.19.3.</span> <span class="nav-text">Collections</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型（Generics）"><span class="nav-number">1.0.20.</span> <span class="nav-text">泛型（Generics）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O看我的另一篇吧"><span class="nav-number">1.1.</span> <span class="nav-text">I&#x2F;O看我的另一篇吧</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
