<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZWZ的博客嘻嘻">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/14/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84+jsp%E7%AD%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/14/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84+jsp%E7%AD%89)/" class="post-title-link" itemprop="url">综合练习笔记(三层架构+jsp等)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-14 18:06:20" itemprop="dateCreated datePublished" datetime="2021-07-14T18:06:20+08:00">2021-07-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><h3 id="简单功能"><a href="#简单功能" class="headerlink" title="简单功能"></a>简单功能</h3><ul>
<li>列表查询</li>
</ul>
<p><img src="https://img04.sogoucdn.com/app/a/100520146/923d17233d755f54610f15f9407ba592" alt=""></p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code>1. 调整页面，加入验证码功能
2. 代码实现</code></pre><blockquote>
<p>从数据库中获取数据然后匹配</p>
</blockquote>
<ul>
<li><p>添加</p>
<p><img src="https://img02.sogoucdn.com/app/a/100520146/5f6bd2d5738cb77f7ba3739e0baf3fdc" alt=""></p>
</li>
</ul>
<ul>
<li>删除</li>
</ul>
<p><img src="https://img04.sogoucdn.com/app/a/100520146/4e68b2fa951cfffcbfcea9d16a2e13be" alt=""></p>
<ul>
<li>修改</li>
</ul>
<p><img src="https://img01.sogoucdn.com/app/a/100520146/e130a526f7927ddc90d81495df504c5b" alt=""></p>
<h3 id="复杂功能"><a href="#复杂功能" class="headerlink" title="复杂功能"></a>复杂功能</h3><ul>
<li>删除选中</li>
</ul>
<p><img src="https://img04.sogoucdn.com/app/a/100520146/33751cab6c96d79c453eeb7453f7a022" alt=""></p>
<ul>
<li>分页查询<pre><code>* 好处：
    1. 减轻服务器内存的开销
    2. 提升用户体验    </code></pre></li>
</ul>
<p><img src="https://img03.sogoucdn.com/app/a/100520146/5ca08d1f9582e438d75360e9a5d4fbf7" alt=""></p>
<p><img src="https://img02.sogoucdn.com/app/a/100520146/6c26be5bbc5b0a8f73d322c747d07e6a" alt=""></p>
<p>3 .复杂条件查询</p>
<p><img src="https://img02.sogoucdn.com/app/a/100520146/77c3eb1c9bb92e462fd74524cb2cd474" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/10/EL&JSTL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/EL&JSTL/" class="post-title-link" itemprop="url">EL&JSTL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-10 17:40:33" itemprop="dateCreated datePublished" datetime="2021-07-10T17:40:33+08:00">2021-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-11 21:41:32" itemprop="dateModified" datetime="2021-07-11T21:41:32+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JSP:
    1. 指令
    2. 注释
    3. 内置对象

2. MVC开发模式
3. EL表达式
4. JSTL标签
5. 三层架构</code></pre><p><img src="https://www.s2tu.com/images/2021/07/10/G5jqlq.png" alt="G5jqlq.png"></p>
<p><img src="https://www.s2tu.com/images/2021/07/11/GwRhpp.png" alt="GwRhpp.png"></p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP:"></a>JSP:</h2><pre><code>1. 指令
    * 作用：用于配置JSP页面，导入资源文件
    * 格式：
        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;
    * 分类：
        1. page        ： 配置JSP页面的
            * contentType：等同于response.setContentType()
                1. 设置响应体的mime类型以及字符集
                2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）
            * import：导包
            * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面
            * isErrorPage：标识当前也是是否是错误页面。
                * true：是，可以使用内置对象exception
                * false：否。默认值。不可以使用内置对象exception


        2. include    ： 页面包含的。导入页面的资源文件
            * &lt;%@include file=&quot;top.jsp&quot;%&gt;
        3. taglib    ： 导入资源
            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
                * prefix：前缀，自定义的
2. 注释:
    1. html注释：
        &lt;!-- --&gt;:只能注释html代码片段
    2. jsp注释：推荐使用
        &lt;%-- --%&gt;：可以注释所有


3. 内置对象
    * 在jsp页面中不需要创建，直接使用的对象
    * 一共有9个：
            变量名                    真实类型                        作用
        * pageContext                PageContext                    当前页面共享数据，还可以获取其他八个内置对象
        * request                    HttpServletRequest            一次请求访问的多个资源(转发)
        * session                    HttpSession                    一次会话的多个请求间
        * application                ServletContext                所有用户间共享数据
        * response                    HttpServletResponse            响应对象
        * page                        Object                        当前页面(Servlet)的对象  this
        * out                        JspWriter                    输出对象，数据输出到页面上
        * config                    ServletConfig                Servlet的配置对象
        * exception                    Throwable                    异常对象</code></pre><h2 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h2><pre><code>1. jsp演变历史
    1. 早期只有servlet，只能使用response输出标签数据，非常麻烦
    2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作
    3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性

2. MVC：
    1. M：Model，模型。JavaBean
        * 完成具体的业务操作，如：查询数据库，封装对象
    2. V：View，视图。JSP
        * 展示数据
    3. C：Controller，控制器。Servlet
        * 获取用户的输入
        * 调用模型
        * 将数据交给视图进行展示


    * 优缺点：
        1. 优点：
            1. 耦合性低，方便维护，可以利于分工协作
            2. 重用性高

        2. 缺点：
            1. 使得项目架构变得复杂，对开发人员要求高</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. 概念：Expression Language 表达式语言
2. 作用：替换和简化jsp页面中java代码的编写
3. 语法：${表达式}
4. 注意：
    * jsp默认支持el表达式的。如果要忽略el表达式
        1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式
        2. \${表达式} ：忽略当前这个el表达式


5. 使用：
    1. 运算：
        * 运算符：
            1. 算数运算符： + - * /(div) %(mod)
            2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=
            3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)
            4. 空运算符： empty
                * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
                * ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
                * ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0
    2. 获取值
        1. el表达式只能从域对象中获取值
        2. 语法：
            1. ${域名称.键名}：从指定域中获取指定键的值
                * 域名称：
                    1. pageScope        --&gt; pageContext
                    2. requestScope     --&gt; request
                    3. sessionScope     --&gt; session
                    4. applicationScope --&gt; application（ServletContext）
                * 举例：在request域中存储了name=张三
                * 获取：${requestScope.name}

            2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。



            3. 获取对象、List集合、Map集合的值
                1. 对象：${域名称.键名.属性名}
                    * 本质上会去调用对象的getter方法

                2. List集合：${域名称.键名[索引]}

                3. Map集合：
                    * ${域名称.键名.key名称}
                    * ${域名称.键名[&quot;key名称&quot;]}


    3. 隐式对象：
        * el表达式中有11个隐式对象
        * pageContext：
            * 获取jsp其他八个内置对象
                * ${pageContext.request.contextPath}：动态获取虚拟目录</code></pre><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><pre><code>1. 概念：JavaServer Pages Tag Library  JSP标准标签库
    * 是由Apache组织提供的开源的免费的jsp标签        &lt;标签&gt;

2. 作用：用于简化和替换jsp页面上的java代码        

3. 使用步骤：
    1. 导入jstl相关jar包
    2. 引入标签库：taglib指令：  &lt;%@ taglib %&gt;
    3. 使用标签

4. 常用的JSTL标签
    1. if:相当于java代码的if语句
        1. 属性：
            * test 必须属性，接受boolean表达式
                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
                * 一般情况下，test属性值会结合el表达式一起使用
            2. 注意：
                * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签
    2. choose:相当于java代码的switch语句
        1. 使用choose标签声明                     相当于switch声明
        2. 使用when标签做判断                     相当于case
        3. 使用otherwise标签做其他情况的声明        相当于default

    3. foreach:相当于java代码的for语句

5. 练习：
    * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中</code></pre><h2 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h2><pre><code>1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互
2. 业务逻辑层：处理业务逻辑的。
3. 数据访问层：操作数据存储文件。</code></pre><h2 id="案例：用户信息列表展示"><a href="#案例：用户信息列表展示" class="headerlink" title="案例：用户信息列表展示"></a>案例：用户信息列表展示</h2><pre><code>1. 需求：用户信息的增删改查操作
2. 设计：
    1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat
    2. 数据库设计：
        create database day17; -- 创建数据库
        use day17;                -- 使用数据库
        create table user(   -- 创建表
            id int primary key auto_increment,
            name varchar(20) not null,
            gender varchar(5),
            age int,
            address varchar(32),
            qq    varchar(20),
            email varchar(50)
        );

3. 开发：
    1. 环境搭建
        1. 创建数据库环境
        2. 创建项目，导入需要的jar包

    2. 编码


4. 测试
5. 部署运维</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/07/Response/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/07/Response/" class="post-title-link" itemprop="url">Response</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-07 21:59:49" itemprop="dateCreated datePublished" datetime="2021-07-07T21:59:49+08:00">2021-07-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. HTTP协议：响应消息
2. Response对象
3. ServletContext对象</code></pre><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><pre><code>1. 请求消息：客户端发送给服务器端的数据
    * 数据格式：
        1. 请求行
        2. 请求头
        3. 请求空行
        4. 请求体
2. 响应消息：服务器端发送给客户端的数据
    * 数据格式：
        1. 响应行
            1. 组成：协议/版本 响应状态码 状态码描述
            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。
                1. 状态码都是3位数字 
                2. 分类：
                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
                    2. 2xx：成功。代表：200
                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)
                    4. 4xx：客户端错误。
                        * 代表：
                            * 404（请求路径没有对应的资源） 
                            * 405：请求方式没有对应的doXxx方法
                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)


        2. 响应头：
            1. 格式：头名称： 值
            2. 常见的响应头：
                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据
                    * 值：
                        * in-line:默认值,在当前页面内打开
                        * attachment;filename=xxx：以附件形式打开响应体。文件下载
        3. 响应空行
        4. 响应体:传输的数据


    * 响应字符串格式
        HTTP/1.1 200 OK
        Content-Type: text/html;charset=UTF-8
        Content-Length: 101
        Date: Wed, 06 Jun 2018 07:08:42 GMT

        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;$Title$&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
          hello , response
          &lt;/body&gt;
        &lt;/html&gt;</code></pre><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息
    1. 设置响应行
        1. 格式：HTTP/1.1 200 ok
        2. 设置状态码：setStatus(int sc) 
    2. 设置响应头：setHeader(String name, String value) 

    3. 设置响应体：
        * 使用步骤：
            1. 获取输出流
                * 字符输出流：PrintWriter getWriter()

                * 字节输出流：ServletOutputStream getOutputStream()

            2. 使用输出流，将数据输出到客户端浏览器


* 案例：
    1. 完成重定向
        * 重定向：资源跳转的方式
        * 代码实现：
            //1. 设置状态码为302
            response.setStatus(302);
            //2.设置响应头location
            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);


            //简单的重定向方法
            response.sendRedirect(&quot;/day15/responseDemo2&quot;);

        * 重定向的特点:redirect
            1. 地址栏发生变化
            2. 重定向可以访问其他站点(服务器)的资源
            3. 重定向是两次请求。不能使用request对象来共享数据
        * 转发的特点：forward
            1. 转发地址栏路径不变
            2. 转发只能访问当前服务器下的资源
            3. 转发是一次请求，可以使用request对象来共享数据

        * forward 和  redirect 区别

        * 路径写法：
            1. 路径分类
                1. 相对路径：通过相对路径不可以确定唯一资源
                    * 如：./index.html
                    * 不以/开头，以.开头路径

                    * 规则：找到当前资源和目标资源之间的相对位置关系
                        * ./：当前目录
                        * ../:后退一级目录
                2. 绝对路径：通过绝对路径可以确定唯一资源
                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2
                    * 以/开头的路径

                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
                            * 建议虚拟目录动态获取：request.getContextPath()
                            * &lt;a&gt; , &lt;form&gt; 重定向...
                        * 给服务器使用：不需要加虚拟目录
                            * 转发路径




    2. 服务器输出字符数据到浏览器
        * 步骤：
            1. 获取字符输出流
            2. 输出数据

        * 注意：
            * 乱码问题：
                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
                2. 设置该流的默认编码
                3. 告诉浏览器响应体使用的编码

                //简单的形式，设置编码，是在获取流之前设置
                response.setContentType(&quot;text/html;charset=utf-8&quot;);
    3. 服务器输出字节数据到浏览器
        * 步骤：
            1. 获取字节输出流
            2. 输出数据

    4. 验证码
        1. 本质：图片
        2. 目的：防止恶意表单注册</code></pre><h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信
2. 获取：
    1. 通过request对象获取
        request.getServletContext();
    2. 通过HttpServlet获取
        this.getServletContext();
3. 功能：
    1. 获取MIME类型：
        * MIME类型:在互联网通信过程中定义的一种文件数据类型
            * 格式： 大类型/小类型   text/html        image/jpeg

        * 获取：String getMimeType(String file)  
    2. 域对象：共享数据
        1. setAttribute(String name,Object value)
        2. getAttribute(String name)
        3. removeAttribute(String name)

        * ServletContext对象范围：所有用户所有请求的数据
    3. 获取文件的真实(服务器)路径
        1. 方法：String getRealPath(String path)  
             String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问
             System.out.println(b);

            String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问
            System.out.println(c);

            String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问
            System.out.println(a);</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流


* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/07/Servlet&HTTP&Request/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/07/Servlet&HTTP&Request/" class="post-title-link" itemprop="url">Servlet&HTTP&Request</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-07 21:59:24" itemprop="dateCreated datePublished" datetime="2021-07-07T21:59:24+08:00">2021-07-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. Servlet
2. HTTP协议
3. Request</code></pre><h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><pre><code>1. 概念
2. 步骤
3. 执行原理
4. 生命周期
5. Servlet3.0 注解配置
6. Servlet的体系结构    0
    Servlet -- 接口
        |
    GenericServlet -- 抽象类
        |
    HttpServlet  -- 抽象类

    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象
        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可

    * HttpServlet：对http协议的一种封装，简化操作
        1. 定义类继承HttpServlet
        2. 复写doGet/doPost方法

7. Servlet相关配置
    1. urlpartten:Servlet访问路径
        1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})
        2. 路径定义规则：
            1. /xxx：路径匹配
            2. /xxx/xxx:多层路径，目录结构
            3. *.do：扩展名匹配</code></pre><h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><pre><code>* 概念：Hyper Text Transfer Protocol 超文本传输协议
    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式
    * 特点：
        1. 基于TCP/IP的高级协议
        2. 默认端口号:80
        3. 基于请求/响应模型的:一次请求对应一次响应
        4. 无状态的：每次请求之间相互独立，不能交互数据

    * 历史版本：
        * 1.0：每一次请求响应都会建立新的连接
        * 1.1：复用连接

* 请求消息数据格式
    1. 请求行
        请求方式 请求url 请求协议/版本
        GET /login.html    HTTP/1.1

        * 请求方式：
            * HTTP协议有7中请求方式，常用的有2种
                * GET：
                    1. 请求参数在请求行中，在url后。
                    2. 请求的url长度有限制的
                    3. 不太安全
                * POST：
                    1. 请求参数在请求体中
                    2. 请求的url长度没有限制的
                    3. 相对安全
    2. 请求头：客户端浏览器告诉服务器一些信息
        请求头名称: 请求头值
        * 常见的请求头：
            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题

            2. Referer：http://localhost/login.html
                * 告诉服务器，我(当前请求)从哪里来？
                    * 作用：
                        1. 防盗链：
                        2. 统计工作：
    3. 请求空行
        空行，就是用于分割POST请求的请求头，和请求体的。
    4. 请求体(正文)：
        * 封装POST请求消息的请求参数的

    * 字符串格式：
        POST /login.html    HTTP/1.1
        Host: localhost
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
        Accept-Encoding: gzip, deflate
        Referer: http://localhost/login.html
        Connection: keep-alive
        Upgrade-Insecure-Requests: 1

        username=zhangsan    


* 响应消息数据格式</code></pre><h2 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h2><pre><code>1. request对象和response对象的原理
    1. request和response对象是由服务器创建的。我们来使用它们
    2. request对象是来获取请求消息，response对象是来设置响应消息

2. request对象继承体系结构：    
    ServletRequest        --    接口
        |    继承
    HttpServletRequest    -- 接口
        |    实现
    org.apache.catalina.connector.RequestFacade 类(tomcat)

3. request功能：
    1. 获取请求消息数据
        1. 获取请求行数据
            * GET /day14/demo1?name=zhangsan HTTP/1.1
            * 方法：
                1. 获取请求方式 ：GET
                    * String getMethod()  
                2. (*)获取虚拟目录：/day14
                    * String getContextPath()
                3. 获取Servlet路径: /demo1
                    * String getServletPath()
                4. 获取get方式请求参数：name=zhangsan
                    * String getQueryString()
                5. (*)获取请求URI：/day14/demo1
                    * String getRequestURI():        /day14/demo1
                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1

                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国
                    * URI：统一资源标识符 : /day14/demo1                    共和国

                6. 获取协议及版本：HTTP/1.1
                    * String getProtocol()

                7. 获取客户机的IP地址：
                    * String getRemoteAddr()

        2. 获取请求头数据
            * 方法：
                * (*)String getHeader(String name):通过请求头的名称获取请求头的值
                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称

        3. 获取请求体数据:
            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
            * 步骤：
                1. 获取流对象
                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据
                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
                        * 在文件上传知识点后讲解

                2. 再从流对象中拿数据


    2. 其他功能：
        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数
            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123
            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game
            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称
            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合

            * 中文乱码问题：
                * get方式：tomcat 8 已经将get方式乱码问题解决了
                * post方式：会乱码
                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);


        2. 请求转发：一种在服务器内部的资源跳转方式
            1. 步骤：
                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)
                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 

            2. 特点：
                1. 浏览器地址栏路径不发生变化
                2. 只能转发到当前服务器内部资源中。
                3. 转发是一次请求


        3. 共享数据：
            * 域对象：一个有作用范围的对象，可以在范围内共享数据
            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
            * 方法：
                1. void setAttribute(String name,Object obj):存储数据
                2. Object getAttitude(String name):通过键获取值
                3. void removeAttribute(String name):通过键移除键值对

        4. 获取ServletContext：
            * ServletContext getServletContext()</code></pre><h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><pre><code>* 用户登录案例需求：
    1.编写login.html登录页面
        username &amp; password 两个输入框
    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表
    3.使用JdbcTemplate技术封装JDBC
    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您
    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误


* 分析

* 开发步骤
    1. 创建项目，导入html页面，配置文件，jar包
    2. 创建数据库环境
        CREATE DATABASE day14;
        USE day14;
        CREATE TABLE USER(

            id INT PRIMARY KEY AUTO_INCREMENT,
            username VARCHAR(32) UNIQUE NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        );

    3. 创建包cn.itcast.domain,创建类User
        package cn.itcast.domain;
        /**
         * 用户的实体类
         */
        public class User {

            private int id;
            private String username;
            private String password;


            public int getId() {
                return id;
            }

            public void setId(int id) {
                this.id = id;
            }

            public String getUsername() {
                return username;
            }

            public void setUsername(String username) {
                this.username = username;
            }

            public String getPassword() {
                return password;
            }

            public void setPassword(String password) {
                this.password = password;
            }

            @Override
            public String toString() {
                return &quot;User{&quot; +
                        &quot;id=&quot; + id +
                        &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; +
                        &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +
                        &apos;}&apos;;
            }
        }
    4. 创建包cn.itcast.util,编写工具类JDBCUtils
        package cn.itcast.util;

        import com.alibaba.druid.pool.DruidDataSourceFactory;

        import javax.sql.DataSource;
        import javax.xml.crypto.Data;
        import java.io.IOException;
        import java.io.InputStream;
        import java.sql.Connection;
        import java.sql.SQLException;
        import java.util.Properties;

        /**
         * JDBC工具类 使用Durid连接池
         */
        public class JDBCUtils {

            private static DataSource ds ;

            static {

                try {
                    //1.加载配置文件
                    Properties pro = new Properties();
                    //使用ClassLoader加载配置文件，获取字节输入流
                    InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
                    pro.load(is);

                    //2.初始化连接池对象
                    ds = DruidDataSourceFactory.createDataSource(pro);

                } catch (IOException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            /**
             * 获取连接池对象
             */
            public static DataSource getDataSource(){
                return ds;
            }


            /**
             * 获取连接Connection对象
             */
            public static Connection getConnection() throws SQLException {
                return  ds.getConnection();
            }
        }
    5. 创建包cn.itcast.dao,创建类UserDao,提供login方法

        package cn.itcast.dao;

        import cn.itcast.domain.User;
        import cn.itcast.util.JDBCUtils;
        import org.springframework.dao.DataAccessException;
        import org.springframework.jdbc.core.BeanPropertyRowMapper;
        import org.springframework.jdbc.core.JdbcTemplate;

        /**
         * 操作数据库中User表的类
         */
        public class UserDao {

            //声明JDBCTemplate对象共用
            private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());

            /**
             * 登录方法
             * @param loginUser 只有用户名和密码
             * @return user包含用户全部数据,没有查询到，返回null
             */
            public User login(User loginUser){
                try {
                    //1.编写sql
                    String sql = &quot;select * from user where username = ? and password = ?&quot;;
                    //2.调用query方法
                    User user = template.queryForObject(sql,
                            new BeanPropertyRowMapper&lt;User&gt;(User.class),
                            loginUser.getUsername(), loginUser.getPassword());


                    return user;
                } catch (DataAccessException e) {
                    e.printStackTrace();//记录日志
                    return null;
                }
            }
        }

    6. 编写cn.itcast.web.servlet.LoginServlet类
        package cn.itcast.web.servlet;

        import cn.itcast.dao.UserDao;
        import cn.itcast.domain.User;

        import javax.servlet.ServletException;
        import javax.servlet.annotation.WebServlet;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;


        @WebServlet(&quot;/loginServlet&quot;)
        public class LoginServlet extends HttpServlet {


            @Override
            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                //1.设置编码
                req.setCharacterEncoding(&quot;utf-8&quot;);
                //2.获取请求参数
                String username = req.getParameter(&quot;username&quot;);
                String password = req.getParameter(&quot;password&quot;);
                //3.封装user对象
                User loginUser = new User();
                loginUser.setUsername(username);
                loginUser.setPassword(password);

                //4.调用UserDao的login方法
                UserDao dao = new UserDao();
                User user = dao.login(loginUser);

                //5.判断user
                if(user == null){
                    //登录失败
                    req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);
                }else{
                    //登录成功
                    //存储数据
                    req.setAttribute(&quot;user&quot;,user);
                    //转发
                    req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);
                }

            }

            @Override
            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                this.doGet(req,resp);
            }
        }

    7. 编写FailServlet和SuccessServlet类
        @WebServlet(&quot;/successServlet&quot;)
        public class SuccessServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                //获取request域中共享的user对象
                User user = (User) request.getAttribute(&quot;user&quot;);

                if(user != null){
                    //给页面写一句话

                    //设置编码
                    response.setContentType(&quot;text/html;charset=utf-8&quot;);
                    //输出
                    response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;);
                }


            }        


        @WebServlet(&quot;/failServlet&quot;)
        public class FailServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                //给页面写一句话

                //设置编码
                response.setContentType(&quot;text/html;charset=utf-8&quot;);
                //输出
                response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);

            }

            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                this.doPost(request,response);
            }
        }



    8. login.html中form表单的action路径的写法
        * 虚拟目录+Servlet的资源路径

    9. BeanUtils工具类，简化数据封装
        * 用于封装JavaBean的
        1. JavaBean：标准的Java类
            1. 要求：
                1. 类必须被public修饰
                2. 必须提供空参的构造器
                3. 成员变量必须使用private修饰
                4. 提供公共setter和getter方法
            2. 功能：封装数据


        2. 概念：
            成员变量：
            属性：setter和getter方法截取后的产物
                例如：getUsername() --&gt; Username--&gt; username


        3. 方法：
            1. setProperty()
            2. getProperty()
            3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/07/Tomcat&Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/07/Tomcat&Servlet/" class="post-title-link" itemprop="url">Tomcat&Servlet</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-07 21:58:47" itemprop="dateCreated datePublished" datetime="2021-07-07T21:58:47+08:00">2021-07-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web相关概念回顾
2. web服务器软件：Tomcat
3. Servlet入门学习</code></pre><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构
    1. C/S：客户端/服务器端
    2. B/S：浏览器/服务器端

2. 资源分类
    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析
        * 如： html,css,JavaScript
    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器
        * 如：servlet/jsp,php,asp....


3. 网络通信三要素
    1. IP：电子设备(计算机)在网络中的唯一标识。
    2. 端口：应用程序在计算机中的唯一标识。 0~65536
    3. 传输协议：规定了数据传输的规则
        1. 基础协议：
            1. tcp:安全协议，三次握手。 速度稍慢
            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机
* 服务器软件：接收用户的请求，处理请求，做出响应
* web服务器软件：接收用户的请求，处理请求，做出响应。
    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目
    * web容器


* 常见的java相关的web服务器软件：
    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。


* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范

* Tomcat：web服务器软件
    1. 下载：http://tomcat.apache.org/
    2. 安装：解压压缩包即可。
        * 注意：安装目录建议不要有中文和空格
    3. 卸载：删除目录就行了
    4. 启动：
        * bin/startup.bat ,双击运行该文件即可
        * 访问：浏览器输入：http://localhost:8080 回车访问自己
                          http://别人的ip:8080 访问别人

        * 可能遇到的问题：
            1. 黑窗口一闪而过：
                * 原因： 没有正确配置JAVA_HOME环境变量
                * 解决方案：正确配置JAVA_HOME环境变量

            2. 启动报错：
                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程
                    * netstat -ano
                2. 温柔：修改自身的端口号
                    * conf/server.xml
                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;
                       connectionTimeout=&quot;20000&quot;
                       redirectPort=&quot;8445&quot; /&gt;
                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。
                        * 好处：在访问时，就不用输入端口号
    5. 关闭：
        1. 正常关闭：
            * bin/shutdown.bat
            * ctrl+c
        2. 强制关闭：
            * 点击启动窗口的×
    6. 配置:
        * 部署项目的方式：
            1. 直接将项目放到webapps目录下即可。
                * /hello：项目的访问路径--&gt;虚拟目录
                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。
                    * war包会自动解压缩

            2. 配置conf/server.xml文件
                在&lt;Host&gt;标签体中配置
                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;
                * docBase:项目存放的路径
                * path：虚拟目录

            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写
                &lt;Context docBase=&quot;D:\hello&quot; /&gt;
                * 虚拟目录：xml文件的名称

        * 静态项目和动态项目：
            * 目录结构
                * java动态项目的目录结构：
                    -- 项目的根目录
                        -- WEB-INF目录：
                            -- web.xml：web项目的核心配置文件
                            -- classes目录：放置字节码文件的目录
                            -- lib目录：放置依赖的jar包


        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre><h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序
    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
    * 将来我们自定义一个类，实现Servlet接口，复写方法。


* 快速入门：
    1. 创建JavaEE项目
    2. 定义一个类，实现Servlet接口
        * public class ServletDemo1 implements Servlet
    3. 实现接口中的抽象方法
    4. 配置Servlet
         在web.xml中配置：
        &lt;!--配置Servlet --&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;
        &lt;/servlet&gt;

        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;

* 执行原理：
    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。
    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名
    4. tomcat会将字节码文件加载进内存，并且创建其对象
    5. 调用其方法

* Servlet中的生命周期方法：
    1. 被创建：执行init方法，只执行一次
        * Servlet什么时候被创建？
            * 默认情况下，第一次被访问时，Servlet被创建
            * 可以配置执行Servlet的创建时机。
                * 在&lt;servlet&gt;标签下配置
                    1. 第一次被访问时，创建
                        * &lt;load-on-startup&gt;的值为负数
                    2. 在服务器启动时，创建
                        * &lt;load-on-startup&gt;的值为0或正整数


        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
            * 多个用户同时访问时，可能存在线程安全问题。
            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值

    2. 提供服务：执行service方法，执行多次
        * 每次访问Servlet时，Service方法都会被调用一次。
    3. 被销毁：执行destroy方法，只执行一次
        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁
        * 只有服务器正常关闭时，才会执行destroy方法。
        * destroy方法在Servlet被销毁之前执行，一般用于释放资源

* Servlet3.0：
    * 好处：
        * 支持注解配置。可以不需要web.xml了。

    * 步骤：
        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
        2. 定义一个类，实现Servlet接口
        3. 复写方法
        4. 在类上使用@WebServlet注解，进行配置
            * @WebServlet(&quot;资源路径&quot;)


            @Target({ElementType.TYPE})
            @Retention(RetentionPolicy.RUNTIME)
            @Documented
            public @interface WebServlet {
                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;

                String[] value() default {};//代表urlPatterns()属性配置

                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;

                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;

                WebInitParam[] initParams() default {};

                boolean asyncSupported() default false;

                String smallIcon() default &quot;&quot;;

                String largeIcon() default &quot;&quot;;

                String description() default &quot;&quot;;

                String displayName() default &quot;&quot;;
            }</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件
    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;

2. 工作空间项目    和     tomcat部署的web项目
    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源
    * WEB-INF目录下的资源不能被浏览器直接访问。
3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/03/%E8%AE%A1%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/%E8%AE%A1%E7%BB%84/" class="post-title-link" itemprop="url">计组</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-03 17:38:33" itemprop="dateCreated datePublished" datetime="2021-07-03T17:38:33+08:00">2021-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-04 14:47:19" itemprop="dateModified" datetime="2021-07-04T14:47:19+08:00">2021-07-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机中各个硬件部分"><a href="#计算机中各个硬件部分" class="headerlink" title="计算机中各个硬件部分"></a>计算机中各个硬件部分</h2><h3 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h3><ol>
<li>计算机由五大部件组成：输出设备、输入设备、存储器、运算器、控制器。</li>
<li>指令和数据以同等地位存储于存储器，可以按地址寻访</li>
<li>指令和数据都是用二进制表示的</li>
<li>指令由操作码和地址码组成的</li>
<li>存储程序（会提前把指令和数据提前存储到存储器当中）</li>
<li><strong>以运算器为中心</strong><br><a href="https://www.s2tu.com/image/G84WRC" target="_blank" rel="noopener"><img src="https://www.s2tu.com/images/2021/07/03/G84WRC.png" alt="G84WRC.png"></a></li>
</ol>
<h3 id="现代计算机的特点"><a href="#现代计算机的特点" class="headerlink" title="现代计算机的特点"></a>现代计算机的特点</h3><ol>
<li>以存储器为中心</li>
</ol>
<blockquote>
<p>CPU = 运算器+控制器<br>主机 = CPU+主存(运行内存)<br>IO设备 = 输入输出设备+辅存<br>硬件等于 = 主机+IO设备<br><img src="https://www.s2tu.com/images/2021/07/03/G8bffd.png" alt="G8bffd.png"></p>
</blockquote>
<h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><p>主存储器 = 存储体+MAR+MDR<BR><br>MAR = Memory Address Register (存储地址寄存器)<br>MDR = Memory Data Register （存储数据寄存器）</p>
<h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><p>运算器：用于实现算术运算(如：加减乘除)、逻辑运算(如：与或非)</br></p>
<ul>
<li>ACC(Accumulator)：累加器，用于存放操作数，或运算结果</li>
<li>MQ(Multiple-Quotient Register)：乘商寄存器，在算乘、除运算时，用于存放操作数或运算结果</li>
<li>X：通用的操作数寄存器，用于存放操作数</li>
<li><strong>ALU</strong> (Arithmetic and Logic Unit)：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算。</li>
</ul>
<h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><ul>
<li><strong>CU</strong>(Control Unit)：控制单元，分析指令，给出控制信号</li>
<li>IR(Instruction Register)：指令寄存器，存放当前执行的指令</li>
<li>PC(Program Counter)：程序计数器，存放下一条指令的地址，有自动加一的功能</li>
</ul>
<h3 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h3><ul>
<li><p>第一条指令的过程(把a取到ACC中)<br><img src="https://www.s2tu.com/images/2021/07/03/G82Q5C.png" alt="G82Q5C.png"></p>
</li>
<li><p>第二条指令(乘b得ab，存到ACC中)<br><img src="https://www.s2tu.com/images/2021/07/03/G8pI4v.png" alt="G8pI4v.png"></p>
</li>
</ul>
<h4 id="取数指令的执行："><a href="#取数指令的执行：" class="headerlink" title="取数指令的执行："></a>取数指令的执行：</h4><blockquote>
<p>从主存中指定地址处取数</p>
</blockquote>
<p>(PC) -&gt; MAR </br><br>M(MAR) -&gt; MDR </br><br>(MDR) -&gt; IR </br></p>
<p>取指令结束 (PC)+1 -&gt; PC </br><br>OP(IR) -&gt; CU </br></p>
<blockquote>
<p>以上步骤都是必须经历的</p>
</blockquote>
<p>分析指令结束<br>Ad(IR) -&gt; MAR </br><br>M(MAR) -&gt; MDR </br><br>(MDR) -&gt; ACC </br><br>执行指令结束</p>
<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><ul>
<li>首先是微程序机器(微指令系统)</li>
<li>传统机器(用机器语言)</li>
<li>操作系统机器</li>
<li>汇编语言机器</li>
<li>高级语言机器</li>
</ul>
<p>上层的机器是下层的基础，下层的机器是上层的拓展</p>
<h3 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h3><ol>
<li>机器语言(二进制代码)</li>
<li>汇编语言(助记符)</li>
<li>高级语言</li>
</ol>
<p>首先高级语言要通过编译程序(即编译器)转换为汇编语言，接着汇编语言要通过汇编程序(即汇编器)转换为机器语言。</br></p>
<p>于是有了编译汇编连接三部程序</p>
<p>有的源程序可以直接通过解释程序(即解释器)转化为机器语言 (比如python，JavaScript，shell等)</p>
<blockquote>
<p>编译程序：将高级语言编写的程序<strong>全部</strong>语句<strong>一次全部</strong>翻译成机器语言程序，后在执行机器语言程序(只需翻译一次)</p>
</blockquote>
<blockquote>
<p>解释程序：将源程序的<strong>一条</strong>语句翻译成对应于机器语言的语句，并立即执行。紧接着在翻译下一句(每次执行都要翻译)</p>
</blockquote>
<h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="存储器的容量"><a href="#存储器的容量" class="headerlink" title="存储器的容量"></a>存储器的容量</h3><ul>
<li>1B = 8bit 1K = 1024B 1M = 1024K 1G = 1024MB 1T = 1024G</li>
</ul>
<p>越大表示存储器越大</p>
<h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><p>XXXGHz代表了CPU的主频：CPU内数字脉冲信号震荡的频率</p>
<ul>
<li><p><strong>CPU主频</strong>(时钟频率) = 1/cpu时钟周期（1/λ）</p>
</li>
<li><p><strong>CPI</strong>(Clock cycle Per Instruction):执行一条指令所需的时钟周期数</p>
</li>
<li><p><strong>执行一条指令的耗时</strong> = CPI x CPU时钟周期</p>
<blockquote>
<p>不同的指令、CPI不同，甚至相同的指<br>令，CPI也有可能有变化</p>
</blockquote>
</li>
</ul>
<p>Eg:某CPU的主频是1000Hz，某程序包含100条指令，平均来看指令的CPI=3.该程序在该CPU上执行需要多久？</p>
<p>100 * 3 *（1/1000）= 0.3s</p>
<ul>
<li><p><strong>CPU执行时间</strong>(整个程序的耗时) = CPU时钟周期数/主频 = (指令条数*CPI)/主频</p>
</li>
<li><p><strong>IPS</strong>(Instruction Per Second):每秒执行多少条指令</p>
</li>
<li><p><strong>FLOPS</strong>(Floating-point Operations Per Second):每秒执行多少次浮点运算</p>
</li>
</ul>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><p><strong>数据通路带宽</strong>：数据总线一次所能并行传送信息的位数(各硬件部分通过数据总线传输数据)</p>
<p><strong>吞吐量：</strong>指系统在单位时间内处理请求数量。</p>
<p><strong>响应时间</strong>：指从用户向计算机发送一个请求到计算器做出相应并获得他所需要的结果的等待时间</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>主频高的CPU一定比主频低的CPU快吗</p>
<ul>
<li>不一定，如果两个CPU，A的主频为2GHz，平均CPI = 10，B的主频为1GHz，平均CPI = 1，则A的执行时间是 0.2 而B的时间是1</li>
</ul>
</li>
<li><p>若A、B两个的CPU的平均CPI相同，那么A一定快吗</p>
<ul>
<li>不一定，还得看指令系统，如果A不支持乘法指令，只能多次用加法实现，而B支持乘法指令，同样也是B快</li>
</ul>
</li>
<li><p>基准程序执行的越快则说明机器性能越好吗？</p>
<ul>
<li>基准程序中的语句存在频度差异，运行结果不能完全说明问题</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">重载与重写的区别</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-15 20:40:42" itemprop="dateModified" datetime="2020-04-15T20:40:42+08:00">2020-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>– Time:2020.4.15.</p>
<h2 id="重载和重写傻傻分不清楚"><a href="#重载和重写傻傻分不清楚" class="headerlink" title="重载和重写傻傻分不清楚"></a>重载和重写傻傻分不清楚</h2><h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h3><p>重写就是子类对父类的允许访问的方法的实现过程进行重新编写，<strong>返回值和形参</strong>都不能改变。<strong>即外壳不变，核心重写</strong></br><br>重写的好处就在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。在原则中，重写意味着可以重写任何现有的方法。例如</p>
<pre><code>class Animal{
    public void move(){
        System.out.println(&quot;hh&quot;);
    }
}
class Dog extends Animal{
    public void move(){   //这里重写了父类的move()方法。
        System.out.println(&quot;hhh&quot;)
    }
}
public class [文件名]{
    public static void main(String[] args){
        Animal a = new Animal();//创建Anmial对象
        Animal b = new Dog();//创建Dog对象

        a.move();//调用Anmial方法
        b.move();//调用Dog中重写的方法
    }
}</code></pre><p>以上的结果会是</p>
<pre><code>hh    //(这是Anmial的方法)
hhh //(这是Dog类的方法)</code></pre><p>但是如果我们在子类Dog里面加一句且在在主函数中</p>
<pre><code>class Animal{
   public void move(){
      System.out.println(&quot;动物可以移动&quot;);
   }
}
class Dog extends Animal{
   public void move(){
      System.out.println(&quot;狗可以跑和走&quot;);
   }
   public void bark(){
      System.out.println(&quot;狗可以吠叫&quot;);//新增的方法
   }
}

public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象

      a.move();// 执行 Animal 类的方法
      b.move();//执行 Dog 类的方法
      b.bark();
   }
}</code></pre><p>结果就会报错，因为在Animal里面没有bark()方法</p>
<h4 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h4><ul>
<li>参数列表必须完全与被重写方法的相同。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为final的方法不能被重写。</li>
<li>声明为static的方法不能被重写，当可以再次被声明。比如</li>
</ul>
<pre><code>public static void Zwz(){
    方法体
}  //父类
public static void Zwz(){
    方法体
}  //子类再次声明static     </code></pre><ul>
<li>子类和父类在同一个包中，那么子类可以重写父类的所有方法，除了private和final的方法</li>
<li>子类与父类不在同一个包内，子类只能重写父类的声明为public和protected的非final方法</li>
<li>构造方法不能重写</li>
<li>如果不能继承一个方法，就不能重写这个方法</li>
</ul>
<h4 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h4><p>在子类中要调用父类的方法的时候就要用super关键字</p>
<pre><code>class Animal{
   public void move(){
      System.out.println(&quot;动物可以移动&quot;);
   }
}

class Dog extends Animal{
   public void move(){
      super.move(); // 应用super类的方法
      System.out.println(&quot;狗可以跑和走&quot;);
   }
}

public class TestDog{
   public static void main(String args[]){

      Animal b = new Dog(); // Dog 对象
      b.move(); //执行 Dog类的方法

   }
}</code></pre><blockquote>
<p>方法执行的都是Dog里面的语句</p>
</blockquote>
<pre><code>动物可以移动
狗可以跑和走</code></pre><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>重载是在一个类中，<strong>方法名字相同而参数不同</strong>返回类型可以相同或者不同。</br><br>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表。常用于构造器(构造方法)的重载。</p>
<h4 id="重载规则："><a href="#重载规则：" class="headerlink" title="重载规则："></a>重载规则：</h4><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常(不懂)</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区别标准</li>
</ul>
<p>例子</p>
<pre><code>public class Overloading {
    public int test(){
        System.out.println(&quot;test1&quot;);
        return 1;
    }

    //加入了参数与上面的不一样
    public void test(int a){
        System.out.println(&quot;test2&quot;);
    }   

    //以下两个参数类型顺序不同
    public String test(int a,String s){
        System.out.println(&quot;test3&quot;);
        return &quot;returntest3&quot;;
    }   

    public String test(String s,int a){
        System.out.println(&quot;test4&quot;);
        return &quot;returntest4&quot;;
    }   

    public static void main(String[] args){
        Overloading o = new Overloading();
        System.out.println(o.test());
        o.test(1);
        System.out.println(o.test(1,&quot;test3&quot;));
        System.out.println(o.test(&quot;test4&quot;,1));
    }
}</code></pre><p>会输出</p>
<pre><code>test1            //public int test()输出结果
1                //public int test()输出结果
test2            //public void test(int a)输出结果
test3            //public String test(int a,String s)输出结果
returntest3        //public String test(int a,String s)输出结果
test4            //public String test(String s,int a)输出结果
returntest4        //public String test(String s,int a)输出结果</code></pre><h3 id="重载和重写之间的区别"><a href="#重载和重写之间的区别" class="headerlink" title="重载和重写之间的区别"></a>重载和重写之间的区别</h3><table>
        <tr>
            <th>区别点</th>
            <th>重载方法</th>
            <th>重写方法</th>
        </tr>
        <tr>
            <th>参数</th>
            <th>列表必须修改</th>
            <th>一定不能修改</th>
        </tr>
        <tr>
            <th>返回类型</th>
            <th>可以修改</th>
            <th>一定不能修改</th>
        </tr>
        <tr>
            <th>异常</th>
            <th>可以修改</th>
            <th>可以减少或删除，一定不能抛出新的或者更广的异常</th>
        </tr>
        <tr>
            <th>访问</th>
            <th>可以修改</th>
            <th>一定不能做更严格的限制(可以降低限制)</th>
        </tr>
</table>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ol>
<li><p>方法重载是一个类中定义了多个方法名相同，而题目的参数的数量不同或数量相同而类型和次序不同，则成为方法的重载。</p>
</li>
<li><p>方法重写是在子类存在的方法与父类方法同名而且参数个数与类型一样，返回值也一样的方法，就叫做重写。</p>
</li>
<li><p>方法重载是一个类的多态性的表现，而方法重写是子类与父类的一种多态性表现。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png" alt=""><br><img src="https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png" alt=""></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E8%87%AA%E5%B7%B1%E6%91%B8%E7%B4%A2%E7%9A%84C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E8%87%AA%E5%B7%B1%E6%91%B8%E7%B4%A2%E7%9A%84C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">自己摸索的C语言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-28 21:42:04" itemprop="dateModified" datetime="2020-03-28T21:42:04+08:00">2020-03-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从零开始的C语言生活"><a href="#从零开始的C语言生活" class="headerlink" title="从零开始的C语言生活"></a>从零开始的C语言生活</h1><p><strong>苦逼大学生被迫学习C语言</strong></p>
<p>IDE当然是我们可爱微软的VS2010的啦(2019不会用）<br>这软件不同于Devc++,每个源文件只能有一个主函数。<br><br/><br><br/><br>必须要记住的头文件，以及引用的库，以及最后返回空。</p>
<ol>
<li><code>#include &lt;stdio.h&gt;</code></li>
<li><code>#inclde &lt;stdlib.h&gt;</code></li>
<li><code>system(&quot;pause&quot;);</code></li>
<li><code>return 0;</code><blockquote>
<p>system在”studlib.h”的库里面定义了，所以可以直接用，没有引用此库是用不了的wo~</p>
</blockquote>
</li>
</ol>
<p>一开始学的当然是<code>printf(&quot;Hello World!\n&quot;)；</code>没啥好说的。接下来就是学习了一些基本的运算符。简单背一背还是会用的</p>
<hr/>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数始终是我有点头疼的点。<br/></p>
<ol>
<li>全局定义一个函数<br/></li>
<li>主函数里面直接运用<br/></li>
<li>主函数后解释函数的功能（注意是否有实参，有则需要返回值。<br/></li>
</ol>
<p>一个小例子<br/></p>
<ol>
<li><code>int max (int x,int y,int z)</code> /* 函数声明 */</li>
<li><code>int main{return 0;}</code>    </li>
<li><code>int max (int x,int y,int z)</code> /* 再写max函数代表什么意思 */<blockquote>
<p>一个标准的引用实参例子 (大概~</p>
</blockquote>
<hr/>

</li>
</ol>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>其实学起来不难会用才叫难。</p>
</blockquote>
<p>指针：其值为另一个变量的地址。</br><br>指针变量：就是变量存储了一分数据的指针。</br><br>例如：现在假设有一个 char 类型的变量 c，它存储了字符 ‘K’（ASCII码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。</br><br><img src="http:c.biancheng.net/uploads/allimg/190114/1IG34354-0.png" alt=""></br><br></br><br>由于指针储存的内容是地址所以给指针赋值的时候需要用上取地址符&amp;，例如：<code>int *p=&amp;a;</code></br><br>在定义指针的时候必须带有<code>*</code>，但是再次给指针赋值的时候不带<code>*</code>，例如：<code>int *p; p=&amp;b;</code></br></p>
<blockquote>
<p>CPU读写数据必须要知道数据在内存中的地址，普通变量和指针变量不过是地址的助记符，虽然<em>p和a获得的数据一样,但是他们运行过程稍有不同，a一次就可以获取数据，</em>p需要两次。</p>
</blockquote>
<p>例如变量a、p地址为0X1000、0XF0A0，指向关系如下：</br><br><img src="http://c.biancheng.net/uploads/allimg/190114/1IG3MJ-2.jpg" alt=""></br></p>
<p>也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。</p>
<p>一个小小的案例:</p>
<pre><code>   #include &lt;stdio.h&gt;

int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */

   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */

   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );

   /* 在指针变量中存储的地址 */
   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );

   /* 使用指针访问值 */
   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );

   return 0;
}</code></pre><p>执行完会有</p>
<pre><code>Address of var variable: bffd8b3c
Address stored in ip variable: bffd8b3c
Value of *ip variable: 20</code></pre><p>很明显在 <code>ip</code>与<code>*ip</code>有所不同，<code>ip</code>取的是地址，<code>*ip</code>取的是值</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</br><br><img src="https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg" alt=""></p>
<p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：</p>
<pre><code>int main ()
{
       int  var;
       int  *ptr;
       int  **pptr;

       var = 3000;

       /* 获取 var 的地址 */
       ptr = &amp;var;

       /* 使用运算符 &amp; 获取 ptr 的地址 */
       pptr = &amp;ptr;

       /* 使用 pptr 获取值 */
       printf(&quot;Value of var = %d\n&quot;, var );
       printf(&quot;Value available at *ptr = %d\n&quot;, *ptr );
       printf(&quot;Value available at **pptr = %d\n&quot;, **pptr);

       return 0;
}</code></pre><p>会输出</p>
<pre><code>Value of var = 3000
Value available at *ptr = 3000
Value available at **pptr = 3000</code></pre><h3 id="传递指针给函数"><a href="#传递指针给函数" class="headerlink" title="传递指针给函数"></a>传递指针给函数</h3><p>例如：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void getSeconds(unsigned long *par);

int main ()
{
       unsigned long sec; /* 定义无符号long型 */


       getSeconds(&amp;sec);/* 把sec的地址赋给函数形参(即指针par) */

       /* 输出实际值 */
       printf(&quot;Number of seconds: %ld\n&quot;, sec);

       return 0;
}

void getSeconds(unsigned long *par)
{
       /* 获取当前的秒数 */
       *par = time( NULL );
       return;
}</code></pre><h2 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h2><p>结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>定义结构，必须用struct语句。struct语句定义了一个包含多个成员的新的数据类型<br>格式如下：</p>
<pre><code>struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;</code></pre><p>Tag 是结构体标签。</p>
<p>member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p>
<p>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</p>
<blockquote>
<p>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。</p>
</blockquote>
<p>初始化结构体变量：</p>
<pre><code>struct Books
{
       char  title[50];
       char  author[50];
       char  subject[100];
       int   book_id;
} book = {&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456}; //与上面相互对应

int main()
{
    printf(&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;, book.title, book.author, book.subject, book.book_id);
}</code></pre><p>会输出</p>
<pre><code>title : C 语言
author: RUNOOB
subject: 编程语言
book_id: 123456</code></pre><p>我们也可以不必在struct的末尾定义一个变量 例如：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};                                        //千万别忘记加逗号

int main()
{
    struct Books book1;                    //定义变量
    struct Books book2;
    strcpy (book1.title,&quot;I love Java&quot;); //&lt;string.h&gt;提供的为变量赋字符串的功能
    strcpy (book1.author,&quot;ZWZ&quot;);
    strcpy (book1.subject,&quot;JAVA&quot;);
    book1.book_id = 1000;

    printf(&quot;Title =%s\n&quot;,book1.title); //由于是字符串，要用%s
    printf(&quot;Author =%s\n&quot;,book1.author);
    printf(&quot;Subject =%s\n&quot;,book1.subject);
    printf(&quot;id =%d\n&quot;,book1.book_id);
    system(&quot;pause&quot;);
    return 0;
}</code></pre><p>也会输出</p>
<pre><code>Title =I love Java
Author =ZWZ
Subject =JAVA
id =1000</code></pre><p>还能作为函数体参数/指针</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
void Print(struct Books book); //book改为*book
int main()
{    
    struct Books book1;
    strcpy(book1.title,&quot;I Love Java&quot;);
    strcpy(book1.author,&quot;ZWZ&quot;);
    strcpy(book1.subject,&quot;Java&quot;);
    book1.book_id = 10;

    Print(book1);                //book1改为寻址&amp;book1

    system(&quot;pause&quot;);
    return 0;
}
void Print(struct Books book)
{
    printf (&quot;Title = %s\n&quot;,book.title); //book.title改为 book-&gt;title 如下类似
    printf (&quot;author = %s\n&quot;,book.author);
    printf (&quot;subject = %s\n&quot;,book.subject);
    printf (&quot;Id = %d\n&quot;,book.book_id); 
}</code></pre><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式</p>
<p>基本格式是：</p>
<pre><code>union union tap
{    
    标准的变量定义
    标准的变量定义
    ...
}[one or more union variables]</code></pre><p>在使用共同体时候应注意不能一次性给多个变量赋值例如：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Data
{
   int i;
   float f;
   char  str[20];
};

int main( )
{
   union Data data;        

   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, &quot;C Programming&quot;);

   printf( &quot;data.i : %d\n&quot;, data.i);
   printf( &quot;data.f : %f\n&quot;, data.f);
   printf( &quot;data.str : %s\n&quot;, data.str);

   return 0;
}</code></pre><p>会出现    </p>
<pre><code>data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming</code></pre><p>i和f的值均有损耗没事因为最后付给变量的值占用了内存位置，即str成员可以完好输出的原因。但是换种方法就可以输出完全例如：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Data
{
   int i;
   float f;
   char  str[20];
};

int main( )
{
   union Data data;        

   data.i = 10;
   printf( &quot;data.i : %d\n&quot;, data.i);

   data.f = 220.5;
   printf( &quot;data.f : %f\n&quot;, data.f);

   strcpy( data.str, &quot;C Programming&quot;);
   printf( &quot;data.str : %s\n&quot;, data.str);

   return 0;
}</code></pre><p>会输出</p>
<pre><code>data.i : 10
data.f : 220.500000
data.str : C Programming</code></pre><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>基本的定义语法是    </p>
<pre><code>struct /* 冒号后面表示可识别的2进制位数 */
{
  unsigned int widthValidated ： ;
  unsigned int heightValidated;
} status ： ;</code></pre><p>例子：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct
{
  unsigned int age : 3;
} Age;

int main( )
{
   Age.age = 4;
   printf( &quot;Sizeof( Age ) : %d\n&quot;, sizeof(Age) );
   printf( &quot;Age.age : %d\n&quot;, Age.age );

   Age.age = 7;
   printf( &quot;Age.age : %d\n&quot;, Age.age );

   Age.age = 8; // 二进制表示为 1000 有四位，超出
   printf( &quot;Age.age : %d\n&quot;, Age.age );

   return 0;
}</code></pre><p>会输出</p>
<pre><code>Sizeof( Age ) : 4
Age.age : 4
Age.age : 7
Age.age : 0</code></pre><blockquote>
<p>很明显，把10进制转化为二进制的时候超过了位域规定的位数，则会使数据直接损坏。</p>
</blockquote>
<h2 id="typedef-和-define-区别"><a href="#typedef-和-define-区别" class="headerlink" title="typedef 和 #define 区别"></a>typedef 和 #define 区别</h2><ol>
<li>typedef只可以为类型定义字符名称，#define不仅可以定义字符名称，还可以为数值定义名称 即<code>#define True one</code> 也是可以的</li>
<li>typedef 由编译器执行解释，#define语句由预编译器进行处理的。</li>
</ol>
<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><ol>
<li>int getchar(void)只会读取单一的字符。可以用循环的方法获取多个字符</li>
<li>int putchar(int c)一次只会输出一个单一字符，亦可用循环获取。</li>
<li>char * gets(char*s)函数是读取一行s到缓冲区，直到终止符或EOF；</li>
<li>int puts(const char*s)函数吧字符串s和一个尾随的换行符写入stdout中。</li>
</ol>
<pre><code>#include &lt;stdio.h&gt;

int main( )
{
   char str[100];

   printf( &quot;Enter a value :&quot;);
   gets( str );

   printf( &quot;\nYou entered: &quot;);
   puts( str );
   return 0;
}</code></pre><p>如果输入 i love hxm<br>会弹出 i love hxm</p>
<blockquote>
<p>如果改变为str[1]，再输入以上语句，虽然会输出出结果，但是会报错！我也不知道为啥报错还能输出出来= =</p>
</blockquote>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归指的是在函数的定义中使用函数自身的方法。一个简单的求阶乘的例子：</p>
<pre><code>#include &lt;stdio.h&gt;

double factorial(unsigned int i)
{
   if(i &lt;= 1)
   {
      return 1;
   }
   return i * factorial(i - 1);
}
int  main()
{
    int i = 15;
    printf(&quot;%d 的阶乘为 %f\n&quot;, i, factorial(i));
    return 0;
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-23 10:58:00" itemprop="dateModified" datetime="2020-07-23T10:58:00+08:00">2020-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><hr>
<ul>
<li>软件架构CS/BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
</ul>
<h2 id="P1-网络编程入门"><a href="#P1-网络编程入门" class="headerlink" title="P1 网络编程入门"></a>P1 网络编程入门</h2><h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><ul>
<li><strong>C/S结构</strong>：全称为Client/Server结构，是指客户端和服务器结构，常见的有QQ，迅雷等</li>
<li><strong>B/S结构</strong>：全称为Browser/Server结构，是指浏览器和服务器结构，常见浏览器有谷歌，火狐等。</li>
</ul>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><hr>
<ul>
<li><strong>网络通信协议</strong>：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机间才能进行通信，这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时，最终完成数据交换。</li>
<li><strong>TCP/IP协议：</strong>传输控制协议/因特网互联协议(transimission Control Protocol/Internet Protocol),是Internet最基本，最广泛的协议。定义了计算机如何连入Internet，以及数据如何在它们之间传输的标准。它内部包含一系列的用于处理数据通信的协议，并用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="https://i.loli.net/2020/07/22/Ad4bSoFKqreBt97.png" alt="1595417186_1_.jpg"></p>
<h3 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h3><p>通信的协议还是比较复杂的，<code>java.net</code>包中包含的类和接口，他们提供低层次的通信细节，我们可以直接使用这些类和接口，不需要考虑其他细节。</p>
<p><code>java.net</code>包中提供了两种常见的网络协议的支持：</p>
<ul>
<li>TCP:传输控制协议(Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之气那在发送端和接收端建立逻辑连接。然后传输数据。它提供了两台计算机之间可靠无差的数据传输。<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端和服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发送连接请求。等待服务器的确认</li>
<li>第二次握手，服务器端向客户端回送一个响应。通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器发送确认信息，确认连接。整个交互过程如下图。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/07/22/Rf1Ne3xukT2DJMc.png" alt="1595421452_1_.jpg"></p>
<p>完成三次握手，链接建立之后客户端和服务器就可以开始进行数据传输了。由于这种面向链接的特性。TCP协议以保证传输数据的安全，所以应用很广泛。比如下载文件、浏览网页等。</p>
<ul>
<li>UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。数据传输时。不需要建立连接。不管对象端服务是否启动，直接将数据、数据源和目的地都封装在一个数据包中，直接发送。每个数据包的大小都在64k以内。不可以靠协议。因为无连接。所以传输速度快。但容易丢失数据。日常中，例如视频会议、QQ聊天等。</li>
</ul>
<h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul>
<li>协议：计算机网络通信必须遵守的规则，已经介绍过了。如上<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4></li>
<li>IP地址：指<strong>互联网协议地址(Internet Protocol Address)</strong>，俗称IP。IP地址用来给一个网络中的计算设备做唯一的编号。如果我们把”个人电脑”比作一台电话的话，那么IP地址就相当于电话号码。<ul>
<li>其分类为<ul>
<li>IPv4：是一个32位的二进制数。通常被分为4个字节。表示成<code>a，b，c，d</code>的形式，例如<code>192.168.1.1</code>其中a、b、c、d都是0-255之间的十进制整数，那么最多可以表示42亿个</li>
<li>IPV6：由于互联网的蓬勃发展，IP地址的需求越来越大，但是网络地址有限，使得IP贼紧张。为了扩大地址空间，拟通过IPV6重新定义地址空间，采用128位地址长度，每16个字节一组，分为8组16进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>,号称可以位全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程(应用程序)的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号就可以唯一识别标识设备中的进程了。</strong></p>
<ul>
<li>端口号：用两个字节表示的整数，它的取值范围是0-65535。其中，0-1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另一个服务或应用所占用，会导致当前程序启动失败</li>
</ul>
<p><img src="https://i.loli.net/2020/07/20/wcYpmOKXdbTHWG9.png" alt="1595204966_1_.jpg"></p>
<blockquote>
<p>端口号就像门牌号一样我们可以通过IP来寻找另一台的电脑，端口号是逻辑端口，我们无法直接查看，可以利用一些软件看到或者是用cmd命令<code>findstr &quot;PID号&quot;</code>查看是什么应用使用了该端口。</p>
</blockquote>
<blockquote>
<p>常用的端口有80 网络端口，比如<code>www.baidu.com:80</code>才可以进入，如果是<code>www.baidu.com:79</code>则进入失败。</p>
</blockquote>
<blockquote>
<p>数据库 mysql：3306 oracle：1521</p>
</blockquote>
<blockquote>
<p>Tomcat服务器：8080</p>
</blockquote>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code>三元组合，就可以标识网络中的进程了。那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><p><img src="https://i.loli.net/2020/07/20/bnOMfmxyUuwC27H.png" alt="1595206041_1_.jpg"></p>
<h2 id="TCP文件上传案例"><a href="#TCP文件上传案例" class="headerlink" title="TCP文件上传案例"></a>TCP文件上传案例</h2><p><img src="https://i.loli.net/2020/07/21/1KPBMXrcLDOS5Tm.png" alt="1595330645_1_.jpg"></p>
<p><img src="https://i.loli.net/2020/07/22/YQZy4DaPgOX9Bjk.png" alt="1595406837_1_.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0&Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0&Lambda/" class="post-title-link" itemprop="url">线程池&Lambda</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-27 12:30:15" itemprop="dateCreated datePublished" datetime="2021-03-27T12:30:15+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-12 15:01:46" itemprop="dateModified" datetime="2020-07-12T15:01:46+08:00">2020-07-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程池与Lambda语法"><a href="#线程池与Lambda语法" class="headerlink" title="线程池与Lambda语法"></a>线程池与Lambda语法</h1><h2 id="1-1线程间通信"><a href="#1-1线程间通信" class="headerlink" title="1.1线程间通信"></a>1.1线程间通信</h2><p>概念：多个线程在处理同一个资源，但是处理的动作(线程的任务)却不相同.</p>
<p>比如线程A用于生产包子，线程B用来吃包子，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在了线程通信的问题。</p>
<p><strong>为什么要处理线程间通信</strong></p>
<p>多个线程并发执行时，在默认CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望其执行的有规律，那么多线程之间就要有一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源</strong></p>
<p>多个线程在处理同一资源，且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作，就是多个线程在操作同一份数据时，避免对同一共享变量的争夺，也就是我们需要通过一定的手段使各个线程能有效的利用资源，而这种手段即 – <strong>等待唤醒机制</strong></p>
<h2 id="1-2等待唤醒机制"><a href="#1-2等待唤醒机制" class="headerlink" title="1.2等待唤醒机制"></a>1.2等待唤醒机制</h2><h3 id="什么是等待唤醒机制"><a href="#什么是等待唤醒机制" class="headerlink" title="什么是等待唤醒机制"></a>什么是等待唤醒机制</h3><p>这个是多个线程之间一种协作的机制，谈到线程我们经常想到的是线程间的竞争(race),比如去争夺锁，但并不是故事的全部,线程间也会有协作机制。就好比公司里你和你的同事们。你们可能存在升职的竞争，但是更多是工作上的合作</p>
<p>在一个线程进行了一些规定后，就进入了<code>wait()</code>，等待其他线程执行完他们的指定代码过后，再将其唤醒<code>notify()</code>；在多个线程进行等待时，可以使用1notifyAll()`来唤醒所有的等待线程。</p>
<p><strong>wait\notify</strong>就是一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不在参与调度。进入wait set中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即WAITING.它还要等着别的线程执行一个特别的动作，也就是<strong>通知(notify)</strong>在这个对象上等待的线程从wait set中释放。重新进入了调度队列(ready queue)中。</li>
<li>notify:则选取所同志对象的wait set 中的一个线程释放，如：餐厅有空位置后，等待就餐醉酒的顾客会先入座。</li>
<li>notifyAll：释放所同志对象在wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立刻恢复执行状态，因为它当初在同步代码块里面，而它不具有锁，所以它需要再次获得锁才可以执行，成功后才能调用wait方法之后的地方回复执行。</p>
</blockquote>
<blockquote>
<p>总结：</p>
</blockquote>
<blockquote>
<ul>
<li>如果获得锁，则从WAITING状态变成RUNNABLE状态</li>
<li>如果没获得锁，则从WAITING状态变成BLOCKED状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong>  </p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用，因为：对应的锁对象可以notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="1-3生产者与消费者问题"><a href="#1-3生产者与消费者问题" class="headerlink" title="1.3生产者与消费者问题"></a>1.3生产者与消费者问题</h2><p>等待唤醒机制其实是经典的”生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<pre><code>包子铺线程生产包子，吃货线程消费包子。当包子没有时(状态为false)，吃货线程等待，包子铺线程生产包子(即包子状态为true)，
并通知吃货线程(解除吃货的等待状态)，因为已经包子，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁
的获取情况，如果吃货获取到锁，那么就执行吃包子动作，包子吃完(包子状态为false)，并通知包子铺进程(接触包子铺的等待状态)，
吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获得情况</code></pre><p><strong>代码如下</strong></p>
<p>包子资源类：</p>
<pre><code>/*
        资源类：包子类
        设置包子的属性
            皮
            馅
            包子的状态：有 true，没有 false
*/
    public class Baozi {
        //皮
        String pi;
        //馅
        String xian;
        //包子的状态：有 true，没有 false，设置初始值为false没有包子
        boolean flag = false;
    }

包子铺线程类：

/*
    生产者(包子铺类)：是一个线程类，可以继承Thread
    设置线程任务(run)：生产包子
    对包子的状态进行判断
    true：有包子
        包子铺调用wait方法进入等待状态
    false：没有包子
        包子铺生产包子
        增加一些趣味性：交替生产两种包子
            两种状态(i%2==0)
        包子铺生产好了包子
        修改包子的状态为true
        唤醒吃货线程，让吃货线程吃包子

    注意事项：
        包子铺线程喝包子线程关系--&gt;通信(互斥)
        必须同步技术保证两个线程只能有一个在执行
        锁对象必须保证唯一。可以使用包子对象为锁对象
        包子铺类和吃货类需要把包子对象作为参数传递进来
            1.需要在成员对象位置创建一个包子变量
            2.使用带参数构造方法，为这个包子变量赋值
*/
public class BaoZiPu extends Thread{
    //定义包子变量
    private Baozi bz;

    //2.使用带参数构造方法，为这个包子变量赋值
    public BaoZiPu(Baozi bz){
        this.bz = bz;
    }

    @Override
    public void run() {
        int count = 0;
        //让包子铺一直生产包子
        while (true){
        //必须同时同步技术保证两个线程只有一个执行
        synchronized (bz) {
            //对包子的状态进行判断
            if (bz.flag == true) {
                //包子铺调用wait方法进入等待状态
                try {
                    bz.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            //被唤醒之后执行，包子铺生产包子
            //增加一些趣味性：交替生产两种包子
            if (count % 2 == 0) {
                //生产薄皮三鲜馅包子
                bz.pi = &quot;薄皮&quot;;
                bz.xian = &quot;三鲜馅&quot;;
            } else {
                //生产冰皮牛肉大葱馅包子
                bz.pi = &quot;冰皮&quot;;
                bz.xian = &quot;牛肉大葱馅&quot;;
            }
            count++;
            System.out.println(&quot;包子铺正在生产：&quot; + bz.pi + bz.xian + &quot;的包子&quot;);
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //包子铺生产好了包子
            //修改包子的状态为true
            bz.flag = true;
            //唤醒吃货线程；让吃货线程吃包子
            bz.notify();
            System.out.println(&quot;包子铺正在生产：&quot; + bz.pi + bz.xian + &quot;的包子,吃货可以开吃了&quot;);
            }
        }
    }
}</code></pre><p>吃货类：</p>
<pre><code>/*
    消费者(吃货)类：是一个线程类，可以继承Thread
    设置线程任务(run):吃包子
    对包子状态进行判断
    false：没有包子
        吃货调用wait方法进入等待状态
    true：有包子
        吃货吃包子
        吃货吃完包子
        修改包子状态为false
        吃货唤醒包子铺线程，生产包子
*/
public class ChiHuo extends Thread{
    //1.需要在成员位置创建一个包子变量
    private Baozi bz;

    //2.使用带参数和构造方法，为这个包子变量赋值
    public ChiHuo(Baozi bz){
        this.bz = bz;
    }
    //设置线程任务(吃包子)
    @Override
    public void run() {
        while (true){
            //必须同时同步技术保证两个线程只有一个执行
            synchronized (bz){
                //对包子状态进行判断
                if (bz.flag==false){
                    //吃货调用wait等待状态
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //唤醒之后执行的代码，吃包子
                System.out.println(&quot;吃货正在吃&quot;+bz.pi+bz.xian+&quot;的包子&quot;);
                //吃货吃完包子
                //秀嘎包子的状态为false
                bz.flag = false;
                bz.notify();
                System.out.println(&quot;吃货已经吃完&quot;+bz.pi+bz.xian+&quot;的包子,包子铺赶紧做包子&quot;);
                System.out.println(&quot;----------------------------------------------&quot;);

            }
        }
    }
}</code></pre><p>测试类：</p>
<pre><code>public class TestBaoZi {
    public static void main(String[] args) {
        //创建包子对象
        Baozi bz = new Baozi();
        //创建包子铺线程，开启，生产包子；
        new BaoZiPu(bz).start();
        new ChiHuo(bz).start();
    }
}</code></pre><p>执行结果：</p>
<pre><code>包子铺正在生产：薄皮三鲜馅的包子
包子铺正在生产：薄皮三鲜馅的包子,吃货可以开吃了
吃货正在吃薄皮三鲜馅的包子
吃货已经吃完薄皮三鲜馅的包子,包子铺赶紧做包子
----------------------------------------------
包子铺正在生产：冰皮牛肉大葱馅的包子
包子铺正在生产：冰皮牛肉大葱馅的包子,吃货可以开吃了
吃货正在吃冰皮牛肉大葱馅的包子
吃货已经吃完冰皮牛肉大葱馅的包子,包子铺赶紧做包子
----------------------------------------------</code></pre><h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1线程池思想概述"><a href="#2-1线程池思想概述" class="headerlink" title="2.1线程池思想概述"></a>2.1线程池思想概述</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，频繁创建线程会导致系统资源被浪费，因为创建喝销毁线程都需要时间。</p>
<p>因此线程池就解决了这麻烦。</p>
<h2 id="2-2线程池的概念"><a href="#2-2线程池的概念" class="headerlink" title="2.2线程池的概念"></a>2.2线程池的概念</h2><ul>
<li>线程池：其实就说一个容纳多个线程的容器，其中线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池很多操作都是与优化资源相关，所以说多无益。</p>
<p><img src="https://i.loli.net/2020/07/10/UzQNyHI3hEdapFb.png" alt="1594382301.jpg"></p>
<h2 id="2-3线程池的使用"><a href="#2-3线程池的使用" class="headerlink" title="2.3线程池的使用"></a>2.3线程池的使用</h2><p>java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上来讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生产一些常用的线程池，官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池，也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象的方法如下：</p>
<ul>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li>
</ul>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不关闭)；</li>
</ol>
<p>Runnable实现类代码：</p>
<pre><code>//2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
    public class Runnbale implements Runnable{
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+&quot;创建了个新线程&quot;);
        }
    }</code></pre><p>线程池测试类：</p>
<pre><code>/*
    线程池：JDK1.5之后提供的
    java.util.concurrent.Executors:线程池的工厂类，用来生产线程池
    Executors类中的静态方法：
        static ExecutorService newFixedThreadPool(int nThreads)
        创建一个可重用固定线程数的线程池

        参数：
            int nThreads：创建线程池中包含的线程数量
        返回值：
            ExecutorService接口：返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收(面向接口编程)

        java.util.concurrent.ExecutorService:线程池接口
            用来从线程池中获取线程，调用start方法，执行线程任务
                submit(Runnable task) 提交一个Runnable任务用于执行
            关闭/销毁线程池的方法
                void shutdown()

         线程池的使用步骤：
            1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
            2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
            3.调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。
            4.调用ExecutorService中的方法shutdown销毁线程池(不建议使用)

*/
public class TestThreadPool {
    public static void main(String[] args) {
        //1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        //3.调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。
        es.submit(new Runnbale());
        es.submit(new Runnbale());
        es.submit(new Runnbale());
        //4.调用ExecutorService中的方法shutdown销毁线程池(不建议使用)
        es.shutdown();
    }
}</code></pre><h2 id="Lambda表达式-λ"><a href="#Lambda表达式-λ" class="headerlink" title="Lambda表达式(λ)"></a>Lambda表达式(λ)</h2><h3 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h3><p>在数学里，<strong>函数</strong>就是由输入量和输出量的一套计算方案。相对而言，面向对象过分强调”必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong></p>
<p>面向对象思想：</p>
<p>做一件事情找一个能解决这个事情的对象，调用对象的方法，完成事情。</p>
<p>函数式编程思想：只要能获取到结果，谁去做，怎么做的都不重要，重视结果而不是过程。</p>
<h2 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h2><p>###传统写法<br>当你需要启动一个线程去完成任务时，通常通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。</p>
<pre><code>public class Demo01Runnable{
    public static void main(String[] args){
        //匿名内部类
        Runnable task = new Runnable(){
            @Override
            public void run(){
                //覆盖重写抽象方法
                System.out.println(&quot;多线程任务执行!&quot;)
            }
        };
        new Thread(task).start();//启动线程
    }
}</code></pre><p>本着”一切皆为对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类，可以分析出几点内容：</p>
<ul>
<li>Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心；</li>
<li>为了指定run的方法体，不得不需要Runnable接口的实现类；</li>
<li>为了省去一个RunnableImpl实现类的麻烦，不得不使用匿名内部类；</li>
<li>必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不重写一遍，且不能写错。</li>
<li>实际上，似乎只有方法体才是关键所在。</li>
</ul>
<h2 id="3-3编程思想转换"><a href="#3-3编程思想转换" class="headerlink" title="3.3编程思想转换"></a>3.3编程思想转换</h2><p><strong>做什么，而不是怎么去做</strong></p>
<p>我们真希望创建一个匿名内部类嘛？不是，我们为了创建这件事不得不创建了一个对象罢了。我们只是想把：<strong>将run方法体内的代码传递给Thread类</strong></p>
<h2 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类可以鞋厂简单的Lambda表达式达到等效：</p>
<pre><code>public class Demo02LambdaRunnable{
    public static void main(String[] args){
        new Thread(()-&gt;System.out.println(&quot;多线程任务执行！&quot;)).start();//启动线程
    }
}</code></pre><p>这段代码和刚才的执行效果是完全相同的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有”不得不创建接口对象”的束缚，不再有”抽象方法覆盖重写”的负担。</p>
<h2 id="3-5回顾匿名内部类"><a href="#3-5回顾匿名内部类" class="headerlink" title="3.5回顾匿名内部类"></a>3.5回顾匿名内部类</h2><p>Lambda是怎么样击败面向对象的？</p>
<pre><code>()-&gt;System.out.println(&quot;多线程任务执行！&quot;)\</code></pre><p>为了了解Lambda的语义，我们需要从传统的代码起步。</p>
<p><strong>使用实现类</strong></p>
<p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start()</code>方法，而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<pre><code>/*
    创建Runnable接口的实现类，重写run方法，设置线程任务
*/
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
    }
}</code></pre><p>创建该实现类的对象作为Thread类的构造参数：</p>
<pre><code>/*
    实现Runnable接口的方式实现多线程程序
*/
public class Demo01Runnable {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl r = new RunnableImpl();
        //创建Thread类对象，构造方法中传递Runnable接口的实现类
        Thread t = new Thread(r);
        t.start();
//---------------------------------------------------------------
        //简化代码，使用匿名内部类，实现多线程程序
        Runnable run = new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
            }
        };
        new Thread(run).start();
//---------------------------------------------------------------
        //继续简化代码
        new Thread(new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;新的线程创建了&quot;);
            }
        }).start();
    }
}</code></pre><h3 id="匿名内部类的好处和弊端"><a href="#匿名内部类的好处和弊端" class="headerlink" title="匿名内部类的好处和弊端"></a>匿名内部类的好处和弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>，另一方面，匿名内部类的语法——<strong>实在太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，Runnable接口有一个run方法的定义：</p>
<ul>
<li>public abstract void run();</li>
</ul>
<p>即制定了一种做事情的方案(其实就是一个函数)：</p>
<ul>
<li><strong>无参数：</strong>不需要任何条件计科执行该方案。</li>
<li><strong>无返回值：</strong>该方案不产生任何结果。</li>
<li><strong>代码块(方法体)：</strong>该方案的具体执行步骤。</li>
</ul>
<p>同语义体现在<code>Lambda</code>语法中更简单：</p>
<pre><code>()-&gt;System.out.println(&quot;多线程执行！&quot;)</code></pre><ul>
<li>前面的小括号即<code>run</code>方法的参数(无)，代表不需要任何条件；</li>
<li>中间的一个剪头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6Lambda标准格式"><a href="#3-6Lambda标准格式" class="headerlink" title="3.6Lambda标准格式"></a>3.6Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由3个部分组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<pre><code>(参数类型 参数名称)-&gt;{代码语句}</code></pre><p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空，多个参数则用逗号隔开。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7练习：使用Lambda标准格式-无参无返回值"><a href="#3-7练习：使用Lambda标准格式-无参无返回值" class="headerlink" title="3.7练习：使用Lambda标准格式(无参无返回值)"></a>3.7练习：使用Lambda标准格式(无参无返回值)</h2><p><strong>题目</strong><br>给定一个厨子<code>cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数，无返回值。</p>
<pre><code>public interface Cook {
    //定义无参数无返回值的方法
    void makeFood();
}</code></pre><p>在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出”吃饭了！”字样：</p>
<pre><code>/*
    需求：
        给定一个厨子cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值.
        使用Lambda的标准格式调用invokeCook方法，打印输出&quot;吃饭啦！&quot;字样
*/
public class Practice {
    public static void main(String[] args) {
        //调用invokeCook方法，参数是Cook接口，传递Cook接口的匿名内部类对象
        invokeCook(new Cook() {
            @Override
            public void makeFood(){
                System.out.println(&quot;吃饭了&quot;);
            }
        });

        //使用Lambda表达式，简化匿名内部类的书写
        invokeCook(()-&gt;{
            System.out.println(&quot;吃饭了&quot;);
        });
    }
    //定义一个方法，参数传递Cook接口，方法内部调用Cook接口中的方法makeFood
    public static void invokeCook(Cook cook){
        cook.makeFood();
    }
}</code></pre><blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体</p>
</blockquote>
<h2 id="3-8Lambda的参数和返回值"><a href="#3-8Lambda的参数和返回值" class="headerlink" title="3.8Lambda的参数和返回值"></a>3.8Lambda的参数和返回值</h2><pre><code>/*
    Lambda表达式又参数有返回值的练习
    需求：
        使用数组存储多个Person对象
        对数组中的Person对象使用Arrays的sort方法进行升序排序
*/
public class Practice2 {
    public static void main(String[] args) {
        Person[] arr = {
                new Person(&quot;zwz&quot;,19),
                new Person(&quot;hxm&quot;,18),
                new Person(&quot;yhx&quot;,20)
        };
/*
        //对数组中的Person对象使用Arrays的sort方法进行升序(前面-后面)排序
        Arrays.sort(arr, new Comparator&lt;Person&gt;() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()-o2.getAge();
            }
        });
*/
        //使用Lambda表达式，简化匿名内部类
        Arrays.sort(arr,(Person o1, Person o2)-&gt;{
            return o1.getAge()-o2.getAge();
        });

        //遍历数组
        for (Person p : arr){
            System.out.println(p);
        }
    }
}</code></pre><p><strong>代码分析</strong></p>
<p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序， Arrays.sort 方法需要排序规则，即 Comparator 接口的实例，抽象方法 compare 是关键；</li>
<li>为了指定 compare 的方法体，不得不需要 Comparator 接口的实现类；</li>
<li>为了省去定义一个 ComparatorImpl 实现类的麻烦，不得不使用匿名内部类；</li>
<li>必须覆盖重写抽象 compare 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；</li>
<li>实际上，只有参数和方法体才是关</li>
</ul>
<h2 id="3-9练习：使用Lambda标准格式-有参有返回"><a href="#3-9练习：使用Lambda标准格式-有参有返回" class="headerlink" title="3.9练习：使用Lambda标准格式(有参有返回)"></a>3.9练习：使用Lambda标准格式(有参有返回)</h2><p><strong>题目</strong></p>
<p>给定一个计算机<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<pre><code>public interface Calculator{
    int calc(int a,int b);
}</code></pre><p>测试类中：</p>
<pre><code>/*
    Lambda表达式有参数有返回值的练习
    需求：
        给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值
        使用Lambda的标准格式调用invokeCalc方法，完成120+130的相加计算
*/
public class Practice3 {
    public static void main(String[] args) {
        //调用invokeCalc方法，方法的参数是一个接口，可以使用匿名内部类
        invokeCalc(10, 20, new Calculator() {
            @Override
            public int calc(int a, int b) {
                return a+b;
            }
        });

        //使用Lambda表达式
        invokeCalc(120,130,(int a,int b)-&gt;{
            return a+b;
        });
    }

    //定义一个方法，参数传递两个int类型整数
    //参数传递Calculator中的方法calc计算两个整数的和

    public static void invokeCalc(int a,int b,Calculator c){
        int sum = c.calc(a,b);
        System.out.println(sum);
    }
}</code></pre><blockquote>
<p>在Lambda表达式里面 小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数。大括号表示<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><p><strong>可推导即可省略</strong></p>
<p>Lambda强调的是”做什么”而不是”怎么做”,所以凡是可以根据上下文推导得知的信息，都可以省略，比如上述还可以用简便写法。</p>
<pre><code>public static void main(String[] aegs){
    invokeCalc(120,130,(a,b) -&gt; a+b);
}</code></pre><p><strong>省略规则</strong></p>
<p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参数，</strong>则小括号可以省略。</li>
<li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号，return关键字，及其语句分号。</li>
</ol>
<h3 id="3-11-Lambda的使用前提"><a href="#3-11-Lambda的使用前提" class="headerlink" title="3.11 Lambda的使用前提"></a>3.11 Lambda的使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong></br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong></br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>P.S 有且仅有一个抽象方法的接口，称为<strong>“函数式接口”</strong></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
