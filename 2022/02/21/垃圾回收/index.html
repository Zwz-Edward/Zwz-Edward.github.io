<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yt32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yt16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="垃圾回收如何判断对象可以回收1.1 引用计数法  当两个对象相互引用，由于两个对象的引用数不能归零，所以不能垃圾回收  1.2 可达性分析算法 Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能沿着GC Root对象为起点的引用链找到该对象，找不到则表示可以垃圾回收 可以作为GC Root的对象 虚拟机栈（栈帧中的本地变量表）中引用的对象。　 方法区中类静态属">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收">
<meta property="og:url" content="http://yoursite.com/2022/02/21/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="ZWZ的博客嘻嘻">
<meta property="og:description" content="垃圾回收如何判断对象可以回收1.1 引用计数法  当两个对象相互引用，由于两个对象的引用数不能归零，所以不能垃圾回收  1.2 可达性分析算法 Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能沿着GC Root对象为起点的引用链找到该对象，找不到则表示可以垃圾回收 可以作为GC Root的对象 虚拟机栈（栈帧中的本地变量表）中引用的对象。　 方法区中类静态属">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2022/02/084bfa5f06a97cf1.jpg">
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2022/02/5b90628670b2d0a8.jpg">
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2022/02/ca7e2cc87fcc1b6a.png">
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2022/02/8dac87c4d79b8f70.png">
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2022/02/4ba82ede1b227199.png">
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2022/02/18a72b90c921af8d.jpg">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png">
<meta property="article:published_time" content="2022-02-21T12:51:39.762Z">
<meta property="article:modified_time" content="2022-02-23T08:14:39.715Z">
<meta property="article:author" content="ZWZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ftp.bmp.ovh/imgs/2022/02/084bfa5f06a97cf1.jpg">

<link rel="canonical" href="http://yoursite.com/2022/02/21/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>垃圾回收 | ZWZ的博客嘻嘻</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWZ的博客嘻嘻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/21/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZWZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWZ的博客嘻嘻">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          垃圾回收
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-21 20:51:39" itemprop="dateCreated datePublished" datetime="2022-02-21T20:51:39+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-23 16:14:39" itemprop="dateModified" datetime="2022-02-23T16:14:39+08:00">2022-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h3 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p><img src="https://ftp.bmp.ovh/imgs/2022/02/084bfa5f06a97cf1.jpg" alt=""></p>
<blockquote>
<p>当两个对象相互引用，由于两个对象的引用数不能归零，所以不能垃圾回收</p>
</blockquote>
<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><ul>
<li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能沿着GC Root对象为起点的引用链找到该对象，找不到则表示可以垃圾回收</li>
<li>可以作为GC Root的对象<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h4><p><img src="https://ftp.bmp.ovh/imgs/2022/02/5b90628670b2d0a8.jpg" alt=""></p>
<blockquote>
<ul>
<li><p>强引用：</p>
<ul>
<li>没有GC Root 直接或间接引用 就会被垃圾回收</li>
</ul>
</li>
<li><p>软引用（SoftReference）：</p>
<ul>
<li>如果没有强引用直接引用该对象，则<p color="red"><strong>在垃圾回收且内存不足时被回收</strong><p></li>
<li>可以配合引用队列来释放软引用自身</li>
</ul>
</li>
<li><p>弱引用（WeakReference）：</p>
<ul>
<li>如果没有强引用直接引用该对象，则<p color="red"><strong>在垃圾回收时被回收</strong><p></li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
</li>
<li><p>虚引用（PhantomReference）：</p>
<ul>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，<br>由 Reference Handler 线程调用虚引用相关方法释放直接内存</li>
</ul>
</li>
<li><p>终结器引用（FinalReference）</p>
<ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象<br>暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize<br>方法，第二次 GC 时才能回收被引用对象</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>软引用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line"></span><br><span class="line">    List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"循环结束："</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在垃圾回收的时候发现内存不足，则会回收软引用指向的对象，此处即为ref，回收之后为null。 但是软引用本身是不会被回收的。若想要被回收则要加入一个引用队列(ReferenceQueue)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>( poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过获取引用队列中的软引用，一个个删除的方式来删除软引用</p>
<p><strong>弱引用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>( poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现和软引用差不多，以及回收弱引用也是用引用队列</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h4><p>定义： Mark Sweep<br>速度较快</p>
<p><img src="https://ftp.bmp.ovh/imgs/2022/02/ca7e2cc87fcc1b6a.png" alt=""></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="2-2-标记整理算法"><a href="#2-2-标记整理算法" class="headerlink" title="2.2 标记整理算法"></a>2.2 标记整理算法</h4><p><img src="https://ftp.bmp.ovh/imgs/2022/02/8dac87c4d79b8f70.png" alt=""></p>
<p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h4><p><img src="https://ftp.bmp.ovh/imgs/2022/02/4ba82ede1b227199.png" alt=""></p>
<p><img src="https://ftp.bmp.ovh/imgs/2022/02/18a72b90c921af8d.jpg" alt=""></p>
<p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<h3 id="分代垃圾回收机制"><a href="#分代垃圾回收机制" class="headerlink" title="分代垃圾回收机制"></a>分代垃圾回收机制</h3><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p>
<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<ul>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的<br>对象年龄加 1并且交换 from to</li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时<br>间更长</li>
</ul>
<h4 id="相关-VM-参数"><a href="#相关-VM-参数" class="headerlink" title="相关 VM 参数"></a>相关 VM 参数</h4><table>
<thead>
<tr>
<th>堆初始大小</th>
<th>-Xms</th>
</tr>
</thead>
<tbody><tr>
<td>堆最大大小</td>
<td>-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td>幸存区比例（动态）</td>
<td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>FullGC 前 MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ol>
<li>串行<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
</ul>
</li>
<li>吞吐量优先<ul>
<li>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高</li>
</ul>
</li>
<li>响应时间优先<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让单次 STW 的时间最短 (触发了多次了GC 单次时间为0.1 0.1 0.1 0.1 0.1 0.1 = 0.5）</li>
</ul>
</li>
</ol>
<h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p>
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
<h4 id="吞吐量优先-（JDK1-8默认使用的垃圾回收器）"><a href="#吞吐量优先-（JDK1-8默认使用的垃圾回收器）" class="headerlink" title="吞吐量优先 （JDK1.8默认使用的垃圾回收器）"></a>吞吐量优先 （<strong>JDK1.8默认使用</strong>的垃圾回收器）</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></p>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel  Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" target="_blank" rel="noopener">https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png</a></p>
<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
<p> CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h3 id="G1-garbage-first"><a href="#G1-garbage-first" class="headerlink" title="G1    (garbage first)"></a>G1    (garbage first)</h3><p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<p><strong>适用场景</strong></p>
<ul>
<li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的 Region</li>
<li>整体上是 标记+整理 算法，两个区域之间是 复制 算法</li>
</ul>
<p><strong>相关 JVM 参数：</strong></p>
<p>​    -XX:+UseG1GC<br>​    -XX:G1HeapRegionSize=size</p>
<p>​    -XX:MaxGCPauseMillis=time</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="多线程">
      <i class="fa fa-chevron-left"></i> 多线程
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何判断对象可以回收"><span class="nav-number">1.0.1.</span> <span class="nav-text">如何判断对象可以回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-引用计数法"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">1.1 引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-可达性分析算法"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">1.2 可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-四种引用"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">1.3 四种引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">1.0.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-标记清除"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">2.1 标记清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-标记整理算法"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">2.2 标记整理算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-复制"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">2.3 复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代垃圾回收机制"><span class="nav-number">1.0.3.</span> <span class="nav-text">分代垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回收流程"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">回收流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关-VM-参数"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">相关 VM 参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器"><span class="nav-number">1.0.4.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#串行"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">串行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-收集器"><span class="nav-number">1.0.4.1.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew-收集器"><span class="nav-number">1.0.4.1.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">1.0.4.1.3.</span> <span class="nav-text">Serial Old 收集器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#吞吐量优先-（JDK1-8默认使用的垃圾回收器）"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">吞吐量优先 （JDK1.8默认使用的垃圾回收器）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scavenge-收集器"><span class="nav-number">1.0.4.2.1.</span> <span class="nav-text">Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Old-收集器"><span class="nav-number">1.0.4.2.2.</span> <span class="nav-text">Parallel Old 收集器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应时间优先"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">响应时间优先</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-收集器"><span class="nav-number">1.0.4.3.1.</span> <span class="nav-text">CMS 收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1-garbage-first"><span class="nav-number">1.0.5.</span> <span class="nav-text">G1    (garbage first)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZWZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
